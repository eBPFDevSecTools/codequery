cscope header:  ./test/balancer_kern.c

cscope header:  ./test/decap_kern.c

cscope header:  ./test/x.c

cscope header:  ./test/xdp_root.c

cscope header:  ./test/healthchecking_kern.c

cscope header:  ./test/xdp_pktcntr.c

cscope header:  ./test/healthchecking_ipip.c

cscope header:  ./test/introspection.h

copying header:  ./test/introspection.h
cscope header:  ./test/balancer_maps.h

copying header:  ./test/balancer_maps.h
cscope header:  ./test/pckt_encap.h

copying header:  ./test/pckt_encap.h
cscope header:  ./test/balancer_consts.h

copying header:  ./test/balancer_consts.h
cscope header:  ./test/encap_helpers.h

copying header:  ./test/encap_helpers.h
cscope header:  ./test/flow_debug.h

copying header:  ./test/flow_debug.h
cscope header:  ./test/jhash.h

copying header:  ./test/jhash.h
cscope header:  ./test/control_data_maps.h

copying header:  ./test/control_data_maps.h
cscope header:  ./test/healthchecking_structs.h

copying header:  ./test/healthchecking_structs.h
cscope header:  ./test/balancer_structs.h

copying header:  ./test/balancer_structs.h
cscope header:  ./test/healthchecking_maps.h

copying header:  ./test/healthchecking_maps.h
cscope header:  ./test/balancer_helpers.h

copying header:  ./test/balancer_helpers.h
cscope header:  ./test/pckt_parsing.h

copying header:  ./test/pckt_parsing.h
cscope header:  ./test/flow_debug_maps.h

copying header:  ./test/flow_debug_maps.h
cscope header:  ./test/decap_maps.h

copying header:  ./test/decap_maps.h
cscope header:  ./test/bpf.h

copying header:  ./test/bpf.h
cscope header:  ./test/flow_debug_helpers.h

copying header:  ./test/flow_debug_helpers.h
cscope header:  ./test/bpf_common.h

copying header:  ./test/bpf_common.h
cscope header:  ./test/csum_helpers.h

copying header:  ./test/csum_helpers.h
cscope header:  ./test/bpf_helpers.h

copying header:  ./test/bpf_helpers.h
cscope header:  ./test/bpf_endian.h

copying header:  ./test/bpf_endian.h
cscope header:  ./test/balancer_kern_flavors-tpl.h

copying header:  ./test/balancer_kern_flavors-tpl.h
cscope header:  ./test/healthchecking_consts.h

copying header:  ./test/healthchecking_consts.h
cscope header:  ./test/handle_icmp.h

copying header:  ./test/handle_icmp.h
Ignoring {#funcName,count,[FileName,linenumber]

ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
ct 1
Ignoring }

Ignoring {#map_name,filename,line #, isFound

ct 3
ct 3
ct 3
ct 3
ct 3
ct 3
ct 3
ct 3
ct 3
ct 3
ct 3
ct 3
ct 3
ct 3
ct 3
ct 3
Ignoring }

annotatedFile:  annotate_struct_test_balancer_helpers.h.out
annotatedFile:  annotate_struct_test_decap_maps.h.out
annotatedFile:  annotate_func_test_csum_helpers.h.xml
annotatedFile:  annotate_struct_test_xdp_pktcntr.c.out
annotatedFile:  annotate_struct_test_balancer_maps.h.out
annotatedFile:  annotate_func_test_bpf_endian.h.xml
annotatedFile:  annotate_func_test_bpf.h.xml
annotatedFile:  annotate_func_test_xdp_root.c.xml
annotatedFile:  annotate_func_test_pckt_encap.h.xml
annotatedFile:  annotate_func_test_healthchecking_structs.h.xml
annotatedFile:  annotate_struct_test_xdp_root.c.out
annotatedFile:  annotate_struct_test_encap_helpers.h.out
annotatedFile:  annotate_func_test_healthchecking_consts.h.xml
annotatedFile:  annotate_func_test_flow_debug_maps.h.xml
annotatedFile:  annotate_struct_test_pckt_parsing.h.out
annotatedFile:  annotate_func_test_healthchecking_maps.h.xml
annotatedFile:  annotate_func_test_balancer_kern.c.xml
annotatedFile:  annotate_struct_test_healthchecking_consts.h.out
annotatedFile:  annotate_struct_test_balancer_consts.h.out
annotatedFile:  annotate_struct_test_jhash.h.out
annotatedFile:  annotate_struct_test_bpf_endian.h.out
annotatedFile:  annotate_struct_test_bpf_helpers.h.out
annotatedFile:  annotate_func_test_handle_icmp.h.xml
annotatedFile:  annotate_struct_test_healthchecking_kern.c.out
annotatedFile:  annotate_func_test_decap_maps.h.xml
annotatedFile:  annotate_func_test_flow_debug.h.xml
annotatedFile:  annotate_func_test_balancer_maps.h.xml
annotatedFile:  annotate_func_test_encap_helpers.h.xml
annotatedFile:  annotate_func_test_balancer_helpers.h.xml
annotatedFile:  annotate_struct_test_flow_debug_maps.h.out
annotatedFile:  annotate_func_test_healthchecking_ipip.c.xml
annotatedFile:  annotate_func_test_healthchecking_helpers.h.xml
annotatedFile:  annotate_func_test_balancer_consts.h.xml
annotatedFile:  annotate_func_test_flow_debug_helpers.h.xml
annotatedFile:  annotate_struct_test_pckt_encap.h.out
annotatedFile:  annotate_struct_test_handle_icmp.h.out
annotatedFile:  annotate_struct_test_balancer_structs.h.out
annotatedFile:  annotate_struct_test_balancer_kern.c.out
annotatedFile:  annotate_func_test_decap_kern.c.xml
annotatedFile:  annotate_struct_test_csum_helpers.h.out
annotatedFile:  annotate_func_test_jhash.h.xml
annotatedFile:  annotate_struct_test_control_data_maps.h.out
annotatedFile:  annotate_struct_test_healthchecking_maps.h.out
annotatedFile:  annotate_struct_test_x.c.out
annotatedFile:  annotate_struct_test_healthchecking_helpers.h.out
annotatedFile:  annotate_struct_test_healthchecking_ipip.c.out
annotatedFile:  annotate_func_test_bpf_helpers.h.xml
annotatedFile:  annotate_struct_test_bpf_common.h.out
annotatedFile:  LOG
annotatedFile:  annotate_struct_test_flow_debug_helpers.h.out
annotatedFile:  annotate_func_test_xdp_pktcntr.c.xml
annotatedFile:  annotate_func_test_x.c.xml
annotatedFile:  annotate_struct_test_healthchecking_structs.h.out
annotatedFile:  annotate_func_test_balancer_structs.h.xml
annotatedFile:  annotate_func_test_control_data_maps.h.xml
annotatedFile:  annotate_func_test_introspection.h.xml
annotatedFile:  annotate_struct_test_decap_kern.c.out
annotatedFile:  annotate_struct_test_flow_debug.h.out
annotatedFile:  annotate_func_test_healthchecking_kern.c.xml
annotatedFile:  annotate_func_test_pckt_parsing.h.xml
annotatedFile:  annotate_struct_test_introspection.h.out
annotatedFile:  annotate_struct_test_bpf.h.out
annotatedFile:  annotate_func_test_bpf_common.h.xml
structFIle:  ./txl_annotate/annotate_struct_test_balancer_helpers.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_balancer_helpers.h.out
string #ifndef exists in file
line Number: 1 #ifndef __BALANCER_HELPERS

string #ifdef exists in file
line Number: 19 #ifdef KATRAN_INTROSPECTION

string #ifdef exists in file
line Number: 42 #ifdef INLINE_DECAP_GENERIC

string #endif exists in file
line Number: 49 #endif // of INLINE_DECAP_GENERIC

[('#ifdef ', 'INLINE_DECAP_GENERIC', 42, 48)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_balancer_helpers.h.out
#ifndef __BALANCER_HELPERS

#define __BALANCER_HELPERS

#include <linux/in.h>

#include <linux/ip.h>

#include <linux/ipv6.h>

#include <stdbool.h>

#include "balancer_consts.h"

#include "balancer_structs.h"

#include "bpf.h"

#include "bpf_helpers.h"

#include "control_data_maps.h"

#include "csum_helpers.h"

#include "introspection.h"

#define bpf_printk(fmt, ...)                                   \

  ({                                                           \

    char ____fmt[] = fmt;                                      \

    bpf_trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \

  })

#ifdef KATRAN_INTROSPECTION



__attribute__ ((__always_inline__)) static inline void submit_event (struct xdp_md *ctx, void *map, __u32 event_id, void *data, __u32 size, bool metadata_only) {

    struct ctl_value *gk;

    __u32 introspection_gk_pos = 5;

    gk = bpf_map_lookup_elem (&ctl_array, &introspection_gk_pos);

    if (!gk || gk->value == 0) {

        return;

    }

    struct event_metadata md = {};

    __u64 flags = BPF_F_CURRENT_CPU;

    md.event = event_id;

    md.pkt_size = size;

    if (metadata_only) {

        md.data_len = 0;

    }

    else {

        md.data_len = min_helper (size, MAX_EVENT_SIZE);

        flags |= (__u64) md.data_len << 32;

    }

    bpf_perf_event_output (ctx, map, flags, & md, sizeof (struct event_metadata));

}

#endif

#ifdef INLINE_DECAP_GENERIC



__attribute__ ((__always_inline__)) static inline int recirculate (struct xdp_md *ctx) {

    int i = RECIRCULATION_INDEX;

    bpf_tail_call (ctx, & subprograms, i);

    return XDP_PASS;

}

#endif // of INLINE_DECAP_GENERIC



__attribute__ ((__always_inline__)) static inline int decrement_ttl (void *data, void *data_end, int offset, bool is_ipv6) {

    struct iphdr *iph;

    struct ipv6hdr *ip6h;

    if (is_ipv6) {

        if ((data + offset + sizeof (struct ipv6hdr)) > data_end) {

            return XDP_DROP;

        }

        ip6h = (struct ipv6hdr *) (data + offset);

        if (!--ip6h->hop_limit) {

            return XDP_DROP;

        }

    }

    else {

        if ((data + offset + sizeof (struct iphdr)) > data_end) {

            return XDP_DROP;

        }

        iph = (struct iphdr *) (data + offset);

        __u32 csum;

        if (!--iph->ttl) {

            return XDP_DROP;

        }

        csum = iph->check + 0x0001;

        iph->check = (csum & 0xffff) + (csum >> 16);

    }

    return FURTHER_PROCESSING;

}

#endif



structFIle:  ./txl_annotate/annotate_struct_test_decap_maps.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_decap_maps.h.out
string #ifndef exists in file
line Number: 1 #ifndef __DECAP_MAPS_H

string #ifndef exists in file
line Number: 5 #ifndef STATS_MAP_SIZE

string #endif exists in file
line Number: 26 #endif // of _DECAP_MAPS

[('#ifndef ', 'STATS_MAP_SIZE', 5, 25)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_decap_maps.h.out
#ifndef __DECAP_MAPS_H

#define __DECAP_MAPS_H

#include "bpf.h"

#include "bpf_helpers.h"

#ifndef STATS_MAP_SIZE

#define STATS_MAP_SIZE 4

#endif



<struct>

struct decap_stats {

    __u64 decap_v4;

    __u64 decap_v6;

    __u64 total;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_decap_maps.h.out:10:14
StructStr struct decap_stats {
    __u64 decap_v4;
    __u64 decap_v6;
    __u64 total;
};



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);

    __type (key, __u32);

    __type (value, struct decap_stats);

    __uint (max_entries, STATS_MAP_SIZE);

    __uint (map_flags, NO_FLAGS);

} decap_counters SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_decap_maps.h.out:18:24
StructStr struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, struct decap_stats);
    __uint (max_entries, STATS_MAP_SIZE);
    __uint (map_flags, NO_FLAGS);
} decap_counters SEC (".maps");

#endif // of _DECAP_MAPS

structFIle:  ./txl_annotate/annotate_struct_test_xdp_pktcntr.c.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_xdp_pktcntr.c.out
[]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_xdp_pktcntr.c.out
#include <linux/if.h>

#include <linux/if_ether.h>

#include <linux/if_tunnel.h>

#include <linux/in.h>

#include <linux/ip.h>

#include <linux/ipv6.h>

#include <linux/pkt_cls.h>

#include "bpf.h"

#include "bpf_helpers.h"

#define CTRL_ARRAY_SIZE 2

#define CNTRS_ARRAY_SIZE 512



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_ARRAY);

    __type (key, __u32);

    __type (value, __u32);

    __uint (max_entries, CTRL_ARRAY_SIZE);

} ctl_array SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_xdp_pktcntr.c.out:14:19
StructStr struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, CTRL_ARRAY_SIZE);
} ctl_array SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);

    __type (key, __u32);

    __type (value, __u64);

    __uint (max_entries, CNTRS_ARRAY_SIZE);

} cntrs_array SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_xdp_pktcntr.c.out:23:28
StructStr struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, __u64);
    __uint (max_entries, CNTRS_ARRAY_SIZE);
} cntrs_array SEC (".maps");



SEC ("xdp")

int pktcntr (struct xdp_md *ctx) {

    void *data_end = (void *) (long) ctx->data_end;

    void *data = (void *) (long) ctx->data;

    __u32 ctl_flag_pos = 0;

    __u32 cntr_pos = 0;

    __u32 *flag = bpf_map_lookup_elem (&ctl_array, &ctl_flag_pos);

    if (!flag || (*flag == 0)) {

        return XDP_PASS;

    };

    __u64 *cntr_val = bpf_map_lookup_elem (&cntrs_array, &cntr_pos);

    if (cntr_val) {

        *cntr_val += 1;

    };

    return XDP_PASS;

}



char _license [] SEC ("license") = "GPL";

structFIle:  ./txl_annotate/annotate_struct_test_balancer_maps.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_balancer_maps.h.out
string #ifndef exists in file
line Number: 1 #ifndef __BALANCER_MAPS_H

string #ifdef exists in file
line Number: 87 #ifdef LPM_SRC_LOOKUP

string #endif exists in file
line Number: 108 #endif // of LPM_SRC_LOOKUP

string #ifdef exists in file
line Number: 109 #ifdef GLOBAL_LRU_LOOKUP

string #endif exists in file
line Number: 130 #endif // of GLOBAL_LRU_LOOKUP

string #endif exists in file
line Number: 131 #endif // of _BALANCER_MAPS

[('#ifdef ', 'LPM_SRC_LOOKUP', 87, 107), ('#ifdef ', 'GLOBAL_LRU_LOOKUP', 109, 129), ('#ifndef ', '__BALANCER_MAPS_H', 1, 130)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_balancer_maps.h.out
#ifndef __BALANCER_MAPS_H

#define __BALANCER_MAPS_H

#include "bpf.h"

#include "bpf_helpers.h"

#include "balancer_consts.h"

#include "balancer_structs.h"



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_HASH);

    __type (key, struct vip_definition);

    __type (value, struct vip_meta);

    __uint (max_entries, MAX_VIPS);

    __uint (map_flags, NO_FLAGS);

} vip_map SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_maps.h.out:9:15
StructStr struct {
    __uint (type, BPF_MAP_TYPE_HASH);
    __type (key, struct vip_definition);
    __type (value, struct vip_meta);
    __uint (max_entries, MAX_VIPS);
    __uint (map_flags, NO_FLAGS);
} vip_map SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_ARRAY_OF_MAPS);

    __uint (key_size, sizeof (__u32));

    __uint (value_size, sizeof (__u32));

    __uint (max_entries, MAX_SUPPORTED_CPUS);

    __uint (map_flags, NO_FLAGS);

} lru_mapping SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_maps.h.out:19:25
StructStr struct {
    __uint (type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
    __uint (key_size, sizeof (__u32));
    __uint (value_size, sizeof (__u32));
    __uint (max_entries, MAX_SUPPORTED_CPUS);
    __uint (map_flags, NO_FLAGS);
} lru_mapping SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_LRU_HASH);

    __type (key, struct flow_key);

    __type (value, struct real_pos_lru);

    __uint (max_entries, DEFAULT_LRU_SIZE);

    __uint (map_flags, NO_FLAGS);

} fallback_cache SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_maps.h.out:29:35
StructStr struct {
    __uint (type, BPF_MAP_TYPE_LRU_HASH);
    __type (key, struct flow_key);
    __type (value, struct real_pos_lru);
    __uint (max_entries, DEFAULT_LRU_SIZE);
    __uint (map_flags, NO_FLAGS);
} fallback_cache SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_ARRAY);

    __type (key, __u32);

    __type (value, __u32);

    __uint (max_entries, CH_RINGS_SIZE);

    __uint (map_flags, NO_FLAGS);

} ch_rings SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_maps.h.out:39:45
StructStr struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, CH_RINGS_SIZE);
    __uint (map_flags, NO_FLAGS);
} ch_rings SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_ARRAY);

    __type (key, __u32);

    __type (value, struct real_definition);

    __uint (max_entries, MAX_REALS);

    __uint (map_flags, NO_FLAGS);

} reals SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_maps.h.out:49:55
StructStr struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, struct real_definition);
    __uint (max_entries, MAX_REALS);
    __uint (map_flags, NO_FLAGS);
} reals SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);

    __type (key, __u32);

    __type (value, struct lb_stats);

    __uint (max_entries, MAX_REALS);

    __uint (map_flags, NO_FLAGS);

} reals_stats SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_maps.h.out:59:65
StructStr struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, struct lb_stats);
    __uint (max_entries, MAX_REALS);
    __uint (map_flags, NO_FLAGS);
} reals_stats SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);

    __type (key, __u32);

    __type (value, struct lb_stats);

    __uint (max_entries, STATS_MAP_SIZE);

    __uint (map_flags, NO_FLAGS);

} stats SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_maps.h.out:69:75
StructStr struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, struct lb_stats);
    __uint (max_entries, STATS_MAP_SIZE);
    __uint (map_flags, NO_FLAGS);
} stats SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_ARRAY);

    __type (key, __u32);

    __type (value, __u32);

    __uint (max_entries, MAX_QUIC_REALS);

    __uint (map_flags, NO_FLAGS);

} server_id_map SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_maps.h.out:79:85
StructStr struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, MAX_QUIC_REALS);
    __uint (map_flags, NO_FLAGS);
} server_id_map SEC (".maps");

#ifdef LPM_SRC_LOOKUP



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_LPM_TRIE);

    __type (key, struct v4_lpm_key);

    __type (value, __u32);

    __uint (max_entries, MAX_LPM_SRC);

    __uint (map_flags, BPF_F_NO_PREALLOC);

} lpm_src_v4 SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_maps.h.out:90:96
StructStr struct {
    __uint (type, BPF_MAP_TYPE_LPM_TRIE);
    __type (key, struct v4_lpm_key);
    __type (value, __u32);
    __uint (max_entries, MAX_LPM_SRC);
    __uint (map_flags, BPF_F_NO_PREALLOC);
} lpm_src_v4 SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_LPM_TRIE);

    __type (key, struct v6_lpm_key);

    __type (value, __u32);

    __uint (max_entries, MAX_LPM_SRC);

    __uint (map_flags, BPF_F_NO_PREALLOC);

} lpm_src_v6 SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_maps.h.out:100:106
StructStr struct {
    __uint (type, BPF_MAP_TYPE_LPM_TRIE);
    __type (key, struct v6_lpm_key);
    __type (value, __u32);
    __uint (max_entries, MAX_LPM_SRC);
    __uint (map_flags, BPF_F_NO_PREALLOC);
} lpm_src_v6 SEC (".maps");

#endif // of LPM_SRC_LOOKUP

#ifdef GLOBAL_LRU_LOOKUP



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_ARRAY_OF_MAPS);

    __uint (key_size, sizeof (__u32));

    __uint (value_size, sizeof (__u32));

    __uint (max_entries, MAX_SUPPORTED_CPUS);

    __uint (map_flags, NO_FLAGS);

} global_lru_maps SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_maps.h.out:112:118
StructStr struct {
    __uint (type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
    __uint (key_size, sizeof (__u32));
    __uint (value_size, sizeof (__u32));
    __uint (max_entries, MAX_SUPPORTED_CPUS);
    __uint (map_flags, NO_FLAGS);
} global_lru_maps SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_LRU_HASH);

    __type (key, struct flow_key);

    __type (value, __u32);

    __uint (max_entries, DEFAULT_GLOBAL_LRU_SIZE);

    __uint (map_flags, NO_FLAGS);

} fallback_glru SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_maps.h.out:122:128
StructStr struct {
    __uint (type, BPF_MAP_TYPE_LRU_HASH);
    __type (key, struct flow_key);
    __type (value, __u32);
    __uint (max_entries, DEFAULT_GLOBAL_LRU_SIZE);
    __uint (map_flags, NO_FLAGS);
} fallback_glru SEC (".maps");

#endif // of GLOBAL_LRU_LOOKUP

#endif // of _BALANCER_MAPS

structFIle:  ./txl_annotate/annotate_struct_test_xdp_root.c.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_xdp_root.c.out
[]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_xdp_root.c.out
#include "bpf.h"

#include "bpf_helpers.h"

#define ROOT_ARRAY_SIZE 3



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_PROG_ARRAY);

    __type (key, __u32);

    __type (value, __u32);

    __uint (max_entries, ROOT_ARRAY_SIZE);

} root_array SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_xdp_root.c.out:6:11
StructStr struct {
    __uint (type, BPF_MAP_TYPE_PROG_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, ROOT_ARRAY_SIZE);
} root_array SEC (".maps");



int SEC ("xdp")

xdp_root (struct xdp_md *ctx) {

    __u32 *fd;

#pragma clang loop unroll(full)

    for (__u32 i = 0; i < ROOT_ARRAY_SIZE; i++) {

        bpf_tail_call (ctx, & root_array, i);

    }

    return XDP_PASS;

}



int SEC ("xdp")

xdp_val (struct xdp_md *ctx) {

    __u32 *fd;

#pragma clang loop unroll(full)

    for (__u32 i = 0; i < ROOT_ARRAY_SIZE; i++) {

        bpf_tail_call (ctx, & root_array, i);

    }

    return XDP_PASS;

}



char _license [] SEC ("license") = "GPL";

structFIle:  ./txl_annotate/annotate_struct_test_encap_helpers.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_encap_helpers.h.out
string #ifndef exists in file
line Number: 1 #ifndef __ENCAP_HELPERS_H

string #ifdef exists in file
line Number: 20 #ifdef COPY_INNER_PACKET_TOS

string #ifdef exists in file
line Number: 36 #ifdef COPY_INNER_PACKET_TOS

string #endif exists in file
line Number: 55 #endif // of __ENCAP_HELPERS_H

[('#ifdef ', 'COPY_INNER_PACKET_TOS', 36, 54)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_encap_helpers.h.out
#ifndef __ENCAP_HELPERS_H

#define __ENCAP_HELPERS_H

#include <linux/ip.h>

#include <linux/ipv6.h>

#include <linux/udp.h>

#include <string.h>

#include "balancer_consts.h"

#include "bpf.h"

#include "bpf_endian.h"

#include "bpf_helpers.h"

#include "csum_helpers.h"



__attribute__ ((__always_inline__)) static inline void create_v4_hdr (struct iphdr *iph, __u8 tos, __u32 saddr, __u32 daddr, __u16 pkt_bytes, __u8 proto) {

    __u64 csum = 0;

    iph->version = 4;

    iph->ihl = 5;

    iph->frag_off = 0;

    iph->protocol = proto;

    iph->check = 0;

#ifdef COPY_INNER_PACKET_TOS

    iph->tos = tos;

#else

    iph->tos = DEFAULT_TOS;

#endif

    iph->tot_len = bpf_htons (pkt_bytes + sizeof (struct iphdr));

    iph->daddr = daddr;

    iph->saddr = saddr;

    iph->ttl = DEFAULT_TTL;

    ipv4_csum_inline (iph, & csum);

    iph->check = csum;

}



__attribute__ ((__always_inline__)) static inline void create_v6_hdr (struct ipv6hdr *ip6h, __u8 tc, __u32 *saddr, __u32 *daddr, __u16 payload_len, __u8 proto) {

    ip6h->version = 6;

    memset (ip6h -> flow_lbl, 0, sizeof (ip6h -> flow_lbl));

#ifdef COPY_INNER_PACKET_TOS

    ip6h->priority = (tc & 0xF0) >> 4;

    ip6h->flow_lbl[0] = (tc & 0x0F) << 4;

#else

    ip6h->priority = DEFAULT_TOS;

#endif

    ip6h->nexthdr = proto;

    ip6h->payload_len = bpf_htons (payload_len);

    ip6h->hop_limit = DEFAULT_TTL;

    memcpy (ip6h -> saddr.s6_addr32, saddr, 16);

    memcpy (ip6h -> daddr.s6_addr32, daddr, 16);

}



__attribute__ ((__always_inline__)) static inline void create_udp_hdr (struct udphdr *udph, __u16 sport, __u16 dport, __u16 len, __u16 csum) {

    udph->source = sport;

    udph->dest = bpf_htons (dport);

    udph->len = bpf_htons (len);

    udph->check = csum;

}

#endif // of __ENCAP_HELPERS_H



structFIle:  ./txl_annotate/annotate_struct_test_pckt_parsing.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_pckt_parsing.h.out
string #ifndef exists in file
line Number: 1 #ifndef __PCKT_PARSING_H

string #ifdef exists in file
line Number: 99 #ifdef TCP_SERVER_ID_ROUTING

string #ifdef exists in file
line Number: 100 #ifdef TCP_HDR_OPT_SKIP_UNROLL_LOOP

string #if exists in file
line Number: 168 #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0) || \

string #endif exists in file
line Number: 207 #endif // TCP_SERVER_ID_ROUTING

string #endif exists in file
line Number: 250 #endif // of  __PCKT_PARSING_H

[('#if ', 'LINUX_VERSION_CODE', 168, 206), ('#ifdef ', 'TCP_HDR_OPT_SKIP_UNROLL_LOOP', 100, 249)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_pckt_parsing.h.out
#ifndef __PCKT_PARSING_H

#define __PCKT_PARSING_H

#include <linux/icmp.h>

#include <linux/icmpv6.h>

#include <linux/if_ether.h>

#include <linux/ip.h>

#include <linux/ipv6.h>

#include <linux/ptrace.h>

#include <linux/tcp.h>

#include <linux/udp.h>

#include <linux/version.h>

#include <stdbool.h>

#include <stddef.h>

#include "balancer_consts.h"

#include "balancer_helpers.h"

#include "bpf.h"



<struct>

struct quic_long_header {

    __u8 flags;

    __u32 version;

    __u8 conn_id_lens;

    __u8 dst_connection_id [QUIC_MIN_CONNID_LEN];

} __attribute__ ((__packed__));

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_pckt_parsing.h.out:19:24
StructStr struct quic_long_header {
    __u8 flags;
    __u32 version;
    __u8 conn_id_lens;
    __u8 dst_connection_id [QUIC_MIN_CONNID_LEN];
} __attribute__ ((__packed__));



<struct>

struct quic_short_header {

    __u8 flags;

    __u8 connection_id [QUIC_MIN_CONNID_LEN];

} __attribute__ ((__packed__));

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_pckt_parsing.h.out:28:31
StructStr struct quic_short_header {
    __u8 flags;
    __u8 connection_id [QUIC_MIN_CONNID_LEN];
} __attribute__ ((__packed__));



__attribute__ ((__always_inline__)) static inline __u64 calc_offset (bool is_ipv6, bool is_icmp) {

    __u64 off = sizeof (struct ethhdr);

    if (is_ipv6) {

        off += sizeof (struct ipv6hdr);

        if (is_icmp) {

            off += (sizeof (struct icmp6hdr) + sizeof (struct ipv6hdr));

        }

    }

    else {

        off += sizeof (struct iphdr);

        if (is_icmp) {

            off += (sizeof (struct icmphdr) + sizeof (struct iphdr));

        }

    }

    return off;

}



__attribute__ ((__always_inline__)) static inline bool parse_udp (void *data, void *data_end, bool is_ipv6, struct packet_description *pckt) {

    bool is_icmp = !((pckt->flags & F_ICMP) == 0);

    __u64 off = calc_offset (is_ipv6, is_icmp);

    struct udphdr *udp;

    udp = data + off;

    if (udp + 1 > data_end) {

        return false;

    }

    if (!is_icmp) {

        pckt->flow.port16[0] = udp->source;

        pckt->flow.port16[1] = udp->dest;

    }

    else {

        pckt->flow.port16[0] = udp->dest;

        pckt->flow.port16[1] = udp->source;

    }

    return true;

}



__attribute__ ((__always_inline__)) static inline bool parse_tcp (void *data, void *data_end, bool is_ipv6, struct packet_description *pckt) {

    bool is_icmp = !((pckt->flags & F_ICMP) == 0);

    __u64 off = calc_offset (is_ipv6, is_icmp);

    struct tcphdr *tcp;

    tcp = data + off;

    if (tcp + 1 > data_end) {

        return false;

    }

    if (tcp->syn) {

        pckt->flags |= F_SYN_SET;

    }

    if (!is_icmp) {

        pckt->flow.port16[0] = tcp->source;

        pckt->flow.port16[1] = tcp->dest;

    }

    else {

        pckt->flow.port16[0] = tcp->dest;

        pckt->flow.port16[1] = tcp->source;

    }

    return true;

}



<struct>

struct hdr_opt_state {

    __u32 server_id;

    __u8 byte_offset;

    __u8 hdr_bytes_remaining;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_pckt_parsing.h.out:93:97
StructStr struct hdr_opt_state {
    __u32 server_id;
    __u8 byte_offset;
    __u8 hdr_bytes_remaining;
};

#ifdef TCP_SERVER_ID_ROUTING

#ifdef TCP_HDR_OPT_SKIP_UNROLL_LOOP



__attribute__ ((noinline))

#else

__attribute__ ((__always_inline__))

#endif

int parse_hdr_opt (const struct xdp_md *xdp, struct hdr_opt_state *state) {

    const void *data = (void *) (long) xdp->data;

    const void *data_end = (void *) (long) xdp->data_end;

    __u8 *tcp_opt, kind, hdr_len;

    if (!state) {

        return -1;

    }

    tcp_opt = (__u8 *) (data + state->byte_offset);

    if (tcp_opt + 1 > data_end) {

        return -1;

    }

    kind = tcp_opt[0];

    if (kind == TCP_OPT_EOL) {

        return -1;

    }

    if (kind == TCP_OPT_NOP) {

        state->hdr_bytes_remaining--;

        state->byte_offset++;

        return 0;

    }

    if (state->hdr_bytes_remaining < 2 || tcp_opt + sizeof (__u8) + sizeof (__u8) > data_end) {

        return -1;

    }

    hdr_len = tcp_opt[1];

    if (hdr_len > state->hdr_bytes_remaining) {

        return -1;

    }

    if (kind == TCP_HDR_OPT_KIND_TPR) {

        if (hdr_len != TCP_HDR_OPT_LEN_TPR) {

            return -1;

        }

        if (tcp_opt + TCP_HDR_OPT_LEN_TPR > data_end) {

            return -1;

        }

        state->server_id = *(__u32*) &tcp_opt[2];

        return 1;

    }

    state->hdr_bytes_remaining -= hdr_len;

    state->byte_offset += hdr_len;

    return 0;

}



__attribute__ ((__always_inline__)) static inline int tcp_hdr_opt_lookup (const struct xdp_md *xdp, bool is_ipv6, struct real_definition **real, struct packet_description *pckt, bool bypass_lru, void *lru_map) {

    const void *data = (void *) (long) xdp->data;

    const void *data_end = (void *) (long) xdp->data_end;

    struct real_pos_lru *dst_lru;

    struct tcphdr *tcp_hdr;

    __u8 tcp_hdr_opt_len = 0;

    __u64 tcp_offset = 0;

    struct hdr_opt_state opt_state = {};

    int err = 0;

    tcp_offset = calc_offset (is_ipv6, false);

    tcp_hdr = (struct tcphdr *) (data + tcp_offset);

    if (tcp_hdr + 1 > data_end) {

        return FURTHER_PROCESSING;

    }

    tcp_hdr_opt_len = (tcp_hdr->doff * 4) - sizeof (struct tcphdr);

    if (tcp_hdr_opt_len < TCP_HDR_OPT_LEN_TPR) {

        return FURTHER_PROCESSING;

    }

    opt_state.hdr_bytes_remaining = tcp_hdr_opt_len;

    opt_state.byte_offset = sizeof (struct tcphdr) + tcp_offset;

#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0) || \

    !defined TCP_HDR_OPT_SKIP_UNROLL_LOOP

#pragma clang loop unroll(full)

#endif

    for (int i = 0; i < TCP_HDR_OPT_MAX_OPT_CHECKS; i++) {

        err = parse_hdr_opt (xdp, &opt_state);

        if (err || !opt_state.hdr_bytes_remaining) {

            break;

        }

    }

    if (!opt_state.server_id) {

        return FURTHER_PROCESSING;

    }

    __u32 key = opt_state.server_id;

    __u32 *real_pos = bpf_map_lookup_elem (&server_id_map, &key);

    if (!real_pos) {

        return FURTHER_PROCESSING;

    }

    key = *real_pos;

    if (key == 0) {

        return FURTHER_PROCESSING;

    }

    pckt->real_index = key;

    *real = bpf_map_lookup_elem (&reals, &key);

    if (!(*real)) {

        return FURTHER_PROCESSING;

    }

    if (!bypass_lru) {

        struct real_pos_lru *dst_lru = bpf_map_lookup_elem (lru_map, &pckt->flow);

        if (dst_lru) {

            dst_lru->pos = key;

            return 0;

        }

        struct real_pos_lru new_dst_lru = {};

        new_dst_lru.pos = key;

        bpf_map_update_elem (lru_map, & pckt -> flow, & new_dst_lru, BPF_ANY);

    }

    return 0;

}

#endif // TCP_SERVER_ID_ROUTING



__attribute__ ((__always_inline__)) static inline int parse_quic (void *data, void *data_end, bool is_ipv6, struct packet_description *pckt) {

    bool is_icmp = (pckt->flags & F_ICMP);

    __u64 off = calc_offset (is_ipv6, is_icmp);

    if ((data + off + sizeof (struct udphdr) + sizeof (__u8)) > data_end) {

        return FURTHER_PROCESSING;

    }

    __u8 *quic_data = data + off + sizeof (struct udphdr);

    __u8 *pkt_type = quic_data;

    __u8 *connId = NULL;

    if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {

        if (quic_data + sizeof (struct quic_long_header) > data_end) {

            return FURTHER_PROCESSING;

        }

        if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {

            return FURTHER_PROCESSING;

        }

        struct quic_long_header *long_header = (struct quic_long_header *) quic_data;

        if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {

            return FURTHER_PROCESSING;

        }

        connId = long_header->dst_connection_id;

    }

    else {

        if (quic_data + sizeof (struct quic_short_header) > data_end) {

            return FURTHER_PROCESSING;

        }

        connId = ((struct quic_short_header *) quic_data)->connection_id;

    }

    if (!connId) {

        return FURTHER_PROCESSING;

    }

    __u8 connIdVersion = (connId[0] >> 6);

    if (connIdVersion == QUIC_CONNID_VERSION_V1) {

        return ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);

    }

    else if (connIdVersion == QUIC_CONNID_VERSION_V2) {

        __u32 cid = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);

        return cid;

    }

    return FURTHER_PROCESSING;

}

#endif // of  __PCKT_PARSING_H



structFIle:  ./txl_annotate/annotate_struct_test_healthchecking_consts.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_healthchecking_consts.h.out
string #ifndef exists in file
line Number: 1 #ifndef __HEALTHCHECKING_CONSTS_H

string #ifndef exists in file
line Number: 7 #ifndef HC_MAX_PACKET_SIZE

string #endif exists in file
line Number: 17 #endif // of __HEALTHCHECKING_CONSTS_H

[('#ifndef ', 'HC_MAX_PACKET_SIZE', 7, 16)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_healthchecking_consts.h.out
#ifndef __HEALTHCHECKING_CONSTS_H

#define __HEALTHCHECKING_CONSTS_H

#define CTRL_MAP_SIZE 4

#define HC_MAIN_INTF_POSITION 3

#define REDIRECT_EGRESS 0

#define DEFAULT_TTL 64

#ifndef HC_MAX_PACKET_SIZE

#define HC_MAX_PACKET_SIZE 1474

#endif

#define GENERIC_STATS_INDEX 0

#define HC_FURTHER_PROCESSING -2

#define STATS_SIZE 1

#define NO_FLAGS 0

#define V6DADDR (1 << 0)

#define HC_SRC_MAC_POS 0

#define HC_DST_MAC_POS 1

#endif // of __HEALTHCHECKING_CONSTS_H

structFIle:  ./txl_annotate/annotate_struct_test_balancer_consts.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_balancer_consts.h.out
string #ifndef exists in file
line Number: 1 #ifndef __BALANCER_CONSTS_H

string #ifndef exists in file
line Number: 11 #ifndef RING_SIZE

string #ifndef exists in file
line Number: 14 #ifndef MAX_VIPS

string #ifndef exists in file
line Number: 17 #ifndef MAX_REALS

string #ifndef exists in file
line Number: 20 #ifndef MAX_LPM_SRC

string #ifndef exists in file
line Number: 23 #ifndef MAX_DECAP_DST

string #ifndef exists in file
line Number: 26 #ifndef MAX_QUIC_REALS

string #ifndef exists in file
line Number: 34 #ifndef MAX_SUPPORTED_CPUS

string #ifndef exists in file
line Number: 40 #ifndef LRU_UDP_TIMEOUT

string #ifndef exists in file
line Number: 54 #ifndef DEFAULT_TTL

string #ifndef exists in file
line Number: 64 #ifndef QUIC_MIN_CONNID_LEN

string #ifndef exists in file
line Number: 67 #ifndef QUIC_CONNID_VERSION_V1

string #ifndef exists in file
line Number: 70 #ifndef QUIC_CONNID_VERSION_V2

string #ifdef exists in file
line Number: 74 #ifdef TCP_SERVER_ID_ROUTING

string #ifndef exists in file
line Number: 81 #ifndef MAX_PCKT_SIZE

string #ifndef exists in file
line Number: 102 #ifndef MAX_CONN_RATE

string #ifndef exists in file
line Number: 105 #ifndef IPIP_V4_PREFIX

string #ifndef exists in file
line Number: 108 #ifndef IPIP_V6_PREFIX1

string #ifndef exists in file
line Number: 111 #ifndef IPIP_V6_PREFIX2

string #ifndef exists in file
line Number: 114 #ifndef IPIP_V6_PREFIX3

string #ifndef exists in file
line Number: 117 #ifndef DEFAULT_TOS

string #ifndef exists in file
line Number: 120 #ifndef COPY_INNER_PACKET_TOS

string #ifndef exists in file
line Number: 123 #ifndef GUE_DPORT

string #ifndef exists in file
line Number: 126 #ifndef GUE_CSUM

string #ifndef exists in file
line Number: 129 #ifndef INIT_JHASH_SEED

string #ifndef exists in file
line Number: 132 #ifndef INIT_JHASH_SEED_V6

string #ifdef exists in file
line Number: 135 #ifdef LPM_SRC_LOOKUP

string #ifndef exists in file
line Number: 136 #ifndef INLINE_DECAP

string #ifndef exists in file
line Number: 137 #ifndef INLINE_DECAP_GUE

string #endif exists in file
line Number: 139 #endif // of INLINE_DECAP_GUE

string #endif exists in file
line Number: 140 #endif // of INLINE_DECAP

string #endif exists in file
line Number: 141 #endif // of LPM_SRC_LOOKUP

string #ifdef exists in file
line Number: 142 #ifdef INLINE_DECAP

string #ifndef exists in file
line Number: 143 #ifndef INLINE_DECAP_IPIP

string #endif exists in file
line Number: 145 #endif // of INLINE_DECAP_IPIP

string #ifdef exists in file
line Number: 147 #ifdef INLINE_DECAP_IPIP

string #ifndef exists in file
line Number: 148 #ifndef INLINE_DECAP_GENERIC

string #endif exists in file
line Number: 150 #endif // of INLINE_DECAP_GENERIC

string #endif exists in file
line Number: 151 #endif // of INLINE_DECAP_IPIP

string #ifdef exists in file
line Number: 152 #ifdef INLINE_DECAP_GUE

string #ifndef exists in file
line Number: 153 #ifndef INLINE_DECAP_GENERIC

string #endif exists in file
line Number: 155 #endif // of INLINE_DECAP_GENERIC

string #endif exists in file
line Number: 156 #endif // of INLINE_DECAP_GUE

string #ifdef exists in file
line Number: 157 #ifdef GUE_ENCAP

string #endif exists in file
line Number: 168 #endif // of __BALANCER_CONSTS_H

[('#ifndef ', 'INLINE_DECAP_GUE', 137, 138), ('#ifndef ', 'INLINE_DECAP', 136, 139), ('#ifdef ', 'LPM_SRC_LOOKUP', 135, 140), ('#ifndef ', 'INLINE_DECAP_IPIP', 143, 144), ('#ifndef ', 'INLINE_DECAP_GENERIC', 148, 149), ('#ifdef ', 'INLINE_DECAP_IPIP', 147, 150), ('#ifndef ', 'INLINE_DECAP_GENERIC', 153, 154), ('#ifdef ', 'INLINE_DECAP_GUE', 152, 155), ('#ifdef ', 'GUE_ENCAP', 157, 167)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_balancer_consts.h.out
#ifndef __BALANCER_CONSTS_H

#define __BALANCER_CONSTS_H

#define BE_ETH_P_IP 8

#define BE_ETH_P_IPV6 56710

#define GUEV1_IPV6MASK 0x30

#define FURTHER_PROCESSING -1

#define PCKT_FRAGMENTED 65343

#define IPV4_HDR_LEN_NO_OPT 20

#define IPV4_PLUS_ICMP_HDR 28

#define IPV6_PLUS_ICMP_HDR 48

#ifndef RING_SIZE

#define RING_SIZE 65537

#endif

#ifndef MAX_VIPS

#define MAX_VIPS 512

#endif

#ifndef MAX_REALS

#define MAX_REALS 4096

#endif

#ifndef MAX_LPM_SRC

#define MAX_LPM_SRC 3000000

#endif

#ifndef MAX_DECAP_DST

#define MAX_DECAP_DST 6

#endif

#ifndef MAX_QUIC_REALS

#define MAX_QUIC_REALS 0x00fffffe // 2^24-2

#endif

#define CTL_MAP_SIZE 16

#define SUBPROGRAMS_ARRAY_SIZE 1

#define RECIRCULATION_INDEX 0

#define CH_RINGS_SIZE (MAX_VIPS * RING_SIZE)

#define STATS_MAP_SIZE (MAX_VIPS * 2)

#ifndef MAX_SUPPORTED_CPUS

#define MAX_SUPPORTED_CPUS 128

#endif

#define DEFAULT_LRU_SIZE 1000

#define DEFAULT_GLOBAL_LRU_SIZE 10000

#define ONE_SEC 1000000000U // 1 sec in nanosec

#ifndef LRU_UDP_TIMEOUT

#define LRU_UDP_TIMEOUT 30000000000U // 30 sec in nanosec

#endif

#define F_IPV6 (1 << 0)

#define F_LOCAL_REAL (1 << 1)

#define F_HASH_NO_SRC_PORT (1 << 0)

#define F_LRU_BYPASS (1 << 1)

#define F_QUIC_VIP (1 << 2)

#define F_HASH_DPORT_ONLY (1 << 3)

#define F_SRC_ROUTING (1 << 4)

#define F_LOCAL_VIP (1 << 5)

#define F_GLOBAL_LRU (1 << 6)

#define F_ICMP (1 << 0)

#define F_SYN_SET (1 << 1)

#ifndef DEFAULT_TTL

#define DEFAULT_TTL 64

#endif

#define QUIC_LONG_HEADER 0x80

#define QUIC_SHORT_HEADER 0x00

#define QUIC_CLIENT_INITIAL 0x00

#define QUIC_0RTT 0x10

#define QUIC_HANDSHAKE 0x20

#define QUIC_RETRY 0x30

#define QUIC_PACKET_TYPE_MASK 0x30

#ifndef QUIC_MIN_CONNID_LEN

#define QUIC_MIN_CONNID_LEN 8

#endif

#ifndef QUIC_CONNID_VERSION_V1

#define QUIC_CONNID_VERSION_V1 0x1

#endif

#ifndef QUIC_CONNID_VERSION_V2

#define QUIC_CONNID_VERSION_V2 0x2

#endif

#define QUIC_CONNID_VERSION_V1_MAX_VAL 0xFFFF

#ifdef TCP_SERVER_ID_ROUTING

#define TCP_HDR_OPT_KIND_TPR 0xB7

#define TCP_HDR_OPT_LEN_TPR 6

#define TCP_HDR_OPT_MAX_OPT_CHECKS 15

#define TCP_OPT_EOL 0

#define TCP_OPT_NOP 1

#endif

#ifndef MAX_PCKT_SIZE

#define MAX_PCKT_SIZE 1514

#endif

#define ICMP_TOOBIG_SIZE 98

#define ICMP6_TOOBIG_SIZE 262

#define ICMP6_TOOBIG_PAYLOAD_SIZE (ICMP6_TOOBIG_SIZE - 6)

#define ICMP_TOOBIG_PAYLOAD_SIZE (ICMP_TOOBIG_SIZE - 6)

#define NO_FLAGS 0

#define LRU_CNTRS 0

#define LRU_MISS_CNTR 1

#define NEW_CONN_RATE_CNTR 2

#define FALLBACK_LRU_CNTR 3

#define ICMP_TOOBIG_CNTRS 4

#define LPM_SRC_CNTRS 5

#define REMOTE_ENCAP_CNTRS 6

#define QUIC_ROUTE_STATS 7

#define QUIC_CID_VERSION_STATS 8

#define QUIC_CID_DROP_STATS 9

#define TCP_SERVER_ID_ROUTE_STATS 10

#define GLOBAL_LRU_CNTR 11

#define GLOBAL_LRU_MISMATCH_CNTR 12

#ifndef MAX_CONN_RATE

#define MAX_CONN_RATE 125000

#endif

#ifndef IPIP_V4_PREFIX

#define IPIP_V4_PREFIX 4268

#endif

#ifndef IPIP_V6_PREFIX1

#define IPIP_V6_PREFIX1 1

#endif

#ifndef IPIP_V6_PREFIX2

#define IPIP_V6_PREFIX2 0

#endif

#ifndef IPIP_V6_PREFIX3

#define IPIP_V6_PREFIX3 0

#endif

#ifndef DEFAULT_TOS

#define DEFAULT_TOS 0

#endif

#ifndef COPY_INNER_PACKET_TOS

#define COPY_INNER_PACKET_TOS 1

#endif

#ifndef GUE_DPORT

#define GUE_DPORT 6080

#endif

#ifndef GUE_CSUM

#define GUE_CSUM 0

#endif

#ifndef INIT_JHASH_SEED

#define INIT_JHASH_SEED CH_RINGS_SIZE

#endif

#ifndef INIT_JHASH_SEED_V6

#define INIT_JHASH_SEED_V6 MAX_VIPS

#endif

#ifdef LPM_SRC_LOOKUP

#ifndef INLINE_DECAP

#ifndef INLINE_DECAP_GUE

#define INLINE_DECAP

#endif // of INLINE_DECAP_GUE

#endif // of INLINE_DECAP

#endif // of LPM_SRC_LOOKUP

#ifdef INLINE_DECAP

#ifndef INLINE_DECAP_IPIP

#define INLINE_DECAP_IPIP

#endif // of INLINE_DECAP_IPIP

#endif

#ifdef INLINE_DECAP_IPIP

#ifndef INLINE_DECAP_GENERIC

#define INLINE_DECAP_GENERIC

#endif // of INLINE_DECAP_GENERIC

#endif // of INLINE_DECAP_IPIP

#ifdef INLINE_DECAP_GUE

#ifndef INLINE_DECAP_GENERIC

#define INLINE_DECAP_GENERIC

#endif // of INLINE_DECAP_GENERIC

#endif // of INLINE_DECAP_GUE

#ifdef GUE_ENCAP

#define PCKT_ENCAP_V4 gue_encap_v4

#define PCKT_ENCAP_V6 gue_encap_v6

#define HC_ENCAP hc_encap_gue

#else

#define PCKT_ENCAP_V4 encap_v4

#define PCKT_ENCAP_V6 encap_v6

#define HC_ENCAP hc_encap_ipip

#endif

#define V4_SRC_INDEX 0

#define V6_SRC_INDEX 1

#endif // of __BALANCER_CONSTS_H

structFIle:  ./txl_annotate/annotate_struct_test_jhash.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_jhash.h.out
string #ifndef exists in file
line Number: 1 #ifndef _JHASH_KERNEL_

[]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_jhash.h.out
#ifndef _JHASH_KERNEL_

#define _JHASH_KERNEL_



static inline __u32 rol32 (__u32 word, unsigned int shift) {

    return (word << shift) | (word >> ((-shift) & 31));

}

#define __jhash_mix(a, b, c) \

  {                          \

    a -= c;                  \

    a ^= rol32(c, 4);        \

    c += b;                  \

    b -= a;                  \

    b ^= rol32(a, 6);        \

    a += c;                  \

    c -= b;                  \

    c ^= rol32(b, 8);        \

    b += a;                  \

    a -= c;                  \

    a ^= rol32(c, 16);       \

    c += b;                  \

    b -= a;                  \

    b ^= rol32(a, 19);       \

    a += c;                  \

    c -= b;                  \

    c ^= rol32(b, 4);        \

    b += a;                  \

  }

#define __jhash_final(a, b, c) \

  {                            \

    c ^= b;                    \

    c -= rol32(b, 14);         \

    a ^= c;                    \

    a -= rol32(c, 11);         \

    b ^= a;                    \

    b -= rol32(a, 25);         \

    c ^= b;                    \

    c -= rol32(b, 16);         \

    a ^= c;                    \

    a -= rol32(c, 4);          \

    b ^= a;                    \

    b -= rol32(a, 14);         \

    c ^= b;                    \

    c -= rol32(b, 24);         \

  }

#define JHASH_INITVAL 0xdeadbeef



typedef unsigned int u32;



static inline u32 jhash (const void *key, u32 length, u32 initval) {

    u32 a, b, c;

    const unsigned char *k = key;

    a = b = c = JHASH_INITVAL + length + initval;

    while (length > 12) {

        a += *(u32*) (k);

        b += *(u32*) (k + 4);

        c += *(u32*) (k + 8);

        __jhash_mix (a, b, c);

        length -= 12;

        k += 12;

    }

    switch (length) {

    case 12 :

        c += (u32) k[11] << 24;

    case 11 :

        c += (u32) k[10] << 16;

    case 10 :

        c += (u32) k[9] << 8;

    case 9 :

        c += k[8];

    case 8 :

        b += (u32) k[7] << 24;

    case 7 :

        b += (u32) k[6] << 16;

    case 6 :

        b += (u32) k[5] << 8;

    case 5 :

        b += k[4];

    case 4 :

        a += (u32) k[3] << 24;

    case 3 :

        a += (u32) k[2] << 16;

    case 2 :

        a += (u32) k[1] << 8;

    case 1 :

        a += k[0];

        __jhash_final (a, b, c);

    case 0 :

        break;

    }

    return c;

}



static inline u32 __jhash_nwords (u32 a, u32 b, u32 c, u32 initval) {

    a += initval;

    b += initval;

    c += initval;

    __jhash_final (a, b, c);

    return c;

}



static inline u32 jhash_2words (u32 a, u32 b, u32 initval) {

    return __jhash_nwords (a, b, 0, initval +JHASH_INITVAL + (2 << 2));

}



static inline u32 jhash_1word (u32 a, u32 initval) {

    return __jhash_nwords (a, 0, 0, initval +JHASH_INITVAL + (1 << 2));

}

#endif



structFIle:  ./txl_annotate/annotate_struct_test_bpf_endian.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_bpf_endian.h.out
string #ifndef exists in file
line Number: 1 #ifndef __BPF_ENDIAN__

string #if exists in file
line Number: 4 #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__

string #elif exists in file
line Number: 13 #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__

string #endif exists in file
line Number: 33 #endif /* __BPF_ENDIAN__ */

[('#if ', '__BYTE_ORDER__', 4, 12), ('#ifdef ', '__BYTE_ORDER__', 13, 32)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_bpf_endian.h.out
#ifndef __BPF_ENDIAN__

#define __BPF_ENDIAN__

#include <linux/swab.h>

#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__

#define __bpf_ntohs(x) __builtin_bswap16(x)

#define __bpf_htons(x) __builtin_bswap16(x)

#define __bpf_constant_ntohs(x) ___constant_swab16(x)

#define __bpf_constant_htons(x) ___constant_swab16(x)

#define __bpf_ntohl(x) __builtin_bswap32(x)

#define __bpf_htonl(x) __builtin_bswap32(x)

#define __bpf_constant_ntohl(x) ___constant_swab32(x)

#define __bpf_constant_htonl(x) ___constant_swab32(x)

#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__

#define __bpf_ntohs(x) (x)

#define __bpf_htons(x) (x)

#define __bpf_constant_ntohs(x) (x)

#define __bpf_constant_htons(x) (x)

#define __bpf_ntohl(x) (x)

#define __bpf_htonl(x) (x)

#define __bpf_constant_ntohl(x) (x)

#define __bpf_constant_htonl(x) (x)

#else

#error "Fix your compiler's __BYTE_ORDER__?!"

#endif

#define bpf_htons(x) \

  (__builtin_constant_p(x) ? __bpf_constant_htons(x) : __bpf_htons(x))

#define bpf_ntohs(x) \

  (__builtin_constant_p(x) ? __bpf_constant_ntohs(x) : __bpf_ntohs(x))

#define bpf_htonl(x) \

  (__builtin_constant_p(x) ? __bpf_constant_htonl(x) : __bpf_htonl(x))

#define bpf_ntohl(x) \

  (__builtin_constant_p(x) ? __bpf_constant_ntohl(x) : __bpf_ntohl(x))

#endif /* __BPF_ENDIAN__ */

structFIle:  ./txl_annotate/annotate_struct_test_bpf_helpers.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_bpf_helpers.h.out
string #ifndef exists in file
line Number: 1 #ifndef __BPF_HELPERS_H

string #if exists in file
line Number: 149 #if defined(__TARGET_ARCH_x86)

string #elif exists in file
line Number: 152 #elif defined(__TARGET_ARCH_s390)

string #elif exists in file
line Number: 155 #elif defined(__TARGET_ARCH_arm)

string #elif exists in file
line Number: 158 #elif defined(__TARGET_ARCH_arm64)

string #elif exists in file
line Number: 161 #elif defined(__TARGET_ARCH_mips)

string #elif exists in file
line Number: 164 #elif defined(__TARGET_ARCH_powerpc)

string #elif exists in file
line Number: 167 #elif defined(__TARGET_ARCH_sparc)

string #ifndef exists in file
line Number: 173 #ifndef bpf_target_defined

string #if exists in file
line Number: 174 #if defined(__x86_64__)

string #elif exists in file
line Number: 176 #elif defined(__s390__)

string #elif exists in file
line Number: 178 #elif defined(__arm__)

string #elif exists in file
line Number: 180 #elif defined(__aarch64__)

string #elif exists in file
line Number: 182 #elif defined(__mips__)

string #elif exists in file
line Number: 184 #elif defined(__powerpc__)

string #elif exists in file
line Number: 186 #elif defined(__sparc__)

string #if exists in file
line Number: 190 #if defined(bpf_target_x86)

string #ifdef exists in file
line Number: 191 #ifdef __KERNEL__

string #ifdef exists in file
line Number: 203 #ifdef __i386__

string #elif exists in file
line Number: 227 #elif defined(bpf_target_s390)

string #elif exists in file
line Number: 243 #elif defined(bpf_target_arm)

string #elif exists in file
line Number: 255 #elif defined(bpf_target_arm64)

string #elif exists in file
line Number: 271 #elif defined(bpf_target_mips)

string #elif exists in file
line Number: 283 #elif defined(bpf_target_powerpc)

string #elif exists in file
line Number: 292 #elif defined(bpf_target_sparc)

string #if exists in file
line Number: 301 #if defined(__arch64__)

string #if exists in file
line Number: 307 #if defined(bpf_target_powerpc)

string #elif exists in file
line Number: 310 #elif defined(bpf_target_sparc)

[('#if ', 'defined(__TARGET_ARCH_x86)', 149, 151), ('#ifdef ', 'defined(__TARGET_ARCH_s390)', 152, 154), ('#ifdef ', 'defined(__TARGET_ARCH_arm)', 155, 157), ('#ifdef ', 'defined(__TARGET_ARCH_arm64)', 158, 160), ('#ifdef ', 'defined(__TARGET_ARCH_mips)', 161, 163), ('#ifdef ', 'defined(__TARGET_ARCH_powerpc)', 164, 166), ('#if ', 'defined(__x86_64__)', 174, 175), ('#ifdef ', 'defined(__s390__)', 176, 177), ('#ifdef ', 'defined(__arm__)', 178, 179), ('#ifdef ', 'defined(__aarch64__)', 180, 181), ('#ifdef ', 'defined(__mips__)', 182, 183), ('#ifdef ', 'defined(__powerpc__)', 184, 185), ('#ifdef ', '__i386__', 203, 226), ('#ifdef ', 'defined(bpf_target_s390)', 227, 242), ('#ifdef ', 'defined(bpf_target_arm)', 243, 254), ('#ifdef ', 'defined(bpf_target_arm64)', 255, 270), ('#ifdef ', 'defined(bpf_target_mips)', 271, 282), ('#ifdef ', 'defined(bpf_target_powerpc)', 283, 291), ('#if ', 'defined(bpf_target_powerpc)', 307, 309)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_bpf_helpers.h.out
#ifndef __BPF_HELPERS_H

#define __BPF_HELPERS_H

#define SEC(NAME) __attribute__((section(NAME), used))

#define __uint(name, val) int(*name)[val]

#define __type(name, val) val* name

#define bpf_printk(fmt, ...)                                   \

  ({                                                           \

    char ____fmt[] = fmt;                                      \

    bpf_trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \

  })

static void * (*bpf_map_lookup_elem) (void *map, void *key) = (void *) BPF_FUNC_map_lookup_elem;

static int (*bpf_map_update_elem) (void *map, void *key, void *value, unsigned long long flags) = (void *) BPF_FUNC_map_update_elem;

static int (*bpf_map_delete_elem) (void *map, void *key) = (void *) BPF_FUNC_map_delete_elem;

static int (*bpf_map_push_elem) (void *map, void *value, unsigned long long flags) = (void *) BPF_FUNC_map_push_elem;

static int (*bpf_map_pop_elem) (void *map, void *value) = (void *) BPF_FUNC_map_pop_elem;

static int (*bpf_map_peek_elem) (void *map, void *value) = (void *) BPF_FUNC_map_peek_elem;

static int (*bpf_probe_read) (void *dst, int size, const void *unsafe_ptr) = (void *) BPF_FUNC_probe_read;

static unsigned long long (*bpf_ktime_get_ns) (void) = (void *) BPF_FUNC_ktime_get_ns;

static int (*bpf_trace_printk) (const char *fmt, int fmt_size, ... ) = (void *) BPF_FUNC_trace_printk;

static void (*bpf_tail_call) (void *ctx, void *map, int index) = (void *) BPF_FUNC_tail_call;

static unsigned long long (*bpf_get_smp_processor_id) (void) = (void *) BPF_FUNC_get_smp_processor_id;

static unsigned long long (*bpf_get_current_pid_tgid) (void) = (void *) BPF_FUNC_get_current_pid_tgid;

static unsigned long long (*bpf_get_current_uid_gid) (void) = (void *) BPF_FUNC_get_current_uid_gid;

static int (*bpf_get_current_comm) (void *buf, int buf_size) = (void *) BPF_FUNC_get_current_comm;

static unsigned long long (*bpf_perf_event_read) (void *map, unsigned long long flags) = (void *) BPF_FUNC_perf_event_read;

static int (*bpf_clone_redirect) (void *ctx, int ifindex, int flags) = (void *) BPF_FUNC_clone_redirect;

static int (*bpf_redirect) (int ifindex, int flags) = (void *) BPF_FUNC_redirect;

static int (*bpf_redirect_map) (void *map, int key, int flags) = (void *) BPF_FUNC_redirect_map;

static int (*bpf_perf_event_output) (void *ctx, void *map, unsigned long long flags, void *data, int size) = (void *) BPF_FUNC_perf_event_output;

static int (*bpf_get_stackid) (void *ctx, void *map, int flags) = (void *) BPF_FUNC_get_stackid;

static int (*bpf_probe_write_user) (void *dst, const void *src, int size) = (void *) BPF_FUNC_probe_write_user;

static int (*bpf_current_task_under_cgroup) (void *map, int index) = (void *) BPF_FUNC_current_task_under_cgroup;

static int (*bpf_skb_get_tunnel_key) (void *ctx, void *key, int size, int flags) = (void *) BPF_FUNC_skb_get_tunnel_key;

static int (*bpf_skb_set_tunnel_key) (void *ctx, void *key, int size, int flags) = (void *) BPF_FUNC_skb_set_tunnel_key;

static int (*bpf_skb_get_tunnel_opt) (void *ctx, void *md, int size) = (void *) BPF_FUNC_skb_get_tunnel_opt;

static int (*bpf_skb_set_tunnel_opt) (void *ctx, void *md, int size) = (void *) BPF_FUNC_skb_set_tunnel_opt;

static unsigned long long (*bpf_get_prandom_u32) (void) = (void *) BPF_FUNC_get_prandom_u32;

static int (*bpf_xdp_adjust_head) (void *ctx, int offset) = (void *) BPF_FUNC_xdp_adjust_head;

static int (*bpf_xdp_adjust_meta) (void *ctx, int offset) = (void *) BPF_FUNC_xdp_adjust_meta;

static int (*bpf_get_socket_cookie) (void *ctx) = (void *) BPF_FUNC_get_socket_cookie;

static int (*bpf_setsockopt) (void *ctx, int level, int optname, void *optval, int optlen) = (void *) BPF_FUNC_setsockopt;

static int (*bpf_getsockopt) (void *ctx, int level, int optname, void *optval, int optlen) = (void *) BPF_FUNC_getsockopt;

static int (*bpf_sock_ops_cb_flags_set) (void *ctx, int flags) = (void *) BPF_FUNC_sock_ops_cb_flags_set;

static int (*bpf_sk_redirect_map) (void *ctx, void *map, int key, int flags) = (void *) BPF_FUNC_sk_redirect_map;

static int (*bpf_sk_redirect_hash) (void *ctx, void *map, void *key, int flags) = (void *) BPF_FUNC_sk_redirect_hash;

static int (*bpf_sock_map_update) (void *map, void *key, void *value, unsigned long long flags) = (void *) BPF_FUNC_sock_map_update;

static int (*bpf_sock_hash_update) (void *map, void *key, void *value, unsigned long long flags) = (void *) BPF_FUNC_sock_hash_update;

static int (*bpf_perf_event_read_value) (void *map, unsigned long long flags, void *buf, unsigned int buf_size) = (void *) BPF_FUNC_perf_event_read_value;

static int (*bpf_perf_prog_read_value) (void *ctx, void *buf, unsigned int buf_size) = (void *) BPF_FUNC_perf_prog_read_value;

static int (*bpf_override_return) (void *ctx, unsigned long rc) = (void *) BPF_FUNC_override_return;

static int (*bpf_msg_redirect_map) (void *ctx, void *map, int key, int flags) = (void *) BPF_FUNC_msg_redirect_map;

static int (*bpf_msg_redirect_hash) (void *ctx, void *map, void *key, int flags) = (void *) BPF_FUNC_msg_redirect_hash;

static int (*bpf_msg_apply_bytes) (void *ctx, int len) = (void *) BPF_FUNC_msg_apply_bytes;

static int (*bpf_msg_cork_bytes) (void *ctx, int len) = (void *) BPF_FUNC_msg_cork_bytes;

static int (*bpf_msg_pull_data) (void *ctx, int start, int end, int flags) = (void *) BPF_FUNC_msg_pull_data;

static int (*bpf_msg_push_data) (void *ctx, int start, int end, int flags) = (void *) BPF_FUNC_msg_push_data;

static int (*bpf_msg_pop_data) (void *ctx, int start, int cut, int flags) = (void *) BPF_FUNC_msg_pop_data;

static int (*bpf_bind) (void *ctx, void *addr, int addr_len) = (void *) BPF_FUNC_bind;

static int (*bpf_xdp_adjust_tail) (void *ctx, int offset) = (void *) BPF_FUNC_xdp_adjust_tail;

static int (*bpf_skb_get_xfrm_state) (void *ctx, int index, void *state, int size, int flags) = (void *) BPF_FUNC_skb_get_xfrm_state;

static int (*bpf_sk_select_reuseport) (void *ctx, void *map, void *key, __u32 flags) = (void *) BPF_FUNC_sk_select_reuseport;

static int (*bpf_get_stack) (void *ctx, void *buf, int size, int flags) = (void *) BPF_FUNC_get_stack;

static int (*bpf_fib_lookup) (void *ctx, struct bpf_fib_lookup *params, int plen, __u32 flags) = (void *) BPF_FUNC_fib_lookup;

static int (*bpf_lwt_push_encap) (void *ctx, unsigned int type, void *hdr, unsigned int len) = (void *) BPF_FUNC_lwt_push_encap;

static int (*bpf_lwt_seg6_store_bytes) (void *ctx, unsigned int offset, void *from, unsigned int len) = (void *) BPF_FUNC_lwt_seg6_store_bytes;

static int (*bpf_lwt_seg6_action) (void *ctx, unsigned int action, void *param, unsigned int param_len) = (void *) BPF_FUNC_lwt_seg6_action;

static int (*bpf_lwt_seg6_adjust_srh) (void *ctx, unsigned int offset, unsigned int len) = (void *) BPF_FUNC_lwt_seg6_adjust_srh;

static int (*bpf_rc_repeat) (void *ctx) = (void *) BPF_FUNC_rc_repeat;

static int (*bpf_rc_keydown) (void *ctx, unsigned int protocol, unsigned long long scancode, unsigned int toggle) = (void *) BPF_FUNC_rc_keydown;

static unsigned long long (*bpf_get_current_cgroup_id) (void) = (void *) BPF_FUNC_get_current_cgroup_id;

static void * (*bpf_get_local_storage) (void *map, unsigned long long flags) = (void *) BPF_FUNC_get_local_storage;

static unsigned long long (*bpf_skb_cgroup_id) (void *ctx) = (void *) BPF_FUNC_skb_cgroup_id;

static unsigned long long (*bpf_skb_ancestor_cgroup_id) (void *ctx, int level) = (void *) BPF_FUNC_skb_ancestor_cgroup_id;

static struct bpf_sock * (*bpf_sk_lookup_tcp) (void *ctx, struct bpf_sock_tuple *tuple, int size, unsigned long long netns_id, unsigned long long flags) = (void *) BPF_FUNC_sk_lookup_tcp;

static struct bpf_sock * (*bpf_skc_lookup_tcp) (void *ctx, struct bpf_sock_tuple *tuple, int size, unsigned long long netns_id, unsigned long long flags) = (void *) BPF_FUNC_skc_lookup_tcp;

static struct bpf_sock * (*bpf_sk_lookup_udp) (void *ctx, struct bpf_sock_tuple *tuple, int size, unsigned long long netns_id, unsigned long long flags) = (void *) BPF_FUNC_sk_lookup_udp;

static int (*bpf_sk_release) (struct bpf_sock *sk) = (void *) BPF_FUNC_sk_release;

static int (*bpf_skb_vlan_push) (void *ctx, __be16 vlan_proto, __u16 vlan_tci) = (void *) BPF_FUNC_skb_vlan_push;

static int (*bpf_skb_vlan_pop) (void *ctx) = (void *) BPF_FUNC_skb_vlan_pop;

static int (*bpf_rc_pointer_rel) (void *ctx, int rel_x, int rel_y) = (void *) BPF_FUNC_rc_pointer_rel;

static void (*bpf_spin_lock) (struct bpf_spin_lock *lock) = (void *) BPF_FUNC_spin_lock;

static void (*bpf_spin_unlock) (struct bpf_spin_lock *lock) = (void *) BPF_FUNC_spin_unlock;

static struct bpf_sock * (*bpf_sk_fullsock) (struct bpf_sock *sk) = (void *) BPF_FUNC_sk_fullsock;

static struct bpf_tcp_sock * (*bpf_tcp_sock) (struct bpf_sock *sk) = (void *) BPF_FUNC_tcp_sock;

static struct bpf_sock * (*bpf_get_listener_sock) (struct bpf_sock *sk) = (void *) BPF_FUNC_get_listener_sock;

static int (*bpf_skb_ecn_set_ce) (void *ctx) = (void *) BPF_FUNC_skb_ecn_set_ce;

static int (*bpf_tcp_check_syncookie) (struct bpf_sock *sk, void *ip, int ip_len, void *tcp, int tcp_len) = (void *) BPF_FUNC_tcp_check_syncookie;

static int (*bpf_sysctl_get_name) (void *ctx, char *buf, unsigned long long buf_len, unsigned long long flags) = (void *) BPF_FUNC_sysctl_get_name;

static int (*bpf_sysctl_get_current_value) (void *ctx, char *buf, unsigned long long buf_len) = (void *) BPF_FUNC_sysctl_get_current_value;

static int (*bpf_sysctl_get_new_value) (void *ctx, char *buf, unsigned long long buf_len) = (void *) BPF_FUNC_sysctl_get_new_value;

static int (*bpf_sysctl_set_new_value) (void *ctx, const char *buf, unsigned long long buf_len) = (void *) BPF_FUNC_sysctl_set_new_value;

static int (*bpf_strtol) (const char *buf, unsigned long long buf_len, unsigned long long flags, long *res) = (void *) BPF_FUNC_strtol;

static int (*bpf_strtoul) (const char *buf, unsigned long long buf_len, unsigned long long flags, unsigned long *res) = (void *) BPF_FUNC_strtoul;

static void * (*bpf_sk_storage_get) (void *map, struct bpf_sock *sk, void *value, __u64 flags) = (void *) BPF_FUNC_sk_storage_get;

static int (*bpf_sk_storage_delete) (void *map, struct bpf_sock *sk) = (void *) BPF_FUNC_sk_storage_delete;

static int (*bpf_send_signal) (unsigned sig) = (void *) BPF_FUNC_send_signal;



<struct>

struct sk_buff;

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf_helpers.h.out:99:99
StructStr struct sk_buff;

unsigned long long load_byte (void * skb, unsigned long long off)

asm ("llvm.bpf.load.byte");

unsigned long long load_half (void * skb, unsigned long long off)

asm ("llvm.bpf.load.half");

unsigned long long load_word (void * skb, unsigned long long off)

asm ("llvm.bpf.load.word");



<struct>

struct bpf_map_def {

    unsigned int type;

    unsigned int key_size;

    unsigned int value_size;

    unsigned int max_entries;

    unsigned int map_flags;

    unsigned int inner_map_idx;

    unsigned int numa_node;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf_helpers.h.out:109:117
StructStr struct bpf_map_def {
    unsigned int type;
    unsigned int key_size;
    unsigned int value_size;
    unsigned int max_entries;
    unsigned int map_flags;
    unsigned int inner_map_idx;
    unsigned int numa_node;
};

#define BPF_ANNOTATE_KV_PAIR(name, type_key, type_val)                     \

  struct ____btf_map_##name {                                              \

    type_key key;                                                          \

    type_val value;                                                        \

  };                                                                       \

  struct ____btf_map_##name __attribute__((section(".maps." #name), used)) \

  ____btf_map_##name = {}

static int (*bpf_skb_load_bytes) (void *ctx, int off, void *to, int len) = (void *) BPF_FUNC_skb_load_bytes;

static int (*bpf_skb_load_bytes_relative) (void *ctx, int off, void *to, int len, __u32 start_header) = (void *) BPF_FUNC_skb_load_bytes_relative;

static int (*bpf_skb_store_bytes) (void *ctx, int off, void *from, int len, int flags) = (void *) BPF_FUNC_skb_store_bytes;

static int (*bpf_l3_csum_replace) (void *ctx, int off, int from, int to, int flags) = (void *) BPF_FUNC_l3_csum_replace;

static int (*bpf_l4_csum_replace) (void *ctx, int off, int from, int to, int flags) = (void *) BPF_FUNC_l4_csum_replace;

static __s64 (*bpf_csum_diff) (void *from, int from_size, void *to, int to_size, int seed) = (void *) BPF_FUNC_csum_diff;

static int (*bpf_skb_under_cgroup) (void *ctx, void *map, int index) = (void *) BPF_FUNC_skb_under_cgroup;

static int (*bpf_skb_change_head) (void *, int len, int flags) = (void *) BPF_FUNC_skb_change_head;

static int (*bpf_skb_pull_data) (void *, int len) = (void *) BPF_FUNC_skb_pull_data;

static unsigned int (*bpf_get_cgroup_classid) (void *ctx) = (void *) BPF_FUNC_get_cgroup_classid;

static unsigned int (*bpf_get_route_realm) (void *ctx) = (void *) BPF_FUNC_get_route_realm;

static int (*bpf_skb_change_proto) (void *ctx, __be16 proto, __u64 flags) = (void *) BPF_FUNC_skb_change_proto;

static int (*bpf_skb_change_type) (void *ctx, __u32 type) = (void *) BPF_FUNC_skb_change_type;

static unsigned int (*bpf_get_hash_recalc) (void *ctx) = (void *) BPF_FUNC_get_hash_recalc;

static unsigned long long (*bpf_get_current_task) (void) = (void *) BPF_FUNC_get_current_task;

static int (*bpf_skb_change_tail) (void *ctx, __u32 len, __u64 flags) = (void *) BPF_FUNC_skb_change_tail;

static long long (*bpf_csum_update) (void *ctx, __u32 csum) = (void *) BPF_FUNC_csum_update;

static void (*bpf_set_hash_invalid) (void *ctx) = (void *) BPF_FUNC_set_hash_invalid;

static int (*bpf_get_numa_node_id) (void) = (void *) BPF_FUNC_get_numa_node_id;

static int (*bpf_probe_read_str) (void *ctx, __u32 size, const void *unsafe_ptr) = (void *) BPF_FUNC_probe_read_str;

static unsigned int (*bpf_get_socket_uid) (void *ctx) = (void *) BPF_FUNC_get_socket_uid;

static unsigned int (*bpf_set_hash) (void *ctx, __u32 hash) = (void *) BPF_FUNC_set_hash;

static int (*bpf_skb_adjust_room) (void *ctx, __s32 len_diff, __u32 mode, unsigned long long flags) = (void *) BPF_FUNC_skb_adjust_room;

#if defined(__TARGET_ARCH_x86)

#define bpf_target_x86

#define bpf_target_defined

#elif defined(__TARGET_ARCH_s390)

#define bpf_target_s390

#define bpf_target_defined

#elif defined(__TARGET_ARCH_arm)

#define bpf_target_arm

#define bpf_target_defined

#elif defined(__TARGET_ARCH_arm64)

#define bpf_target_arm64

#define bpf_target_defined

#elif defined(__TARGET_ARCH_mips)

#define bpf_target_mips

#define bpf_target_defined

#elif defined(__TARGET_ARCH_powerpc)

#define bpf_target_powerpc

#define bpf_target_defined

#elif defined(__TARGET_ARCH_sparc)

#define bpf_target_sparc

#define bpf_target_defined

#else

#undef bpf_target_defined

#endif

#ifndef bpf_target_defined

#if defined(__x86_64__)

#define bpf_target_x86

#elif defined(__s390__)

#define bpf_target_s390

#elif defined(__arm__)

#define bpf_target_arm

#elif defined(__aarch64__)

#define bpf_target_arm64

#elif defined(__mips__)

#define bpf_target_mips

#elif defined(__powerpc__)

#define bpf_target_powerpc

#elif defined(__sparc__)

#define bpf_target_sparc

#endif

#endif

#if defined(bpf_target_x86)

#ifdef __KERNEL__

#define PT_REGS_PARM1(x) ((x)->di)

#define PT_REGS_PARM2(x) ((x)->si)

#define PT_REGS_PARM3(x) ((x)->dx)

#define PT_REGS_PARM4(x) ((x)->cx)

#define PT_REGS_PARM5(x) ((x)->r8)

#define PT_REGS_RET(x) ((x)->sp)

#define PT_REGS_FP(x) ((x)->bp)

#define PT_REGS_RC(x) ((x)->ax)

#define PT_REGS_SP(x) ((x)->sp)

#define PT_REGS_IP(x) ((x)->ip)

#else

#ifdef __i386__

#define PT_REGS_PARM1(x) ((x)->eax)

#define PT_REGS_PARM2(x) ((x)->edx)

#define PT_REGS_PARM3(x) ((x)->ecx)

#define PT_REGS_PARM4(x) 0

#define PT_REGS_PARM5(x) 0

#define PT_REGS_RET(x) ((x)->esp)

#define PT_REGS_FP(x) ((x)->ebp)

#define PT_REGS_RC(x) ((x)->eax)

#define PT_REGS_SP(x) ((x)->esp)

#define PT_REGS_IP(x) ((x)->eip)

#else

#define PT_REGS_PARM1(x) ((x)->rdi)

#define PT_REGS_PARM2(x) ((x)->rsi)

#define PT_REGS_PARM3(x) ((x)->rdx)

#define PT_REGS_PARM4(x) ((x)->rcx)

#define PT_REGS_PARM5(x) ((x)->r8)

#define PT_REGS_RET(x) ((x)->rsp)

#define PT_REGS_FP(x) ((x)->rbp)

#define PT_REGS_RC(x) ((x)->rax)

#define PT_REGS_SP(x) ((x)->rsp)

#define PT_REGS_IP(x) ((x)->rip)

#endif

#endif

#elif defined(bpf_target_s390)



<struct>

struct pt_regs;

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf_helpers.h.out:230:230
StructStr struct pt_regs;

#define PT_REGS_S390 const volatile user_pt_regs

#define PT_REGS_PARM1(x) (((PT_REGS_S390*)(x))->gprs[2])

#define PT_REGS_PARM2(x) (((PT_REGS_S390*)(x))->gprs[3])

#define PT_REGS_PARM3(x) (((PT_REGS_S390*)(x))->gprs[4])

#define PT_REGS_PARM4(x) (((PT_REGS_S390*)(x))->gprs[5])

#define PT_REGS_PARM5(x) (((PT_REGS_S390*)(x))->gprs[6])

#define PT_REGS_RET(x) (((PT_REGS_S390*)(x))->gprs[14])

#define PT_REGS_FP(x) (((PT_REGS_S390*)(x))->gprs[11])

#define PT_REGS_RC(x) (((PT_REGS_S390*)(x))->gprs[2])

#define PT_REGS_SP(x) (((PT_REGS_S390*)(x))->gprs[15])

#define PT_REGS_IP(x) (((PT_REGS_S390*)(x))->psw.addr)

#elif defined(bpf_target_arm)

#define PT_REGS_PARM1(x) ((x)->uregs[0])

#define PT_REGS_PARM2(x) ((x)->uregs[1])

#define PT_REGS_PARM3(x) ((x)->uregs[2])

#define PT_REGS_PARM4(x) ((x)->uregs[3])

#define PT_REGS_PARM5(x) ((x)->uregs[4])

#define PT_REGS_RET(x) ((x)->uregs[14])

#define PT_REGS_FP(x) \

  ((x)->uregs[11]) /* Works only with CONFIG_FRAME_POINTER */

#define PT_REGS_RC(x) ((x)->uregs[0])

#define PT_REGS_SP(x) ((x)->uregs[13])

#define PT_REGS_IP(x) ((x)->uregs[12])

#elif defined(bpf_target_arm64)



<struct>

struct pt_regs;

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf_helpers.h.out:258:258
StructStr struct pt_regs;

#define PT_REGS_ARM64 const volatile struct user_pt_regs

#define PT_REGS_PARM1(x) (((PT_REGS_ARM64*)(x))->regs[0])

#define PT_REGS_PARM2(x) (((PT_REGS_ARM64*)(x))->regs[1])

#define PT_REGS_PARM3(x) (((PT_REGS_ARM64*)(x))->regs[2])

#define PT_REGS_PARM4(x) (((PT_REGS_ARM64*)(x))->regs[3])

#define PT_REGS_PARM5(x) (((PT_REGS_ARM64*)(x))->regs[4])

#define PT_REGS_RET(x) (((PT_REGS_ARM64*)(x))->regs[30])

#define PT_REGS_FP(x) (((PT_REGS_ARM64*)(x))->regs[29])

#define PT_REGS_RC(x) (((PT_REGS_ARM64*)(x))->regs[0])

#define PT_REGS_SP(x) (((PT_REGS_ARM64*)(x))->sp)

#define PT_REGS_IP(x) (((PT_REGS_ARM64*)(x))->pc)

#elif defined(bpf_target_mips)

#define PT_REGS_PARM1(x) ((x)->regs[4])

#define PT_REGS_PARM2(x) ((x)->regs[5])

#define PT_REGS_PARM3(x) ((x)->regs[6])

#define PT_REGS_PARM4(x) ((x)->regs[7])

#define PT_REGS_PARM5(x) ((x)->regs[8])

#define PT_REGS_RET(x) ((x)->regs[31])

#define PT_REGS_FP(x) ((x)->regs[30]) /* Works only with CONFIG_FRAME_POINTER \

                                       */

#define PT_REGS_RC(x) ((x)->regs[1])

#define PT_REGS_SP(x) ((x)->regs[29])

#define PT_REGS_IP(x) ((x)->cp0_epc)

#elif defined(bpf_target_powerpc)

#define PT_REGS_PARM1(x) ((x)->gpr[3])

#define PT_REGS_PARM2(x) ((x)->gpr[4])

#define PT_REGS_PARM3(x) ((x)->gpr[5])

#define PT_REGS_PARM4(x) ((x)->gpr[6])

#define PT_REGS_PARM5(x) ((x)->gpr[7])

#define PT_REGS_RC(x) ((x)->gpr[3])

#define PT_REGS_SP(x) ((x)->sp)

#define PT_REGS_IP(x) ((x)->nip)

#elif defined(bpf_target_sparc)

#define PT_REGS_PARM1(x) ((x)->u_regs[UREG_I0])

#define PT_REGS_PARM2(x) ((x)->u_regs[UREG_I1])

#define PT_REGS_PARM3(x) ((x)->u_regs[UREG_I2])

#define PT_REGS_PARM4(x) ((x)->u_regs[UREG_I3])

#define PT_REGS_PARM5(x) ((x)->u_regs[UREG_I4])

#define PT_REGS_RET(x) ((x)->u_regs[UREG_I7])

#define PT_REGS_RC(x) ((x)->u_regs[UREG_I0])

#define PT_REGS_SP(x) ((x)->u_regs[UREG_FP])

#if defined(__arch64__)

#define PT_REGS_IP(x) ((x)->tpc)

#else

#define PT_REGS_IP(x) ((x)->pc)

#endif

#endif

#if defined(bpf_target_powerpc)

#define BPF_KPROBE_READ_RET_IP(ip, ctx) ({ (ip) = (ctx)->link; })

#define BPF_KRETPROBE_READ_RET_IP BPF_KPROBE_READ_RET_IP

#elif defined(bpf_target_sparc)

#define BPF_KPROBE_READ_RET_IP(ip, ctx) ({ (ip) = PT_REGS_RET(ctx); })

#define BPF_KRETPROBE_READ_RET_IP BPF_KPROBE_READ_RET_IP

#else

#define BPF_KPROBE_READ_RET_IP(ip, ctx) \

  ({ bpf_probe_read(&(ip), sizeof(ip), (void*)PT_REGS_RET(ctx)); })

#define BPF_KRETPROBE_READ_RET_IP(ip, ctx)                                    \

  ({                                                                          \

    bpf_probe_read(&(ip), sizeof(ip), (void*)(PT_REGS_FP(ctx) + sizeof(ip))); \

  })

#endif

#endif

structFIle:  ./txl_annotate/annotate_struct_test_healthchecking_kern.c.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_healthchecking_kern.c.out
string #if exists in file
line Number: 41 #if HC_MAX_PACKET_SIZE > 0

[]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_healthchecking_kern.c.out
#include <linux/if_ether.h>

#include <linux/ip.h>

#include <linux/ipv6.h>

#include <linux/pkt_cls.h>

#include <linux/string.h>

#include <linux/udp.h>

#include "bpf.h"

#include "bpf_helpers.h"

#include "encap_helpers.h"

#include "healthchecking_helpers.h"

#include "healthchecking_maps.h"

#include "healthchecking_structs.h"



SEC ("tc")

int healthcheck_encap (struct __sk_buff *skb) {

    __u32 stats_key = GENERIC_STATS_INDEX;

    __u32 key = HC_MAIN_INTF_POSITION;

    __u32 somark = skb->mark;

    __u32 ifindex = 0;

    __u64 flags = 0;

    bool is_ipv6 = false;

    int adjust_len = 0;

    int ret = 0;

    struct hc_stats *prog_stats;

    struct ethhdr *ethh;

    struct hc_mac *esrc, *edst;

    struct hc_real_definition *src;

    prog_stats = bpf_map_lookup_elem (&hc_stats_map, &stats_key);

    if (!prog_stats) {

        return TC_ACT_UNSPEC;

    }

    if (somark == 0) {

        prog_stats->pckts_skipped += 1;

        return TC_ACT_UNSPEC;

    }

    struct hc_real_definition *real = bpf_map_lookup_elem (&hc_reals_map, &somark);

    if (!real) {

        prog_stats->pckts_skipped += 1;

        return TC_ACT_UNSPEC;

    }

#if HC_MAX_PACKET_SIZE > 0

    if (skb->len > HC_MAX_PACKET_SIZE) {

        prog_stats->pckts_dropped += 1;

        prog_stats->pckts_too_big += 1;

        return TC_ACT_SHOT;

    }

#endif

    __u32 *intf_ifindex = bpf_map_lookup_elem (&hc_ctrl_map, &key);

    if (!intf_ifindex) {

        prog_stats->pckts_dropped += 1;

        return TC_ACT_SHOT;

    }

    key = HC_SRC_MAC_POS;

    esrc = bpf_map_lookup_elem (&hc_pckt_macs, &key);

    if (!esrc) {

        prog_stats->pckts_dropped += 1;

        return TC_ACT_SHOT;

    }

    key = HC_DST_MAC_POS;

    edst = bpf_map_lookup_elem (&hc_pckt_macs, &key);

    if (!edst) {

        prog_stats->pckts_dropped += 1;

        return TC_ACT_SHOT;

    }

    if ((skb->data + sizeof (struct ethhdr)) > skb->data_end) {

        prog_stats->pckts_dropped += 1;

        return TC_ACT_SHOT;

    }

    ethh = (void *) (long) skb->data;

    if (ethh->h_proto == BE_ETH_P_IPV6) {

        is_ipv6 = true;

    }

    struct hc_key hckey = {};

    bool hc_key_parseable = set_hc_key (skb, &hckey, is_ipv6);

    skb->mark = 0;

    if (!HC_ENCAP (skb, real, ethh, is_ipv6)) {

        prog_stats->pckts_dropped += 1;

        return TC_ACT_SHOT;

    }

    if (skb->data + sizeof (struct ethhdr) > skb->data_end) {

        prog_stats->pckts_dropped += 1;

        return TC_ACT_SHOT;

    }

    ethh = (void *) (long) skb->data;

    memcpy (ethh -> h_source, esrc -> mac, 6);

    memcpy (ethh -> h_dest, edst -> mac, 6);

    prog_stats->pckts_processed += 1;

    if (hc_key_parseable) {

        __u32 *hc_key_cntr_index = bpf_map_lookup_elem (&hc_key_map, &hckey);

        if (hc_key_cntr_index) {

            __u32 *packets_processed_for_hc_key = bpf_map_lookup_elem (&per_hckey_stats, hc_key_cntr_index);

            if (packets_processed_for_hc_key) {

                *packets_processed_for_hc_key += 1;

            }

        }

    }

    return bpf_redirect (*intf_ifindex, REDIRECT_EGRESS);

}



char _license [] SEC ("license") = "GPL";

structFIle:  ./txl_annotate/annotate_struct_test_flow_debug_maps.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_flow_debug_maps.h.out
string #ifndef exists in file
line Number: 1 #ifndef __FLOW_DEBUG_MAPS_H

string #endif exists in file
line Number: 17 #endif // of __FLOW_DEBUG_MAPS_H

[('#ifndef ', '__FLOW_DEBUG_MAPS_H', 1, 16)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_flow_debug_maps.h.out
#ifndef __FLOW_DEBUG_MAPS_H

#define __FLOW_DEBUG_MAPS_H

#include "balancer_structs.h"

#include "bpf.h"

#include "bpf_helpers.h"

#include "flow_debug.h"



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_ARRAY_OF_MAPS);

    __uint (key_size, sizeof (__u32));

    __uint (value_size, sizeof (__u32));

    __uint (max_entries, MAX_SUPPORTED_CPUS);

    __uint (map_flags, NO_FLAGS);

} flow_debug_maps SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_flow_debug_maps.h.out:9:15
StructStr struct {
    __uint (type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
    __uint (key_size, sizeof (__u32));
    __uint (value_size, sizeof (__u32));
    __uint (max_entries, MAX_SUPPORTED_CPUS);
    __uint (map_flags, NO_FLAGS);
} flow_debug_maps SEC (".maps");

#endif // of __FLOW_DEBUG_MAPS_H

structFIle:  ./txl_annotate/annotate_struct_test_pckt_encap.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_pckt_encap.h.out
string #ifndef exists in file
line Number: 1 #ifndef __PCKT_ENCAP_H

string #ifdef exists in file
line Number: 122 #ifdef GUE_ENCAP

string #endif exists in file
line Number: 272 #endif // of GUE_ENCAP

string #ifdef exists in file
line Number: 273 #ifdef INLINE_DECAP_GUE

string #endif exists in file
line Number: 313 #endif // of INLINE_DECAP_GUE

string #endif exists in file
line Number: 314 #endif // of __PCKT_ENCAP_H

[('#ifdef ', 'GUE_ENCAP', 122, 271), ('#ifdef ', 'INLINE_DECAP_GUE', 273, 312), ('#ifndef ', '__PCKT_ENCAP_H', 1, 313)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_pckt_encap.h.out
#ifndef __PCKT_ENCAP_H

#define __PCKT_ENCAP_H

#include <linux/ip.h>

#include <linux/ipv6.h>

#include <string.h>

#include "balancer_consts.h"

#include "balancer_helpers.h"

#include "balancer_structs.h"

#include "bpf.h"

#include "bpf_endian.h"

#include "bpf_helpers.h"

#include "control_data_maps.h"

#include "encap_helpers.h"

#include "flow_debug.h"

#include "pckt_parsing.h"



__attribute__ ((__always_inline__)) static inline bool encap_v6 (struct xdp_md *xdp, struct ctl_value *cval, bool is_ipv6, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes) {

    void *data;

    void *data_end;

    struct ipv6hdr *ip6h;

    struct ethhdr *new_eth;

    struct ethhdr *old_eth;

    __u16 payload_len;

    __u32 ip_suffix;

    __u32 saddr [4];

    __u8 proto;

    if (bpf_xdp_adjust_head (xdp, 0 - (int) sizeof (struct ipv6hdr))) {

        return false;

    }

    data = (void *) (long) xdp->data;

    data_end = (void *) (long) xdp->data_end;

    new_eth = data;

    ip6h = data + sizeof (struct ethhdr);

    old_eth = data + sizeof (struct ipv6hdr);

    if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {

        return false;

    }

    memcpy (new_eth -> h_dest, cval -> mac, 6);

    memcpy (new_eth -> h_source, old_eth -> h_dest, 6);

    new_eth->h_proto = BE_ETH_P_IPV6;

    if (is_ipv6) {

        proto = IPPROTO_IPV6;

        ip_suffix = pckt->flow.srcv6[3] ^ pckt->flow.port16[0];

        payload_len = pkt_bytes + sizeof (struct ipv6hdr);

    }

    else {

        proto = IPPROTO_IPIP;

        ip_suffix = pckt->flow.src ^ pckt->flow.port16[0];

        payload_len = pkt_bytes;

    }

    saddr[0] = IPIP_V6_PREFIX1;

    saddr[1] = IPIP_V6_PREFIX2;

    saddr[2] = IPIP_V6_PREFIX3;

    saddr[3] = ip_suffix;

    create_v6_hdr (ip6h, pckt -> tos, saddr, dst -> dstv6, payload_len, proto);

    return true;

}



__attribute__ ((__always_inline__)) static inline bool encap_v4 (struct xdp_md *xdp, struct ctl_value *cval, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes) {

    void *data;

    void *data_end;

    struct iphdr *iph;

    struct ethhdr *new_eth;

    struct ethhdr *old_eth;

    __u32 ip_suffix = bpf_htons (pckt->flow.port16[0]);

    ip_suffix <<= 16;

    ip_suffix ^= pckt->flow.src;

    if (bpf_xdp_adjust_head (xdp, 0 - (int) sizeof (struct iphdr))) {

        return false;

    }

    data = (void *) (long) xdp->data;

    data_end = (void *) (long) xdp->data_end;

    new_eth = data;

    iph = data + sizeof (struct ethhdr);

    old_eth = data + sizeof (struct iphdr);

    if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {

        return false;

    }

    memcpy (new_eth -> h_dest, cval -> mac, 6);

    memcpy (new_eth -> h_source, old_eth -> h_dest, 6);

    new_eth->h_proto = BE_ETH_P_IP;

    create_v4_hdr (iph, pckt -> tos, ((0xFFFF0000 & ip_suffix) | IPIP_V4_PREFIX), dst -> dst, pkt_bytes, IPPROTO_IPIP);

    return true;

}



__attribute__ ((__always_inline__)) static inline bool decap_v6 (struct xdp_md *xdp, void **data, void **data_end, bool inner_v4) {

    struct ethhdr *new_eth;

    struct ethhdr *old_eth;

    old_eth = *data;

    new_eth = *data + sizeof (struct ipv6hdr);

    memcpy (new_eth -> h_source, old_eth -> h_source, 6);

    memcpy (new_eth -> h_dest, old_eth -> h_dest, 6);

    if (inner_v4) {

        new_eth->h_proto = BE_ETH_P_IP;

    }

    else {

        new_eth->h_proto = BE_ETH_P_IPV6;

    }

    if (bpf_xdp_adjust_head (xdp, (int) sizeof (struct ipv6hdr))) {

        return false;

    }

    *data = (void *) (long) xdp->data;

    *data_end = (void *) (long) xdp->data_end;

    return true;

}



__attribute__ ((__always_inline__)) static inline bool decap_v4 (struct xdp_md *xdp, void **data, void **data_end) {

    struct ethhdr *new_eth;

    struct ethhdr *old_eth;

    old_eth = *data;

    new_eth = *data + sizeof (struct iphdr);

    memcpy (new_eth -> h_source, old_eth -> h_source, 6);

    memcpy (new_eth -> h_dest, old_eth -> h_dest, 6);

    new_eth->h_proto = BE_ETH_P_IP;

    if (bpf_xdp_adjust_head (xdp, (int) sizeof (struct iphdr))) {

        return false;

    }

    *data = (void *) (long) xdp->data;

    *data_end = (void *) (long) xdp->data_end;

    return true;

}

#ifdef GUE_ENCAP



__attribute__ ((__always_inline__)) static inline bool gue_csum (void *data, void *data_end, bool outer_v6, bool inner_v6, struct packet_description *pckt, __u64 *csum) {

    __u16 outer_ip_off;

    __u16 udp_hdr_off;

    __u16 inner_ip_off;

    __u16 inner_transport_off;

    struct udphdr *udph;

    outer_ip_off = sizeof (struct ethhdr);

    udp_hdr_off = outer_v6 ? outer_ip_off + sizeof (struct ipv6hdr) : outer_ip_off + sizeof (struct iphdr);

    inner_ip_off = udp_hdr_off + sizeof (struct udphdr);

    inner_transport_off = inner_v6 ? inner_ip_off + sizeof (struct ipv6hdr) : inner_ip_off + sizeof (struct iphdr);

    if (data + inner_transport_off > data_end) {

        return false;

    }

    if (pckt->flow.proto == IPPROTO_UDP) {

        struct udphdr *inner_udp = data + inner_transport_off;

        if (inner_udp + 1 > data_end) {

            return false;

        }

        *csum = inner_udp->check;

    }

    else if (pckt->flow.proto == IPPROTO_TCP) {

        struct tcphdr *inner_tcp = data + inner_transport_off;

        if (inner_tcp + 1 > data_end) {

            return false;

        }

        *csum = inner_tcp->check;

    }

    else {

        return false;

    }

    if (inner_v6) {

        struct ipv6hdr *outer_ip6h = data + outer_ip_off;

        udph = (void *) data + udp_hdr_off;

        struct ipv6hdr *inner_ip6h = data + inner_ip_off;

        if (outer_ip6h + 1 > data_end || udph + 1 > data_end || inner_ip6h + 1 > data_end) {

            return false;

        }

        return gue_csum_v6 (outer_ip6h, udph, inner_ip6h, csum);

    }

    else {

        if (outer_v6) {

            struct ipv6hdr *outer_ip6h = data + outer_ip_off;

            udph = data + udp_hdr_off;

            struct iphdr *inner_iph = data + inner_ip_off;

            if (outer_ip6h + 1 > data_end || udph + 1 > data_end || inner_iph + 1 > data_end) {

                return false;

            }

            return gue_csum_v4_in_v6 (outer_ip6h, udph, inner_iph, csum);

        }

        else {

            struct iphdr *outer_iph = data + outer_ip_off;

            udph = data + udp_hdr_off;

            struct iphdr *inner_iph = data + inner_ip_off;

            if (outer_iph + 1 > data_end || udph + 1 > data_end || inner_iph + 1 > data_end) {

                return false;

            }

            return gue_csum_v4 (outer_iph, udph, inner_iph, csum);

        }

    }

    return true;

}



__attribute__ ((__always_inline__)) static inline bool gue_encap_v4 (struct xdp_md *xdp, struct ctl_value *cval, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes) {

    void *data;

    void *data_end;

    struct iphdr *iph;

    struct udphdr *udph;

    struct ethhdr *new_eth;

    struct ethhdr *old_eth;

    struct real_definition *src;

    __u16 sport = bpf_htons (pckt->flow.port16[0]);

    __u32 ipv4_src = V4_SRC_INDEX;

    src = bpf_map_lookup_elem (&pckt_srcs, &ipv4_src);

    if (!src) {

        return false;

    }

    ipv4_src = src->dst;

    sport ^= ((pckt->flow.src >> 16) & 0xFFFF);

    if (bpf_xdp_adjust_head (xdp, 0 - ((int) sizeof (struct iphdr) + (int) sizeof (struct udphdr)))) {

        return false;

    }

    data = (void *) (long) xdp->data;

    data_end = (void *) (long) xdp->data_end;

    new_eth = data;

    iph = data + sizeof (struct ethhdr);

    udph = (void *) iph + sizeof (struct iphdr);

    old_eth = data + sizeof (struct iphdr) + sizeof (struct udphdr);

    if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end || udph + 1 > data_end) {

        return false;

    }

    memcpy (new_eth -> h_dest, cval -> mac, sizeof (new_eth -> h_dest));

    memcpy (new_eth -> h_source, old_eth -> h_dest, sizeof (new_eth -> h_source));

    new_eth->h_proto = BE_ETH_P_IP;

    create_udp_hdr (udph, sport, GUE_DPORT, pkt_bytes + sizeof (struct udphdr), 0);

    create_v4_hdr (iph, pckt -> tos, ipv4_src, dst -> dst, pkt_bytes + sizeof (struct udphdr), IPPROTO_UDP);

    __u64 csum = 0;

    if (gue_csum (data, data_end, false, false, pckt, &csum)) {

        udph->check = csum & 0xFFFF;

    }

    return true;

}



__attribute__ ((__always_inline__)) static inline bool gue_encap_v6 (struct xdp_md *xdp, struct ctl_value *cval, bool is_ipv6, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes) {

    void *data;

    void *data_end;

    struct ipv6hdr *ip6h;

    struct ethhdr *new_eth;

    struct ethhdr *old_eth;

    struct udphdr *udph;

    __u32 key = V6_SRC_INDEX;

    __u16 payload_len;

    __u16 sport;

    struct real_definition *src;

    src = bpf_map_lookup_elem (&pckt_srcs, &key);

    if (!src) {

        return false;

    }

    if (bpf_xdp_adjust_head (xdp, 0 - ((int) sizeof (struct ipv6hdr) + (int) sizeof (struct udphdr)))) {

        return false;

    }

    data = (void *) (long) xdp->data;

    data_end = (void *) (long) xdp->data_end;

    new_eth = data;

    ip6h = data + sizeof (struct ethhdr);

    udph = (void *) ip6h + sizeof (struct ipv6hdr);

    old_eth = data + sizeof (struct ipv6hdr) + sizeof (struct udphdr);

    if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end || udph + 1 > data_end) {

        return false;

    }

    memcpy (new_eth -> h_dest, cval -> mac, 6);

    memcpy (new_eth -> h_source, old_eth -> h_dest, 6);

    new_eth->h_proto = BE_ETH_P_IPV6;

    if (is_ipv6) {

        sport = (pckt->flow.srcv6[3] & 0xFFFF) ^ pckt->flow.port16[0];

        pkt_bytes += (sizeof (struct ipv6hdr) + sizeof (struct udphdr));

    }

    else {

        sport = ((pckt->flow.src >> 16) & 0xFFFF) ^ pckt->flow.port16[0];

        pkt_bytes += sizeof (struct udphdr);

    }

    create_udp_hdr (udph, sport, GUE_DPORT, pkt_bytes, 0);

    create_v6_hdr (ip6h, pckt -> tos, src -> dstv6, dst -> dstv6, pkt_bytes, IPPROTO_UDP);

    __u64 csum = 0;

    if (gue_csum (data, data_end, true, is_ipv6, pckt, &csum)) {

        udph->check = csum & 0xFFFF;

    }

    return true;

}

#endif // of GUE_ENCAP

#ifdef INLINE_DECAP_GUE



__attribute__ ((__always_inline__)) static inline bool gue_decap_v4 (struct xdp_md *xdp, void **data, void **data_end) {

    struct ethhdr *new_eth;

    struct ethhdr *old_eth;

    old_eth = *data;

    new_eth = *data + sizeof (struct iphdr) + sizeof (struct udphdr);

    RECORD_GUE_ROUTE (old_eth, new_eth, * data_end, true, true);

    memcpy (new_eth -> h_source, old_eth -> h_source, 6);

    memcpy (new_eth -> h_dest, old_eth -> h_dest, 6);

    new_eth->h_proto = BE_ETH_P_IP;

    if (bpf_xdp_adjust_head (xdp, (int) (sizeof (struct iphdr) + sizeof (struct udphdr)))) {

        return false;

    }

    *data = (void *) (long) xdp->data;

    *data_end = (void *) (long) xdp->data_end;

    return true;

}



__attribute__ ((__always_inline__)) static inline bool gue_decap_v6 (struct xdp_md *xdp, void **data, void **data_end, bool inner_v4) {

    struct ethhdr *new_eth;

    struct ethhdr *old_eth;

    old_eth = *data;

    new_eth = *data + sizeof (struct ipv6hdr) + sizeof (struct udphdr);

    RECORD_GUE_ROUTE (old_eth, new_eth, * data_end, false, inner_v4);

    memcpy (new_eth -> h_source, old_eth -> h_source, 6);

    memcpy (new_eth -> h_dest, old_eth -> h_dest, 6);

    if (inner_v4) {

        new_eth->h_proto = BE_ETH_P_IP;

    }

    else {

        new_eth->h_proto = BE_ETH_P_IPV6;

    }

    if (bpf_xdp_adjust_head (xdp, (int) (sizeof (struct ipv6hdr) + sizeof (struct udphdr)))) {

        return false;

    }

    *data = (void *) (long) xdp->data;

    *data_end = (void *) (long) xdp->data_end;

    return true;

}

#endif // of INLINE_DECAP_GUE

#endif // of __PCKT_ENCAP_H



structFIle:  ./txl_annotate/annotate_struct_test_handle_icmp.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_handle_icmp.h.out
string #ifndef exists in file
line Number: 1 #ifndef __HANDLE_ICMP_H

string #endif exists in file
line Number: 234 #endif // of __HANDLE_ICMP_H

[('#ifndef ', '__HANDLE_ICMP_H', 1, 233)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_handle_icmp.h.out
#ifndef __HANDLE_ICMP_H

#define __HANDLE_ICMP_H

#include <linux/icmp.h>

#include <linux/icmpv6.h>

#include <linux/if_ether.h>

#include <linux/ip.h>

#include <linux/ipv6.h>

#include <stddef.h>

#include "balancer_consts.h"

#include "balancer_helpers.h"

#include "balancer_structs.h"

#include "bpf.h"

#include "bpf_endian.h"



__attribute__ ((__always_inline__)) static inline int swap_mac_and_send (void *data, void *data_end) {

    struct ethhdr *eth;

    unsigned char tmp_mac [ETH_ALEN];

    eth = data;

    memcpy (tmp_mac, eth -> h_source, ETH_ALEN);

    memcpy (eth -> h_source, eth -> h_dest, ETH_ALEN);

    memcpy (eth -> h_dest, tmp_mac, ETH_ALEN);

    return XDP_TX;

}



__attribute__ ((__always_inline__)) static inline void swap_mac (void *data, struct ethhdr *orig_eth) {

    struct ethhdr *eth;

    eth = data;

    memcpy (eth -> h_source, orig_eth -> h_dest, ETH_ALEN);

    memcpy (eth -> h_dest, orig_eth -> h_source, ETH_ALEN);

    eth->h_proto = orig_eth->h_proto;

}



__attribute__ ((__always_inline__)) static inline int send_icmp_reply (void *data, void *data_end) {

    struct iphdr *iph;

    struct icmphdr *icmp_hdr;

    __u32 tmp_addr = 0;

    __u64 csum = 0;

    __u64 off = 0;

    if ((data + sizeof (struct ethhdr) + sizeof (struct iphdr) + sizeof (struct icmphdr)) > data_end) {

        return XDP_DROP;

    }

    off += sizeof (struct ethhdr);

    iph = data + off;

    off += sizeof (struct iphdr);

    icmp_hdr = data + off;

    icmp_hdr->type = ICMP_ECHOREPLY;

    icmp_hdr->checksum += 0x0008;

    iph->ttl = DEFAULT_TTL;

    tmp_addr = iph->daddr;

    iph->daddr = iph->saddr;

    iph->saddr = tmp_addr;

    iph->check = 0;

    ipv4_csum_inline (iph, & csum);

    iph->check = csum;

    return swap_mac_and_send (data, data_end);

}



__attribute__ ((__always_inline__)) static inline int send_icmp6_reply (void *data, void *data_end) {

    struct ipv6hdr *ip6h;

    struct icmp6hdr *icmp_hdr;

    __be32 tmp_addr [4];

    __u64 off = 0;

    if ((data + sizeof (struct ethhdr) + sizeof (struct ipv6hdr) + sizeof (struct icmp6hdr)) > data_end) {

        return XDP_DROP;

    }

    off += sizeof (struct ethhdr);

    ip6h = data + off;

    off += sizeof (struct ipv6hdr);

    icmp_hdr = data + off;

    icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;

    icmp_hdr->icmp6_cksum -= 0x0001;

    ip6h->hop_limit = DEFAULT_TTL;

    memcpy (tmp_addr, ip6h -> saddr.s6_addr32, 16);

    memcpy (ip6h -> saddr.s6_addr32, ip6h -> daddr.s6_addr32, 16);

    memcpy (ip6h -> daddr.s6_addr32, tmp_addr, 16);

    return swap_mac_and_send (data, data_end);

}



__attribute__ ((__always_inline__)) static inline int send_icmp4_too_big (struct xdp_md *xdp) {

    int headroom = (int) sizeof (struct iphdr) + (int) sizeof (struct icmphdr);

    if (bpf_xdp_adjust_head (xdp, 0 - headroom)) {

        return XDP_DROP;

    }

    void *data = (void *) (long) xdp->data;

    void *data_end = (void *) (long) xdp->data_end;

    if (data + (ICMP_TOOBIG_SIZE + headroom) > data_end) {

        return XDP_DROP;

    }

    struct iphdr *iph, *orig_iph;

    struct ethhdr *orig_eth;

    struct icmphdr *icmp_hdr;

    __u64 csum = 0;

    __u64 off = 0;

    orig_eth = data + headroom;

    swap_mac (data, orig_eth);

    off += sizeof (struct ethhdr);

    iph = data + off;

    off += sizeof (struct iphdr);

    icmp_hdr = data + off;

    off += sizeof (struct icmphdr);

    orig_iph = data + off;

    icmp_hdr->type = ICMP_DEST_UNREACH;

    icmp_hdr->code = ICMP_FRAG_NEEDED;

    icmp_hdr->un.frag.mtu = bpf_htons (MAX_PCKT_SIZE - sizeof (struct ethhdr));

    icmp_hdr->checksum = 0;

    ipv4_csum (icmp_hdr, ICMP_TOOBIG_PAYLOAD_SIZE, & csum);

    icmp_hdr->checksum = csum;

    iph->ttl = DEFAULT_TTL;

    iph->daddr = orig_iph->saddr;

    iph->saddr = orig_iph->daddr;

    iph->version = 4;

    iph->ihl = 5;

    iph->protocol = IPPROTO_ICMP;

    iph->tos = 0;

    iph->tot_len = bpf_htons (ICMP_TOOBIG_SIZE +headroom - sizeof (struct ethhdr));

    iph->check = 0;

    csum = 0;

    ipv4_csum (iph, sizeof (struct iphdr), & csum);

    iph->check = csum;

    return XDP_TX;

}



__attribute__ ((__always_inline__)) static inline int send_icmp6_too_big (struct xdp_md *xdp) {

    int headroom = (int) sizeof (struct ipv6hdr) + (int) sizeof (struct icmp6hdr);

    if (bpf_xdp_adjust_head (xdp, 0 - headroom)) {

        return XDP_DROP;

    }

    void *data = (void *) (long) xdp->data;

    void *data_end = (void *) (long) xdp->data_end;

    if (data + (ICMP6_TOOBIG_SIZE + headroom) > data_end) {

        return XDP_DROP;

    }

    struct ipv6hdr *ip6h, *orig_ip6h;

    struct ethhdr *orig_eth;

    struct icmp6hdr *icmp6_hdr;

    __u64 csum = 0;

    __u64 off = 0;

    orig_eth = data + headroom;

    swap_mac (data, orig_eth);

    off += sizeof (struct ethhdr);

    ip6h = data + off;

    off += sizeof (struct ipv6hdr);

    icmp6_hdr = data + off;

    off += sizeof (struct icmp6hdr);

    orig_ip6h = data + off;

    ip6h->version = 6;

    ip6h->priority = 0;

    ip6h->nexthdr = IPPROTO_ICMPV6;

    ip6h->hop_limit = DEFAULT_TTL;

    ip6h->payload_len = bpf_htons (ICMP6_TOOBIG_PAYLOAD_SIZE);

    memset (ip6h -> flow_lbl, 0, sizeof (ip6h -> flow_lbl));

    memcpy (ip6h -> daddr.s6_addr32, orig_ip6h -> saddr.s6_addr32, 16);

    memcpy (ip6h -> saddr.s6_addr32, orig_ip6h -> daddr.s6_addr32, 16);

    icmp6_hdr->icmp6_type = ICMPV6_PKT_TOOBIG;

    icmp6_hdr->icmp6_code = 0;

    icmp6_hdr->icmp6_mtu = bpf_htonl (MAX_PCKT_SIZE - sizeof (struct ethhdr));

    icmp6_hdr->icmp6_cksum = 0;

    ipv6_csum (icmp6_hdr, ICMP6_TOOBIG_PAYLOAD_SIZE, & csum, ip6h);

    icmp6_hdr->icmp6_cksum = csum;

    return XDP_TX;

}



__attribute__ ((__always_inline__)) static inline int send_icmp_too_big (struct xdp_md *xdp, bool is_ipv6, int pckt_size) {

    int offset = pckt_size;

    if (is_ipv6) {

        offset -= ICMP6_TOOBIG_SIZE;

    }

    else {

        offset -= ICMP_TOOBIG_SIZE;

    }

    if (bpf_xdp_adjust_tail (xdp, 0 - offset)) {

        return XDP_DROP;

    }

    if (is_ipv6) {

        return send_icmp6_too_big (xdp);

    }

    else {

        return send_icmp4_too_big (xdp);

    }

}



__attribute__ ((__always_inline__)) static inline int parse_icmpv6 (void *data, void *data_end, __u64 off, struct packet_description *pckt) {

    struct icmp6hdr *icmp_hdr;

    struct ipv6hdr *ip6h;

    icmp_hdr = data + off;

    if (icmp_hdr + 1 > data_end) {

        return XDP_DROP;

    }

    if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {

        return send_icmp6_reply (data, data_end);

    }

    if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) && (icmp_hdr->icmp6_type != ICMPV6_DEST_UNREACH)) {

        return XDP_PASS;

    }

    off += sizeof (struct icmp6hdr);

    ip6h = data + off;

    if (ip6h + 1 > data_end) {

        return XDP_DROP;

    }

    pckt->flow.proto = ip6h->nexthdr;

    pckt->flags |= F_ICMP;

    memcpy (pckt -> flow.srcv6, ip6h -> daddr.s6_addr32, 16);

    memcpy (pckt -> flow.dstv6, ip6h -> saddr.s6_addr32, 16);

    return FURTHER_PROCESSING;

}



__attribute__ ((__always_inline__)) static inline int parse_icmp (void *data, void *data_end, __u64 off, struct packet_description *pckt) {

    struct icmphdr *icmp_hdr;

    struct iphdr *iph;

    icmp_hdr = data + off;

    if (icmp_hdr + 1 > data_end) {

        return XDP_DROP;

    }

    if (icmp_hdr->type == ICMP_ECHO) {

        return send_icmp_reply (data, data_end);

    }

    if (icmp_hdr->type != ICMP_DEST_UNREACH) {

        return XDP_PASS;

    }

    off += sizeof (struct icmphdr);

    iph = data + off;

    if (iph + 1 > data_end) {

        return XDP_DROP;

    }

    if (iph->ihl != 5) {

        return XDP_DROP;

    }

    pckt->flow.proto = iph->protocol;

    pckt->flags |= F_ICMP;

    pckt->flow.src = iph->daddr;

    pckt->flow.dst = iph->saddr;

    return FURTHER_PROCESSING;

}

#endif // of __HANDLE_ICMP_H



structFIle:  ./txl_annotate/annotate_struct_test_balancer_structs.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_balancer_structs.h.out
string #ifndef exists in file
line Number: 1 #ifndef __BALANCER_STRUCTS_H

string #ifdef exists in file
line Number: 105 #ifdef KATRAN_INTROSPECTION

string #ifdef exists in file
line Number: 115 #ifdef RECORD_FLOW_INFO

string #endif exists in file
line Number: 129 #endif // of RECORD_FLOW_INFO

string #endif exists in file
line Number: 130 #endif // of _BALANCER_STRUCTS

[('#ifdef ', 'RECORD_FLOW_INFO', 115, 128), ('#ifdef ', 'KATRAN_INTROSPECTION', 105, 129)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_balancer_structs.h.out
#ifndef __BALANCER_STRUCTS_H

#define __BALANCER_STRUCTS_H



<struct>

struct flow_key {

    union {

        __be32 src;

        __be32 srcv6 [4];

    };

    union {

        __be32 dst;

        __be32 dstv6 [4];

    };

    union {

        __u32 ports;

        __u16 port16 [2];

    };

    __u8 proto;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_structs.h.out:5:19
StructStr struct flow_key {
    union {
        __be32 src;
        __be32 srcv6 [4];
    };
    union {
        __be32 dst;
        __be32 dstv6 [4];
    };
    union {
        __u32 ports;
        __u16 port16 [2];
    };
    __u8 proto;
};



<struct>

struct packet_description {

    struct flow_key flow;

    __u32 real_index;

    __u8 flags;

    __u8 tos;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_structs.h.out:23:28
StructStr struct packet_description {
    struct flow_key flow;
    __u32 real_index;
    __u8 flags;
    __u8 tos;
};



<struct>

struct ctl_value {

    union {

        __u64 value;

        __u32 ifindex;

        __u8 mac [6];

    };

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_structs.h.out:32:38
StructStr struct ctl_value {
    union {
        __u64 value;
        __u32 ifindex;
        __u8 mac [6];
    };
};



<struct>

struct vip_definition {

    union {

        __be32 vip;

        __be32 vipv6 [4];

    };

    __u16 port;

    __u8 proto;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_structs.h.out:42:49
StructStr struct vip_definition {
    union {
        __be32 vip;
        __be32 vipv6 [4];
    };
    __u16 port;
    __u8 proto;
};



<struct>

struct vip_meta {

    __u32 flags;

    __u32 vip_num;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_structs.h.out:53:56
StructStr struct vip_meta {
    __u32 flags;
    __u32 vip_num;
};



<struct>

struct real_pos_lru {

    __u32 pos;

    __u64 atime;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_structs.h.out:60:63
StructStr struct real_pos_lru {
    __u32 pos;
    __u64 atime;
};



<struct>

struct real_definition {

    union {

        __be32 dst;

        __be32 dstv6 [4];

    };

    __u8 flags;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_structs.h.out:67:73
StructStr struct real_definition {
    union {
        __be32 dst;
        __be32 dstv6 [4];
    };
    __u8 flags;
};



<struct>

struct lb_stats {

    __u64 v1;

    __u64 v2;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_structs.h.out:77:80
StructStr struct lb_stats {
    __u64 v1;
    __u64 v2;
};



<struct>

struct v4_lpm_key {

    __u32 prefixlen;

    __be32 addr;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_structs.h.out:84:87
StructStr struct v4_lpm_key {
    __u32 prefixlen;
    __be32 addr;
};



<struct>

struct v6_lpm_key {

    __u32 prefixlen;

    __be32 addr [4];

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_structs.h.out:91:94
StructStr struct v6_lpm_key {
    __u32 prefixlen;
    __be32 addr [4];
};



<struct>

struct address {

    union {

        __be32 addr;

        __be32 addrv6 [4];

    };

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_structs.h.out:98:103
StructStr struct address {
    union {
        __be32 addr;
        __be32 addrv6 [4];
    };
};

#ifdef KATRAN_INTROSPECTION



<struct>

struct event_metadata {

    __u32 event;

    __u32 pkt_size;

    __u32 data_len;

} __attribute__ ((__packed__));

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_structs.h.out:108:112
StructStr struct event_metadata {
    __u32 event;
    __u32 pkt_size;
    __u32 data_len;
} __attribute__ ((__packed__));

#endif

#ifdef RECORD_FLOW_INFO



<struct>

struct flow_debug_info {

    union {

        __be32 l4_hop;

        __be32 l4_hopv6 [4];

    };

    union {

        __be32 this_hop;

        __be32 this_hopv6 [4];

    };

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_balancer_structs.h.out:118:127
StructStr struct flow_debug_info {
    union {
        __be32 l4_hop;
        __be32 l4_hopv6 [4];
    };
    union {
        __be32 this_hop;
        __be32 this_hopv6 [4];
    };
};

#endif // of RECORD_FLOW_INFO

#endif // of _BALANCER_STRUCTS

structFIle:  ./txl_annotate/annotate_struct_test_balancer_kern.c.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_balancer_kern.c.out
string #ifdef exists in file
line Number: 47 #ifdef LPM_SRC_LOOKUP

string #ifdef exists in file
line Number: 188 #ifdef INLINE_DECAP_GENERIC

string #endif exists in file
line Number: 211 #endif // of INLINE_DECAP_GENERIC

string #ifdef exists in file
line Number: 212 #ifdef GLOBAL_LRU_LOOKUP

string #endif exists in file
line Number: 261 #endif // GLOBAL_LRU_LOOKUP

string #ifdef exists in file
line Number: 262 #ifdef INLINE_DECAP_IPIP

string #endif exists in file
line Number: 307 #endif // of INLINE_DECAP_IPIP

string #ifdef exists in file
line Number: 308 #ifdef INLINE_DECAP_GUE

string #endif exists in file
line Number: 352 #endif // of INLINE_DECAP_GUE

string #ifdef exists in file
line Number: 407 #ifdef INLINE_DECAP_IPIP

string #endif exists in file
line Number: 424 #endif // INLINE_DECAP_IPIP

string #ifdef exists in file
line Number: 434 #ifdef INLINE_DECAP_GUE

string #endif exists in file
line Number: 443 #endif // of INLINE_DECAP_GUE

string #ifdef exists in file
line Number: 469 #ifdef ICMP_TOOBIG_GENERATION

string #ifdef exists in file
line Number: 545 #ifdef TCP_SERVER_ID_ROUTING

string #endif exists in file
line Number: 559 #endif // TCP_SERVER_ID_ROUTING

string #ifdef exists in file
line Number: 563 #ifdef GLOBAL_LRU_LOOKUP

string #endif exists in file
line Number: 570 #endif // GLOBAL_LRU_LOOKUP

string #ifdef exists in file
line Number: 609 #ifdef LOCAL_DELIVERY_OPTIMIZATION

[('#ifdef ', 'INLINE_DECAP_GENERIC', 188, 210), ('#ifdef ', 'GLOBAL_LRU_LOOKUP', 212, 260), ('#ifdef ', 'INLINE_DECAP_IPIP', 262, 306), ('#ifdef ', 'INLINE_DECAP_GUE', 308, 351), ('#ifdef ', 'INLINE_DECAP_IPIP', 407, 423), ('#ifdef ', 'INLINE_DECAP_GUE', 434, 442), ('#ifdef ', 'TCP_SERVER_ID_ROUTING', 545, 558), ('#ifdef ', 'GLOBAL_LRU_LOOKUP', 563, 569)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_balancer_kern.c.out
#include <linux/in.h>

#include <linux/ip.h>

#include <linux/ipv6.h>

#include <stdbool.h>

#include <stddef.h>

#include <string.h>

#include "balancer_consts.h"

#include "balancer_helpers.h"

#include "balancer_maps.h"

#include "balancer_structs.h"

#include "bpf.h"

#include "bpf_helpers.h"

#include "handle_icmp.h"

#include "jhash.h"

#include "pckt_encap.h"

#include "pckt_parsing.h"



__attribute__ ((__always_inline__)) static inline bool is_under_flood (__u64 *cur_time) {

    __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;

    struct lb_stats *conn_rate_stats = bpf_map_lookup_elem (&stats, &conn_rate_key);

    if (!conn_rate_stats) {

        return true;

    }

    *cur_time = bpf_ktime_get_ns ();

    if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {

        conn_rate_stats->v1 = 1;

        conn_rate_stats->v2 = *cur_time;

    }

    else {

        conn_rate_stats->v1 += 1;

        if (conn_rate_stats->v1 > MAX_CONN_RATE) {

            return true;

        }

    }

    return false;

}



__attribute__ ((__always_inline__)) static inline bool get_packet_dst (struct real_definition **real, struct packet_description *pckt, struct vip_meta *vip_info, bool is_ipv6, void *lru_map) {

    struct real_pos_lru new_dst_lru = {};

    bool under_flood = false;

    bool src_found = false;

    __u32 *real_pos;

    __u64 cur_time = 0;

    __u32 hash;

    __u32 key;

    under_flood = is_under_flood (&cur_time);

#ifdef LPM_SRC_LOOKUP

    if ((vip_info->flags & F_SRC_ROUTING) && !under_flood) {

        __u32 *lpm_val;

        if (is_ipv6) {

            struct v6_lpm_key lpm_key_v6 = {};

            lpm_key_v6.prefixlen = 128;

            memcpy (lpm_key_v6.addr, pckt -> flow.srcv6, 16);

            lpm_val = bpf_map_lookup_elem (&lpm_src_v6, &lpm_key_v6);

        }

        else {

            struct v4_lpm_key lpm_key_v4 = {};

            lpm_key_v4.addr = pckt->flow.src;

            lpm_key_v4.prefixlen = 32;

            lpm_val = bpf_map_lookup_elem (&lpm_src_v4, &lpm_key_v4);

        }

        if (lpm_val) {

            src_found = true;

            key = *lpm_val;

        }

        __u32 stats_key = MAX_VIPS + LPM_SRC_CNTRS;

        struct lb_stats *data_stats = bpf_map_lookup_elem (&stats, &stats_key);

        if (data_stats) {

            if (src_found) {

                data_stats->v2 += 1;

            }

            else {

                data_stats->v1 += 1;

            }

        }

    }

#endif

    if (!src_found) {

        bool hash_16bytes = is_ipv6;

        if (vip_info->flags & F_HASH_DPORT_ONLY) {

            pckt->flow.port16[0] = pckt->flow.port16[1];

            memset (pckt -> flow.srcv6, 0, 16);

        }

        hash = get_packet_hash (pckt, hash_16bytes) % RING_SIZE;

        key = RING_SIZE * (vip_info->vip_num) + hash;

        real_pos = bpf_map_lookup_elem (&ch_rings, &key);

        if (!real_pos) {

            return false;

        }

        key = *real_pos;

    }

    pckt->real_index = key;

    *real = bpf_map_lookup_elem (&reals, &key);

    if (!(*real)) {

        return false;

    }

    if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {

        if (pckt->flow.proto == IPPROTO_UDP) {

            new_dst_lru.atime = cur_time;

        }

        new_dst_lru.pos = key;

        bpf_map_update_elem (lru_map, & pckt -> flow, & new_dst_lru, BPF_ANY);

    }

    return true;

}



__attribute__ ((__always_inline__)) static inline void connection_table_lookup (struct real_definition **real, struct packet_description *pckt, void *lru_map, bool isGlobalLru) {

    struct real_pos_lru *dst_lru;

    __u64 cur_time;

    __u32 key;

    dst_lru = bpf_map_lookup_elem (lru_map, &pckt->flow);

    if (!dst_lru) {

        return;

    }

    if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {

        cur_time = bpf_ktime_get_ns ();

        if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {

            return;

        }

        dst_lru->atime = cur_time;

    }

    key = dst_lru->pos;

    pckt->real_index = key;

    *real = bpf_map_lookup_elem (&reals, &key);

    return;

}



__attribute__ ((__always_inline__)) static inline int process_l3_headers (struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes, void *data, void *data_end, bool is_ipv6) {

    __u64 iph_len;

    int action;

    struct iphdr *iph;

    struct ipv6hdr *ip6h;

    if (is_ipv6) {

        ip6h = data + off;

        if (ip6h + 1 > data_end) {

            return XDP_DROP;

        }

        iph_len = sizeof (struct ipv6hdr);

        *protocol = ip6h->nexthdr;

        pckt->flow.proto = *protocol;

        pckt->tos = (ip6h->priority << 4) & 0xF0;

        pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);

        *pkt_bytes = bpf_ntohs (ip6h->payload_len);

        off += iph_len;

        if (*protocol == IPPROTO_FRAGMENT) {

            return XDP_DROP;

        }

        else if (*protocol == IPPROTO_ICMPV6) {

            action = parse_icmpv6 (data, data_end, off, pckt);

            if (action >= 0) {

                return action;

            }

        }

        else {

            memcpy (pckt -> flow.srcv6, ip6h -> saddr.s6_addr32, 16);

            memcpy (pckt -> flow.dstv6, ip6h -> daddr.s6_addr32, 16);

        }

    }

    else {

        iph = data + off;

        if (iph + 1 > data_end) {

            return XDP_DROP;

        }

        if (iph->ihl != 5) {

            return XDP_DROP;

        }

        pckt->tos = iph->tos;

        *protocol = iph->protocol;

        pckt->flow.proto = *protocol;

        *pkt_bytes = bpf_ntohs (iph->tot_len);

        off += IPV4_HDR_LEN_NO_OPT;

        if (iph->frag_off & PCKT_FRAGMENTED) {

            return XDP_DROP;

        }

        if (*protocol == IPPROTO_ICMP) {

            action = parse_icmp (data, data_end, off, pckt);

            if (action >= 0) {

                return action;

            }

        }

        else {

            pckt->flow.src = iph->saddr;

            pckt->flow.dst = iph->daddr;

        }

    }

    return FURTHER_PROCESSING;

}

#ifdef INLINE_DECAP_GENERIC



__attribute__ ((__always_inline__)) static inline int check_decap_dst (struct packet_description *pckt, bool is_ipv6, bool *pass) {

    struct address dst_addr = {};

    struct lb_stats *data_stats;

    if (is_ipv6) {

        memcpy (dst_addr.addrv6, pckt -> flow.dstv6, 16);

    }

    else {

        dst_addr.addr = pckt->flow.dst;

    }

    __u32 *decap_dst_flags = bpf_map_lookup_elem (&decap_dst, &dst_addr);

    if (decap_dst_flags) {

        *pass = false;

        __u32 stats_key = MAX_VIPS + REMOTE_ENCAP_CNTRS;

        data_stats = bpf_map_lookup_elem (&stats, &stats_key);

        if (!data_stats) {

            return XDP_DROP;

        }

        data_stats->v1 += 1;

    }

    return FURTHER_PROCESSING;

}

#endif // of INLINE_DECAP_GENERIC

#ifdef GLOBAL_LRU_LOOKUP



__attribute__ ((__always_inline__)) static inline bool reals_have_same_addr (struct real_definition *a, struct real_definition *b) {

    if (a->flags != b->flags) {

        return false;

    }

    if (a->flags & F_IPV6) {

        for (int i = 0; i < 4; i++) {

            if (a->dstv6[i] != b->dstv6[i]) {

                return false;

            }

            return true;

        }

    }

    else {

        return a->dst == b->dst;

    }

}



__attribute__ ((__always_inline__)) static inline int perform_global_lru_lookup (struct real_definition **dst, struct packet_description *pckt, __u32 cpu_num, struct vip_meta *vip_info, bool is_ipv6) {

    void *g_lru_map = bpf_map_lookup_elem (&global_lru_maps, &cpu_num);

    __u32 global_lru_stats_key = MAX_VIPS + GLOBAL_LRU_CNTR;

    struct lb_stats *global_lru_stats = bpf_map_lookup_elem (&stats, &global_lru_stats_key);

    if (!global_lru_stats) {

        return XDP_DROP;

    }

    if (!g_lru_map) {

        global_lru_stats->v1 += 1;

        g_lru_map = &fallback_glru;

    }

    connection_table_lookup (dst, pckt, g_lru_map, true);

    if (*dst) {

        global_lru_stats->v2 += 1;

        struct real_definition *dst_consistent_hash = NULL;

        if (get_packet_dst (&dst_consistent_hash, pckt, vip_info, is_ipv6, NULL)) {

            __u32 global_lru_mismatch_stats_key = MAX_VIPS + GLOBAL_LRU_MISMATCH_CNTR;

            struct lb_stats *global_lru_mismatch_stats = bpf_map_lookup_elem (&stats, &global_lru_mismatch_stats_key);

            if (dst_consistent_hash && global_lru_mismatch_stats) {

                if (reals_have_same_addr (dst_consistent_hash, *dst)) {

                    global_lru_mismatch_stats->v1++;

                }

                else {

                    global_lru_mismatch_stats->v2++;

                }

            }

        }

    }

    return FURTHER_PROCESSING;

}

#endif // GLOBAL_LRU_LOOKUP

#ifdef INLINE_DECAP_IPIP



__attribute__ ((__always_inline__)) static inline int process_encaped_ipip_pckt (void **data, void **data_end, struct xdp_md *xdp, bool *is_ipv6, __u8 *protocol, bool pass) {

    int action;

    if (*protocol == IPPROTO_IPIP) {

        if (*is_ipv6) {

            int offset = sizeof (struct ipv6hdr) + sizeof (struct ethhdr);

            if ((*data + offset) > *data_end) {

                return XDP_DROP;

            }

            action = decrement_ttl (*data, *data_end, offset, false);

            if (!decap_v6 (xdp, data, data_end, true)) {

                return XDP_DROP;

            }

            *is_ipv6 = false;

        }

        else {

            int offset = sizeof (struct iphdr) + sizeof (struct ethhdr);

            if ((*data + offset) > *data_end) {

                return XDP_DROP;

            }

            action = decrement_ttl (*data, *data_end, offset, false);

            if (!decap_v4 (xdp, data, data_end)) {

                return XDP_DROP;

            }

        }

    }

    else if (*protocol == IPPROTO_IPV6) {

        int offset = sizeof (struct ipv6hdr) + sizeof (struct ethhdr);

        if ((*data + offset) > *data_end) {

            return XDP_DROP;

        }

        action = decrement_ttl (*data, *data_end, offset, true);

        if (!decap_v6 (xdp, data, data_end, false)) {

            return XDP_DROP;

        }

    }

    if (action >= 0) {

        return action;

    }

    if (pass) {

        return XDP_PASS;

    }

    return recirculate (xdp);

}

#endif // of INLINE_DECAP_IPIP

#ifdef INLINE_DECAP_GUE



__attribute__ ((__always_inline__)) static inline int process_encaped_gue_pckt (void **data, void **data_end, struct xdp_md *xdp, bool is_ipv6, bool pass) {

    int offset = 0;

    int action;

    if (is_ipv6) {

        __u8 v6 = 0;

        offset = sizeof (struct ipv6hdr) + sizeof (struct ethhdr) + sizeof (struct udphdr);

        if ((*data + offset + 1) > *data_end) {

            return XDP_DROP;

        }

        v6 = ((__u8 *) (*data))[offset];

        v6 &= GUEV1_IPV6MASK;

        if (v6) {

            action = decrement_ttl (*data, *data_end, offset, true);

            if (!gue_decap_v6 (xdp, data, data_end, false)) {

                return XDP_DROP;

            }

        }

        else {

            action = decrement_ttl (*data, *data_end, offset, false);

            if (!gue_decap_v6 (xdp, data, data_end, true)) {

                return XDP_DROP;

            }

        }

    }

    else {

        offset = sizeof (struct iphdr) + sizeof (struct ethhdr) + sizeof (struct udphdr);

        if ((*data + offset) > *data_end) {

            return XDP_DROP;

        }

        action = decrement_ttl (*data, *data_end, offset, false);

        if (!gue_decap_v4 (xdp, data, data_end)) {

            return XDP_DROP;

        }

    }

    if (action >= 0) {

        return action;

    }

    if (pass) {

        return XDP_PASS;

    }

    return recirculate (xdp);

}

#endif // of INLINE_DECAP_GUE



__attribute__ ((__always_inline__)) static inline void increment_quic_cid_version_stats (int host_id) {

    __u32 quic_version_stats_key = MAX_VIPS + QUIC_CID_VERSION_STATS;

    struct lb_stats *quic_version = bpf_map_lookup_elem (&stats, &quic_version_stats_key);

    if (!quic_version) {

        return;

    }

    if (host_id > QUIC_CONNID_VERSION_V1_MAX_VAL) {

        quic_version->v2 += 1;

    }

    else {

        quic_version->v1 += 1;

    }

}



__attribute__ ((__always_inline__)) static inline void increment_quic_cid_drop_no_real () {

    __u32 quic_drop_stats_key = MAX_VIPS + QUIC_CID_DROP_STATS;

    struct lb_stats *quic_drop = bpf_map_lookup_elem (&stats, &quic_drop_stats_key);

    if (!quic_drop) {

        return;

    }

    quic_drop->v1 += 1;

}



__attribute__ ((__always_inline__)) static inline void increment_quic_cid_drop_real_0 () {

    __u32 quic_drop_stats_key = MAX_VIPS + QUIC_CID_DROP_STATS;

    struct lb_stats *quic_drop = bpf_map_lookup_elem (&stats, &quic_drop_stats_key);

    if (!quic_drop) {

        return;

    }

    quic_drop->v2 += 1;

}



__attribute__ ((__always_inline__)) static inline int process_packet (struct xdp_md *xdp, __u64 off, bool is_ipv6) {

    void *data = (void *) (long) xdp->data;

    void *data_end = (void *) (long) xdp->data_end;

    struct ctl_value *cval;

    struct real_definition *dst = NULL;

    struct packet_description pckt = {};

    struct vip_definition vip = {};

    struct vip_meta *vip_info;

    struct lb_stats *data_stats;

    __u64 iph_len;

    __u8 protocol;

    __u16 original_sport;

    int action;

    __u32 vip_num;

    __u32 mac_addr_pos = 0;

    __u16 pkt_bytes;

    action = process_l3_headers (&pckt, &protocol, off, &pkt_bytes, data, data_end, is_ipv6);

    if (action >= 0) {

        return action;

    }

    protocol = pckt.flow.proto;

#ifdef INLINE_DECAP_IPIP

    if (protocol == IPPROTO_IPIP) {

        bool pass = true;

        action = check_decap_dst (&pckt, is_ipv6, &pass);

        if (action >= 0) {

            return action;

        }

        return process_encaped_ipip_pckt (&data, &data_end, xdp, &is_ipv6, &protocol, pass);

    }

    else if (protocol == IPPROTO_IPV6) {

        bool pass = true;

        action = check_decap_dst (&pckt, is_ipv6, &pass);

        if (action >= 0) {

            return action;

        }

        return process_encaped_ipip_pckt (&data, &data_end, xdp, &is_ipv6, &protocol, pass);

    }

#endif // INLINE_DECAP_IPIP

    if (protocol == IPPROTO_TCP) {

        if (!parse_tcp (data, data_end, is_ipv6, &pckt)) {

            return XDP_DROP;

        }

    }

    else if (protocol == IPPROTO_UDP) {

        if (!parse_udp (data, data_end, is_ipv6, &pckt)) {

            return XDP_DROP;

        }

#ifdef INLINE_DECAP_GUE

        if (pckt.flow.port16[1] == bpf_htons (GUE_DPORT)) {

            bool pass = true;

            action = check_decap_dst (&pckt, is_ipv6, &pass);

            if (action >= 0) {

                return action;

            }

            return process_encaped_gue_pckt (&data, &data_end, xdp, is_ipv6, pass);

        }

#endif // of INLINE_DECAP_GUE

    }

    else {

        return XDP_PASS;

    }

    if (is_ipv6) {

        memcpy (vip.vipv6, pckt.flow.dstv6, 16);

    }

    else {

        vip.vip = pckt.flow.dst;

    }

    vip.port = pckt.flow.port16[1];

    vip.proto = pckt.flow.proto;

    vip_info = bpf_map_lookup_elem (&vip_map, &vip);

    if (!vip_info) {

        vip.port = 0;

        vip_info = bpf_map_lookup_elem (&vip_map, &vip);

        if (!vip_info) {

            return XDP_PASS;

        }

        if (!(vip_info->flags & F_HASH_DPORT_ONLY)) {

            pckt.flow.port16[1] = 0;

        }

    }

    if (data_end - data > MAX_PCKT_SIZE) {

        REPORT_PACKET_TOOBIG (xdp, data, data_end - data, false);

#ifdef ICMP_TOOBIG_GENERATION

        __u32 stats_key = MAX_VIPS + ICMP_TOOBIG_CNTRS;

        data_stats = bpf_map_lookup_elem (&stats, &stats_key);

        if (!data_stats) {

            return XDP_DROP;

        }

        if (is_ipv6) {

            data_stats->v2 += 1;

        }

        else {

            data_stats->v1 += 1;

        }

        return send_icmp_too_big (xdp, is_ipv6, data_end -data);

#else

        return XDP_DROP;

#endif

    }

    __u32 stats_key = MAX_VIPS + LRU_CNTRS;

    data_stats = bpf_map_lookup_elem (&stats, &stats_key);

    if (!data_stats) {

        return XDP_DROP;

    }

    data_stats->v1 += 1;

    if ((vip_info->flags & F_QUIC_VIP)) {

        __u32 quic_stats_key = MAX_VIPS + QUIC_ROUTE_STATS;

        struct lb_stats *quic_stats = bpf_map_lookup_elem (&stats, &quic_stats_key);

        if (!quic_stats) {

            return XDP_DROP;

        }

        int real_index;

        real_index = parse_quic (data, data_end, is_ipv6, &pckt);

        if (real_index > 0) {

            increment_quic_cid_version_stats (real_index);

            __u32 key = real_index;

            __u32 *real_pos = bpf_map_lookup_elem (&server_id_map, &key);

            if (real_pos) {

                key = *real_pos;

                if (key == 0) {

                    increment_quic_cid_drop_real_0 ();

                    quic_stats->v1 += 1;

                }

                else {

                    pckt.real_index = key;

                    dst = bpf_map_lookup_elem (&reals, &key);

                    if (!dst) {

                        increment_quic_cid_drop_no_real ();

                        REPORT_QUIC_PACKET_DROP_NO_REAL (xdp, data, data_end - data, false);

                        return XDP_DROP;

                    }

                    quic_stats->v2 += 1;

                }

            }

            else {

                quic_stats->v1 += 1;

            }

        }

        else {

            quic_stats->v1 += 1;

        }

    }

    original_sport = pckt.flow.port16[0];

    if (!dst) {

        if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {

            pckt.flow.port16[0] = 0;

        }

        __u32 cpu_num = bpf_get_smp_processor_id ();

        void *lru_map = bpf_map_lookup_elem (&lru_mapping, &cpu_num);

        if (!lru_map) {

            lru_map = &fallback_cache;

            __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;

            struct lb_stats *lru_stats = bpf_map_lookup_elem (&stats, &lru_stats_key);

            if (!lru_stats) {

                return XDP_DROP;

            }

            lru_stats->v1 += 1;

        }

#ifdef TCP_SERVER_ID_ROUTING

        if (pckt.flow.proto == IPPROTO_TCP && !(pckt.flags & F_SYN_SET)) {

            __u32 routing_stats_key = MAX_VIPS + TCP_SERVER_ID_ROUTE_STATS;

            struct lb_stats *routing_stats = bpf_map_lookup_elem (&stats, &routing_stats_key);

            if (!routing_stats) {

                return XDP_DROP;

            }

            if (tcp_hdr_opt_lookup (xdp, is_ipv6, &dst, &pckt, vip_info->flags & F_LRU_BYPASS, lru_map) == FURTHER_PROCESSING) {

                routing_stats->v1 += 1;

            }

            else {

                routing_stats->v2 += 1;

            }

        }

#endif // TCP_SERVER_ID_ROUTING

        if (!dst && !(pckt.flags & F_SYN_SET) && !(vip_info->flags & F_LRU_BYPASS)) {

            connection_table_lookup (& dst, & pckt, lru_map, false);

        }

#ifdef GLOBAL_LRU_LOOKUP

        if (!dst && !(pckt.flags & F_SYN_SET) && vip_info->flags & F_GLOBAL_LRU) {

            int global_lru_lookup_result = perform_global_lru_lookup (&dst, &pckt, cpu_num, vip_info, is_ipv6);

            if (global_lru_lookup_result >= 0) {

                return global_lru_lookup_result;

            }

        }

#endif // GLOBAL_LRU_LOOKUP

        if (!dst) {

            if (pckt.flow.proto == IPPROTO_TCP) {

                __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;

                struct lb_stats *lru_stats = bpf_map_lookup_elem (&stats, &lru_stats_key);

                if (!lru_stats) {

                    return XDP_DROP;

                }

                if (pckt.flags & F_SYN_SET) {

                    lru_stats->v1 += 1;

                }

                else {

                    REPORT_TCP_NONSYN_LRUMISS (xdp, data, data_end - data, false);

                    lru_stats->v2 += 1;

                }

            }

            if (!get_packet_dst (&dst, &pckt, vip_info, is_ipv6, lru_map)) {

                return XDP_DROP;

            }

            data_stats->v2 += 1;

        }

    }

    cval = bpf_map_lookup_elem (&ctl_array, &mac_addr_pos);

    if (!cval) {

        return XDP_DROP;

    }

    vip_num = vip_info->vip_num;

    data_stats = bpf_map_lookup_elem (&stats, &vip_num);

    if (!data_stats) {

        return XDP_DROP;

    }

    data_stats->v1 += 1;

    data_stats->v2 += pkt_bytes;

    data_stats = bpf_map_lookup_elem (&reals_stats, &pckt.real_index);

    if (!data_stats) {

        return XDP_DROP;

    }

    data_stats->v1 += 1;

    data_stats->v2 += pkt_bytes;

#ifdef LOCAL_DELIVERY_OPTIMIZATION

    if ((vip_info->flags & F_LOCAL_VIP) && (dst->flags & F_LOCAL_REAL)) {

        return XDP_PASS;

    }

#endif

    pckt.flow.port16[0] = original_sport;

    if (dst->flags & F_IPV6) {

        if (!PCKT_ENCAP_V6 (xdp, cval, is_ipv6, &pckt, dst, pkt_bytes)) {

            return XDP_DROP;

        }

    }

    else {

        if (!PCKT_ENCAP_V4 (xdp, cval, &pckt, dst, pkt_bytes)) {

            return XDP_DROP;

        }

    }

    return XDP_TX;

}



SEC ("xdp")

int balancer_ingress (struct xdp_md *ctx) {

    void *data = (void *) (long) ctx->data;

    void *data_end = (void *) (long) ctx->data_end;

    struct ethhdr *eth = data;

    __u32 eth_proto;

    __u32 nh_off;

    nh_off = sizeof (struct ethhdr);

    if (data + nh_off > data_end) {

        return XDP_DROP;

    }

    eth_proto = eth->h_proto;

    if (eth_proto == BE_ETH_P_IP) {

        return process_packet (ctx, nh_off, false);

    }

    else if (eth_proto == BE_ETH_P_IPV6) {

        return process_packet (ctx, nh_off, true);

    }

    else {

        return XDP_PASS;

    }

}



__attribute__ ((__always_inline__)) static inline __u32 get_packet_hash (struct packet_description *pckt, bool hash_16bytes) {

    if (hash_16bytes) {

        return jhash_2words (jhash (pckt->flow.srcv6, 16, INIT_JHASH_SEED_V6), pckt->flow.ports, INIT_JHASH_SEED);

    }

    else {

        return jhash_2words (pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);

    }

}



char _license [] SEC ("license") = "GPL";

structFIle:  ./txl_annotate/annotate_struct_test_csum_helpers.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_csum_helpers.h.out
string #ifndef exists in file
line Number: 1 #ifndef __CSUM_HELPERS_H

string #ifdef exists in file
line Number: 63 #ifdef GUE_ENCAP

string #endif exists in file
line Number: 270 #endif // of GUE_ENCAP

string #endif exists in file
line Number: 271 #endif // of __CSUM_HELPERS_H

[('#ifdef ', 'GUE_ENCAP', 63, 269), ('#ifndef ', '__CSUM_HELPERS_H', 1, 270)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_csum_helpers.h.out
#ifndef __CSUM_HELPERS_H

#define __CSUM_HELPERS_H

#include <linux/in.h>

#include <linux/ip.h>

#include <linux/ipv6.h>

#include <linux/udp.h>

#include <stdbool.h>

#include "bpf.h"

#include "bpf_endian.h"

#include "bpf_helpers.h"



__attribute__ ((__always_inline__)) static inline __u16 csum_fold_helper (__u64 csum) {

    int i;

#pragma unroll

    for (i = 0; i < 4; i++) {

        if (csum >> 16)

            csum = (csum & 0xffff) + (csum >> 16);

    }

    return ~csum;

}



__attribute__ ((__always_inline__)) static int min_helper (int a, int b) {

    return a < b ? a : b;

}



__attribute__ ((__always_inline__)) static inline void ipv4_csum (void *data_start, int data_size, __u64 *csum) {

    *csum = bpf_csum_diff (0, 0, data_start, data_size, *csum);

    *csum = csum_fold_helper (*csum);

}



__attribute__ ((__always_inline__)) static inline void ipv4_csum_inline (void *iph, __u64 *csum) {

    __u16 *next_iph_u16 = (__u16 *) iph;

#pragma clang loop unroll(full)

    for (int i = 0; i < sizeof (struct iphdr) >> 1; i++) {

        *csum += *next_iph_u16++;

    }

    *csum = csum_fold_helper (*csum);

}



__attribute__ ((__always_inline__)) static inline void ipv4_l4_csum (void *data_start, int data_size, __u64 *csum, struct iphdr *iph) {

    __u32 tmp = 0;

    *csum = bpf_csum_diff (0, 0, &iph->saddr, sizeof (__be32), *csum);

    *csum = bpf_csum_diff (0, 0, &iph->daddr, sizeof (__be32), *csum);

    tmp = __builtin_bswap32 ((__u32) (iph->protocol));

    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);

    tmp = __builtin_bswap32 ((__u32) (data_size));

    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);

    *csum = bpf_csum_diff (0, 0, data_start, data_size, *csum);

    *csum = csum_fold_helper (*csum);

}



__attribute__ ((__always_inline__)) static inline void ipv6_csum (void *data_start, int data_size, __u64 *csum, struct ipv6hdr *ip6h) {

    __u32 tmp = 0;

    *csum = bpf_csum_diff (0, 0, &ip6h->saddr, sizeof (struct in6_addr), *csum);

    *csum = bpf_csum_diff (0, 0, &ip6h->daddr, sizeof (struct in6_addr), *csum);

    tmp = __builtin_bswap32 ((__u32) (data_size));

    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);

    tmp = __builtin_bswap32 ((__u32) (ip6h->nexthdr));

    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);

    *csum = bpf_csum_diff (0, 0, data_start, data_size, *csum);

    *csum = csum_fold_helper (*csum);

}

#ifdef GUE_ENCAP



__attribute__ ((__always_inline__)) static inline __s64 add_pseudo_ipv6_header (struct ipv6hdr *ip6h, __u64 *csum) {

    __s64 ret;

    __u32 tmp = 0;

    ret = bpf_csum_diff (0, 0, &ip6h->saddr, sizeof (struct in6_addr), *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    ret = bpf_csum_diff (0, 0, &ip6h->daddr, sizeof (struct in6_addr), *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    tmp = (__u32) bpf_ntohs (ip6h->payload_len);

    tmp = bpf_htonl (tmp);

    ret = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    tmp = __builtin_bswap32 ((__u32) (ip6h->nexthdr));

    ret = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    return 0;

}



__attribute__ ((__always_inline__)) static inline __s64 rem_pseudo_ipv6_header (struct ipv6hdr *ip6h, __u64 *csum) {

    __s64 ret;

    __u32 tmp = 0;

    ret = bpf_csum_diff (&ip6h->saddr, sizeof (struct in6_addr), 0, 0, *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    ret = bpf_csum_diff (&ip6h->daddr, sizeof (struct in6_addr), 0, 0, *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    tmp = (__u32) bpf_ntohs (ip6h->payload_len);

    tmp = bpf_htonl (tmp);

    ret = bpf_csum_diff (&tmp, sizeof (__u32), 0, 0, *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    tmp = __builtin_bswap32 ((__u32) (ip6h->nexthdr));

    ret = bpf_csum_diff (&tmp, sizeof (__u32), 0, 0, *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    return 0;

}



__attribute__ ((__always_inline__)) static inline __s64 add_pseudo_ipv4_header (struct iphdr *iph, __u64 *csum) {

    __s64 ret;

    __u32 tmp = 0;

    ret = bpf_csum_diff (0, 0, &iph->saddr, sizeof (__be32), *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    ret = bpf_csum_diff (0, 0, &iph->daddr, sizeof (__be32), *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    tmp = (__u32) bpf_ntohs (iph->tot_len) - sizeof (struct iphdr);

    tmp = bpf_htonl (tmp);

    ret = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    tmp = __builtin_bswap32 ((__u32) (iph->protocol));

    ret = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    return 0;

}



__attribute__ ((__always_inline__)) static inline __s64 rem_pseudo_ipv4_header (struct iphdr *iph, __u64 *csum) {

    __s64 ret;

    __u32 tmp = 0;

    ret = bpf_csum_diff (&iph->saddr, sizeof (__be32), 0, 0, *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    ret = bpf_csum_diff (&iph->daddr, sizeof (__be32), 0, 0, *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    tmp = (__u32) bpf_ntohs (iph->tot_len) - sizeof (struct iphdr);

    tmp = bpf_htonl (tmp);

    ret = bpf_csum_diff (&tmp, sizeof (__u32), 0, 0, *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    tmp = __builtin_bswap32 ((__u32) (iph->protocol));

    ret = bpf_csum_diff (&tmp, sizeof (__u32), 0, 0, *csum);

    if (ret < 0) {

        return ret;

    }

    *csum = ret;

    return 0;

}



__attribute__ ((__always_inline__)) static inline bool gue_csum_v6 (struct ipv6hdr *outer_ip6h, struct udphdr *udph, struct ipv6hdr *inner_ip6h, __u64 *csum_in_hdr) {

    __s64 ret;

    __u32 tmp = 0;

    __u32 seed = (~(*csum_in_hdr)) & 0xffff;

    __u32 orig_csum = (__u32) *csum_in_hdr;

    ret = bpf_csum_diff (0, 0, &orig_csum, sizeof (__u32), seed);

    if (ret < 0) {

        return false;

    }

    *csum_in_hdr = ret;

    if (rem_pseudo_ipv6_header (inner_ip6h, csum_in_hdr) < 0) {

        return false;

    }

    ret = bpf_csum_diff (0, 0, inner_ip6h, sizeof (struct ipv6hdr), *csum_in_hdr);

    if (ret < 0) {

        return false;

    }

    *csum_in_hdr = ret;

    ret = bpf_csum_diff (0, 0, udph, sizeof (struct udphdr), *csum_in_hdr);

    if (ret < 0) {

        return false;

    }

    *csum_in_hdr = ret;

    if (add_pseudo_ipv6_header (outer_ip6h, csum_in_hdr) < 0) {

        return false;

    }

    *csum_in_hdr = csum_fold_helper (*csum_in_hdr);

    return true;

}



__attribute__ ((__always_inline__)) static inline bool gue_csum_v4 (struct iphdr *outer_iph, struct udphdr *udph, struct iphdr *inner_iph, __u64 *csum_in_hdr) {

    __s64 ret;

    __u32 tmp = 0;

    __u32 seed = (~(*csum_in_hdr)) & 0xffff;

    __u32 orig_csum = (__u32) *csum_in_hdr;

    ret = bpf_csum_diff (0, 0, &orig_csum, sizeof (__u32), seed);

    if (ret < 0) {

        return false;

    }

    *csum_in_hdr = ret;

    if (rem_pseudo_ipv4_header (inner_iph, csum_in_hdr) < 0) {

        return false;

    }

    ret = bpf_csum_diff (0, 0, inner_iph, sizeof (struct iphdr), *csum_in_hdr);

    if (ret < 0) {

        return false;

    }

    *csum_in_hdr = ret;

    ret = bpf_csum_diff (0, 0, udph, sizeof (struct udphdr), *csum_in_hdr);

    if (ret < 0) {

        return false;

    }

    *csum_in_hdr = ret;

    if (add_pseudo_ipv4_header (outer_iph, csum_in_hdr) < 0) {

        return false;

    }

    *csum_in_hdr = csum_fold_helper (*csum_in_hdr);

    return true;

}



__attribute__ ((__always_inline__)) static inline bool gue_csum_v4_in_v6 (struct ipv6hdr *outer_ip6h, struct udphdr *udph, struct iphdr *inner_iph, __u64 *csum_in_hdr) {

    __s64 ret;

    __u32 tmp = 0;

    __u32 seed = (~(*csum_in_hdr)) & 0xffff;

    __u32 orig_csum = (__u32) *csum_in_hdr;

    ret = bpf_csum_diff (0, 0, &orig_csum, sizeof (__u32), seed);

    if (ret < 0) {

        return false;

    }

    *csum_in_hdr = ret;

    if (rem_pseudo_ipv4_header (inner_iph, csum_in_hdr) < 0) {

        return false;

    }

    ret = bpf_csum_diff (0, 0, inner_iph, sizeof (struct iphdr), *csum_in_hdr);

    if (ret < 0) {

        return false;

    }

    *csum_in_hdr = ret;

    ret = bpf_csum_diff (0, 0, udph, sizeof (struct udphdr), *csum_in_hdr);

    if (ret < 0) {

        return false;

    }

    *csum_in_hdr = ret;

    if (add_pseudo_ipv6_header (outer_ip6h, csum_in_hdr) < 0) {

        return false;

    }

    *csum_in_hdr = csum_fold_helper (*csum_in_hdr);

    return true;

}

#endif // of GUE_ENCAP

#endif // of __CSUM_HELPERS_H



structFIle:  ./txl_annotate/annotate_struct_test_control_data_maps.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_control_data_maps.h.out
string #ifndef exists in file
line Number: 1 #ifndef __CONTROL_DATA_MAPS_H

string #ifdef exists in file
line Number: 17 #ifdef KATRAN_INTROSPECTION

string #ifdef exists in file
line Number: 29 #ifdef INLINE_DECAP_GENERIC

string #ifdef exists in file
line Number: 50 #ifdef GUE_ENCAP

string #endif exists in file
line Number: 62 #endif // of __CONTROL_DATA_MAPS_H

[('#ifdef ', 'GUE_ENCAP', 50, 61)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_control_data_maps.h.out
#ifndef __CONTROL_DATA_MAPS_H

#define __CONTROL_DATA_MAPS_H

#include "bpf.h"

#include "bpf_helpers.h"

#include "balancer_consts.h"

#include "balancer_structs.h"



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_ARRAY);

    __type (key, __u32);

    __type (value, struct ctl_value);

    __uint (max_entries, CTL_MAP_SIZE);

    __uint (map_flags, NO_FLAGS);

} ctl_array SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_control_data_maps.h.out:9:15
StructStr struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, struct ctl_value);
    __uint (max_entries, CTL_MAP_SIZE);
    __uint (map_flags, NO_FLAGS);
} ctl_array SEC (".maps");

#ifdef KATRAN_INTROSPECTION



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);

    __type (key, int);

    __type (value, __u32);

    __uint (max_entries, MAX_SUPPORTED_CPUS);

    __uint (map_flags, NO_FLAGS);

} event_pipe SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_control_data_maps.h.out:20:26
StructStr struct {
    __uint (type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
    __type (key, int);
    __type (value, __u32);
    __uint (max_entries, MAX_SUPPORTED_CPUS);
    __uint (map_flags, NO_FLAGS);
} event_pipe SEC (".maps");

#endif

#ifdef INLINE_DECAP_GENERIC



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_HASH);

    __type (key, struct address);

    __type (value, __u32);

    __uint (max_entries, MAX_VIPS);

    __uint (map_flags, NO_FLAGS);

} decap_dst SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_control_data_maps.h.out:32:38
StructStr struct {
    __uint (type, BPF_MAP_TYPE_HASH);
    __type (key, struct address);
    __type (value, __u32);
    __uint (max_entries, MAX_VIPS);
    __uint (map_flags, NO_FLAGS);
} decap_dst SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_PROG_ARRAY);

    __type (key, __u32);

    __type (value, __u32);

    __uint (max_entries, SUBPROGRAMS_ARRAY_SIZE);

} subprograms SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_control_data_maps.h.out:42:47
StructStr struct {
    __uint (type, BPF_MAP_TYPE_PROG_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, SUBPROGRAMS_ARRAY_SIZE);
} subprograms SEC (".maps");

#endif

#ifdef GUE_ENCAP



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_ARRAY);

    __type (key, __u32);

    __type (value, struct real_definition);

    __uint (max_entries, 2);

    __uint (map_flags, NO_FLAGS);

} pckt_srcs SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_control_data_maps.h.out:53:59
StructStr struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, struct real_definition);
    __uint (max_entries, 2);
    __uint (map_flags, NO_FLAGS);
} pckt_srcs SEC (".maps");

#endif

#endif // of __CONTROL_DATA_MAPS_H

structFIle:  ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out
string #ifndef exists in file
line Number: 1 #ifndef __HEALTHCHECKING_MAPS_H

string #endif exists in file
line Number: 76 #endif // of __HEALTHCHECKING_MAPS_H

[('#ifndef ', '__HEALTHCHECKING_MAPS_H', 1, 75)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out
#ifndef __HEALTHCHECKING_MAPS_H

#define __HEALTHCHECKING_MAPS_H

#include "bpf.h"

#include "bpf_helpers.h"

#include "balancer_consts.h"

#include "healthchecking_consts.h"

#include "healthchecking_structs.h"



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_ARRAY);

    __type (key, __u32);

    __type (value, __u32);

    __uint (max_entries, CTRL_MAP_SIZE);

} hc_ctrl_map SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out:10:15
StructStr struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, CTRL_MAP_SIZE);
} hc_ctrl_map SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_HASH);

    __type (key, __u32);

    __type (value, struct hc_real_definition);

    __uint (max_entries, MAX_REALS);

} hc_reals_map SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out:19:24
StructStr struct {
    __uint (type, BPF_MAP_TYPE_HASH);
    __type (key, __u32);
    __type (value, struct hc_real_definition);
    __uint (max_entries, MAX_REALS);
} hc_reals_map SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_ARRAY);

    __type (key, __u32);

    __type (value, struct hc_real_definition);

    __uint (max_entries, 2);

    __uint (map_flags, NO_FLAGS);

} hc_pckt_srcs_map SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out:28:34
StructStr struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, struct hc_real_definition);
    __uint (max_entries, 2);
    __uint (map_flags, NO_FLAGS);
} hc_pckt_srcs_map SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_ARRAY);

    __type (key, __u32);

    __type (value, struct hc_mac);

    __uint (max_entries, 2);

    __uint (map_flags, NO_FLAGS);

} hc_pckt_macs SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out:38:44
StructStr struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, struct hc_mac);
    __uint (max_entries, 2);
    __uint (map_flags, NO_FLAGS);
} hc_pckt_macs SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);

    __type (key, __u32);

    __type (value, struct hc_stats);

    __uint (max_entries, STATS_SIZE);

    __uint (map_flags, NO_FLAGS);

} hc_stats_map SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out:48:54
StructStr struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, struct hc_stats);
    __uint (max_entries, STATS_SIZE);
    __uint (map_flags, NO_FLAGS);
} hc_stats_map SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);

    __type (key, __u32);

    __type (value, __u64);

    __uint (max_entries, MAX_VIPS);

    __uint (map_flags, NO_FLAGS);

} per_hckey_stats SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out:58:64
StructStr struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, __u64);
    __uint (max_entries, MAX_VIPS);
    __uint (map_flags, NO_FLAGS);
} per_hckey_stats SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_HASH);

    __type (key, struct hc_key);

    __type (value, __u32);

    __uint (max_entries, MAX_VIPS);

    __uint (map_flags, NO_FLAGS);

} hc_key_map SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out:68:74
StructStr struct {
    __uint (type, BPF_MAP_TYPE_HASH);
    __type (key, struct hc_key);
    __type (value, __u32);
    __uint (max_entries, MAX_VIPS);
    __uint (map_flags, NO_FLAGS);
} hc_key_map SEC (".maps");

#endif // of __HEALTHCHECKING_MAPS_H

structFIle:  ./txl_annotate/annotate_struct_test_x.c.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_x.c.out
[]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_x.c.out
#include "decap_kern.c"



SEC ("xdp")

int xdp_prog_simple (struct xdp_md *ctx) {

    return xdpdecap (ctx);

}



char _license [] SEC ("license") = "GPL";

structFIle:  ./txl_annotate/annotate_struct_test_healthchecking_helpers.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_healthchecking_helpers.h.out
string #ifndef exists in file
line Number: 1 #ifndef __HEALTHCHECKING_HELPERS_H

string #endif exists in file
line Number: 167 #endif // of __HEALTHCHECKING_HELPERS_H

[('#ifndef ', '__HEALTHCHECKING_HELPERS_H', 1, 166)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_healthchecking_helpers.h.out
#ifndef __HEALTHCHECKING_HELPERS_H

#define __HEALTHCHECKING_HELPERS_H

#include <linux/if_ether.h>

#include <linux/ip.h>

#include <linux/ipv6.h>

#include <linux/pkt_cls.h>

#include <linux/string.h>

#include <linux/tcp.h>

#include <linux/udp.h>

#include <stdbool.h>

#include "bpf.h"

#include "bpf_helpers.h"

#include "encap_helpers.h"

#include "healthchecking_maps.h"

#include "healthchecking_structs.h"



__attribute__ ((__always_inline__)) static inline bool set_hc_key (const struct __sk_buff *skb, struct hc_key *hckey, bool is_ipv6) {

    void *iphdr = (void *) (long) skb->data + sizeof (struct ethhdr);

    void *transport_hdr;

    if (is_ipv6) {

        struct ipv6hdr *ip6h = iphdr;

        if (ip6h + 1 > (void *) (long) skb->data_end) {

            return false;

        }

        transport_hdr = iphdr + sizeof (struct ipv6hdr);

        memcpy (hckey -> addrv6, ip6h -> daddr.s6_addr32, 16);

        hckey->proto = ip6h->nexthdr;

    }

    else {

        struct iphdr *iph = iphdr;

        if (iph + 1 > (void *) (long) skb->data_end) {

            return false;

        }

        transport_hdr = iphdr + sizeof (struct iphdr);

        hckey->addr = iph->daddr;

        hckey->proto = iph->protocol;

    }

    if (hckey->proto == IPPROTO_TCP) {

        struct tcphdr *tcp = transport_hdr;

        if (tcp + 1 > (void *) (long) skb->data_end) {

            return false;

        }

        hckey->port = tcp->dest;

    }

    else if (hckey->proto == IPPROTO_UDP) {

        struct udphdr *udp = transport_hdr;

        if (udp + 1 > (void *) (long) skb->data_end) {

            return false;

        }

        hckey->port = udp->dest;

    }

    else {

        return false;

    }

    return true;

}



__attribute__ ((__always_inline__)) static inline bool hc_encap_ipip (struct __sk_buff *skb, struct hc_real_definition *real, struct ethhdr *ethh, bool is_ipv6) {

    struct hc_real_definition *src;

    __u64 flags = 0;

    __u16 pkt_len;

    int adjust_len;

    __u32 key;

    pkt_len = skb->len - sizeof (struct ethhdr);

    if (real->flags == V6DADDR) {

        __u8 proto = IPPROTO_IPV6;

        key = V6_SRC_INDEX;

        src = bpf_map_lookup_elem (&hc_pckt_srcs_map, &key);

        if (!src) {

            return false;

        }

        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV6;

        adjust_len = sizeof (struct ipv6hdr);

        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {

            return false;

        }

        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct ipv6hdr)) > skb->data_end) {

            return false;

        }

        ethh = (void *) (long) skb->data;

        ethh->h_proto = BE_ETH_P_IPV6;

        struct ipv6hdr *ip6h = (void *) (long) skb->data + sizeof (struct ethhdr);

        if (!is_ipv6) {

            proto = IPPROTO_IPIP;

        }

        create_v6_hdr (ip6h, DEFAULT_TOS, src -> v6daddr, real -> v6daddr, pkt_len, proto);

    }

    else {

        key = V4_SRC_INDEX;

        src = bpf_map_lookup_elem (&hc_pckt_srcs_map, &key);

        if (!src) {

            return false;

        }

        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV4;

        adjust_len = sizeof (struct iphdr);

        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {

            return false;

        }

        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct iphdr)) > skb->data_end) {

            return false;

        }

        struct iphdr *iph = (void *) (long) skb->data + sizeof (struct ethhdr);

        create_v4_hdr (iph, DEFAULT_TOS, src -> daddr, real -> daddr, pkt_len, IPPROTO_IPIP);

    }

    return true;

}



__attribute__ ((__always_inline__)) static inline __u16 gue_sport (__u32 seed) {

    return (__u16) ((seed ^ (seed >> 16)) & 0xFFFF);

}



__attribute__ ((__always_inline__)) static inline bool hc_encap_gue (struct __sk_buff *skb, struct hc_real_definition *real, struct ethhdr *ethh, bool is_ipv6) {

    struct hc_real_definition *src;

    __u64 flags = 0;

    __u16 pkt_len;

    __u16 sport;

    int adjust_len;

    __u32 key;

    pkt_len = skb->len - sizeof (struct ethhdr);

    if (real->flags == V6DADDR) {

        sport = gue_sport (real->v6daddr[0] | real->v6daddr[3]);

        __u8 proto = IPPROTO_IPV6;

        key = V6_SRC_INDEX;

        src = bpf_map_lookup_elem (&hc_pckt_srcs_map, &key);

        if (!src) {

            return false;

        }

        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 | BPF_F_ADJ_ROOM_ENCAP_L4_UDP;

        adjust_len = sizeof (struct ipv6hdr) + sizeof (struct udphdr);

        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {

            return false;

        }

        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct ipv6hdr) + sizeof (struct udphdr)) > skb->data_end) {

            return false;

        }

        ethh = (void *) (long) skb->data;

        ethh->h_proto = BE_ETH_P_IPV6;

        struct ipv6hdr *ip6h = (void *) (long) skb->data + sizeof (struct ethhdr);

        struct udphdr *udph = (void *) ip6h + sizeof (struct ipv6hdr);

        pkt_len += sizeof (struct udphdr);

        create_udp_hdr (udph, sport, GUE_DPORT, pkt_len, GUE_CSUM);

        create_v6_hdr (ip6h, DEFAULT_TOS, src -> v6daddr, real -> v6daddr, pkt_len, IPPROTO_UDP);

    }

    else {

        sport = gue_sport (real->daddr);

        key = V4_SRC_INDEX;

        src = bpf_map_lookup_elem (&hc_pckt_srcs_map, &key);

        if (!src) {

            return false;

        }

        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 | BPF_F_ADJ_ROOM_ENCAP_L4_UDP;

        adjust_len = sizeof (struct iphdr) + sizeof (struct udphdr);

        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {

            return false;

        }

        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct iphdr) + sizeof (struct udphdr)) > skb->data_end) {

            return false;

        }

        struct iphdr *iph = (void *) (long) skb->data + sizeof (struct ethhdr);

        struct udphdr *udph = (void *) iph + sizeof (struct iphdr);

        pkt_len += sizeof (struct udphdr);

        create_udp_hdr (udph, sport, GUE_DPORT, pkt_len, GUE_CSUM);

        create_v4_hdr (iph, DEFAULT_TOS, src -> daddr, real -> daddr, pkt_len, IPPROTO_UDP);

    }

    return true;

}

#endif // of __HEALTHCHECKING_HELPERS_H



structFIle:  ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out
string #ifndef exists in file
line Number: 8 #ifndef REALS_MAP_SIZE

string #ifndef exists in file
line Number: 13 #ifndef MAX_PACKET_SIZE

[]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out
#include <linux/ip.h>

#include <linux/ipv6.h>

#include <linux/pkt_cls.h>

#include <linux/string.h>

#include "bpf.h"

#include "bpf_helpers.h"

#define CTRL_MAP_SIZE 4

#ifndef REALS_MAP_SIZE

#define REALS_MAP_SIZE 4096

#endif

#define REDIRECT_EGRESS 0

#define DEFAULT_TTL 64

#ifndef MAX_PACKET_SIZE

#define MAX_PACKET_SIZE 1474

#endif

#define GENERIC_STATS_INDEX 0

#define STATS_SIZE 1

#define NO_FLAGS 0

#define V6DADDR (1 << 0)



<struct>

struct hc_real_definition {

    union {

        __be32 daddr;

        __be32 v6daddr [4];

    };

    __u8 flags;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out:22:28
StructStr struct hc_real_definition {
    union {
        __be32 daddr;
        __be32 v6daddr [4];
    };
    __u8 flags;
};



<struct>

struct hc_stats {

    __u64 pckts_processed;

    __u64 pckts_dropped;

    __u64 pckts_skipped;

    __u64 pckts_too_big;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out:32:37
StructStr struct hc_stats {
    __u64 pckts_processed;
    __u64 pckts_dropped;
    __u64 pckts_skipped;
    __u64 pckts_too_big;
};



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_ARRAY);

    __type (key, __u32);

    __type (value, __u32);

    __uint (max_entries, CTRL_MAP_SIZE);

} hc_ctrl_map SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out:41:46
StructStr struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, CTRL_MAP_SIZE);
} hc_ctrl_map SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_HASH);

    __type (key, __u32);

    __type (value, struct hc_real_definition);

    __uint (max_entries, REALS_MAP_SIZE);

} hc_reals_map SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out:50:55
StructStr struct {
    __uint (type, BPF_MAP_TYPE_HASH);
    __type (key, __u32);
    __type (value, struct hc_real_definition);
    __uint (max_entries, REALS_MAP_SIZE);
} hc_reals_map SEC (".maps");



<struct>

struct {

    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);

    __type (key, __u32);

    __type (value, struct hc_stats);

    __uint (max_entries, STATS_SIZE);

    __uint (map_flags, NO_FLAGS);

} hc_stats_map SEC (".maps");

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out:59:65
StructStr struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, struct hc_stats);
    __uint (max_entries, STATS_SIZE);
    __uint (map_flags, NO_FLAGS);
} hc_stats_map SEC (".maps");



SEC ("tc")

int healthcheck_encap (struct __sk_buff *skb) {

    int ret = 0;

    int tun_flag = 0;

    __u32 ifindex;

    __u32 somark = skb->mark;

    __u32 v4_intf_pos = 1;

    __u32 v6_intf_pos = 2;

    struct bpf_tunnel_key tkey = {};

    __u32 stats_key = GENERIC_STATS_INDEX;

    struct hc_stats *prog_stats;

    prog_stats = bpf_map_lookup_elem (&hc_stats_map, &stats_key);

    if (!prog_stats) {

        return TC_ACT_UNSPEC;

    }

    if (skb->mark == 0) {

        prog_stats->pckts_skipped += 1;

        return TC_ACT_UNSPEC;

    }

    struct hc_real_definition *real = bpf_map_lookup_elem (&hc_reals_map, &somark);

    if (!real) {

        prog_stats->pckts_skipped += 1;

        return TC_ACT_UNSPEC;

    }

    if (skb->len > MAX_PACKET_SIZE) {

        prog_stats->pckts_dropped += 1;

        prog_stats->pckts_too_big += 1;

        return TC_ACT_SHOT;

    }

    __u32 *v4_intf_ifindex = bpf_map_lookup_elem (&hc_ctrl_map, &v4_intf_pos);

    if (!v4_intf_ifindex) {

        prog_stats->pckts_dropped += 1;

        return TC_ACT_SHOT;

    }

    __u32 *v6_intf_ifindex = bpf_map_lookup_elem (&hc_ctrl_map, &v6_intf_pos);

    if (!v6_intf_ifindex) {

        prog_stats->pckts_dropped += 1;

        return TC_ACT_SHOT;

    }

    tkey.tunnel_ttl = DEFAULT_TTL;

    skb->mark = 0;

    if (real->flags == V6DADDR) {

        tun_flag = BPF_F_TUNINFO_IPV6;

        memcpy (tkey.remote_ipv6, real -> v6daddr, 16);

        ifindex = *v6_intf_ifindex;

    }

    else {

        tkey.remote_ipv4 = real->daddr;

        ifindex = *v4_intf_ifindex;

    }

    prog_stats->pckts_processed += 1;

    bpf_skb_set_tunnel_key (skb, & tkey, sizeof (tkey), tun_flag);

    return bpf_redirect (ifindex, REDIRECT_EGRESS);

}



char _license [] SEC ("license") = "GPL";

structFIle:  ./txl_annotate/annotate_struct_test_bpf_common.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_bpf_common.h.out
string #ifndef exists in file
line Number: 1 #ifndef _UAPI__LINUX_BPF_COMMON_H__

string #ifndef exists in file
line Number: 43 #ifndef BPF_MAXINSNS

string #endif exists in file
line Number: 46 #endif /* _UAPI__LINUX_BPF_COMMON_H__ */

[('#ifndef ', 'BPF_MAXINSNS', 43, 45)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_bpf_common.h.out
#ifndef _UAPI__LINUX_BPF_COMMON_H__

#define _UAPI__LINUX_BPF_COMMON_H__

#define BPF_CLASS(code) ((code)&0x07)

#define BPF_LD 0x00

#define BPF_LDX 0x01

#define BPF_ST 0x02

#define BPF_STX 0x03

#define BPF_ALU 0x04

#define BPF_JMP 0x05

#define BPF_RET 0x06

#define BPF_MISC 0x07

#define BPF_SIZE(code) ((code)&0x18)

#define BPF_W 0x00 /* 32-bit */

#define BPF_H 0x08 /* 16-bit */

#define BPF_B 0x10 /*  8-bit */

#define BPF_MODE(code) ((code)&0xe0)

#define BPF_IMM 0x00

#define BPF_ABS 0x20

#define BPF_IND 0x40

#define BPF_MEM 0x60

#define BPF_LEN 0x80

#define BPF_MSH 0xa0

#define BPF_OP(code) ((code)&0xf0)

#define BPF_ADD 0x00

#define BPF_SUB 0x10

#define BPF_MUL 0x20

#define BPF_DIV 0x30

#define BPF_OR 0x40

#define BPF_AND 0x50

#define BPF_LSH 0x60

#define BPF_RSH 0x70

#define BPF_NEG 0x80

#define BPF_MOD 0x90

#define BPF_XOR 0xa0

#define BPF_JA 0x00

#define BPF_JEQ 0x10

#define BPF_JGT 0x20

#define BPF_JGE 0x30

#define BPF_JSET 0x40

#define BPF_SRC(code) ((code)&0x08)

#define BPF_K 0x00

#define BPF_X 0x08

#ifndef BPF_MAXINSNS

#define BPF_MAXINSNS 4096

#endif

#endif /* _UAPI__LINUX_BPF_COMMON_H__ */

structFIle:  ./txl_annotate/annotate_struct_test_flow_debug_helpers.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_flow_debug_helpers.h.out
string #ifndef exists in file
line Number: 1 #ifndef __FLOW_DEBUG_HELPERS_H

string #endif exists in file
line Number: 86 #endif // of __FLOW_DEBUG_HELPERS_H

[('#ifndef ', '__FLOW_DEBUG_HELPERS_H', 1, 85)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_flow_debug_helpers.h.out
#ifndef __FLOW_DEBUG_HELPERS_H

#define __FLOW_DEBUG_HELPERS_H

#include <linux/if_ether.h>

#include <linux/in.h>

#include <linux/ip.h>

#include <linux/ipv6.h>

#include <linux/tcp.h>

#include <linux/udp.h>

#include "flow_debug_maps.h"



__attribute__ ((__always_inline__)) static inline __u32 get_next_ports (void *transport_hdr, __u8 proto, void *data_end) {

    __u32 ports = 0;

    struct udphdr *udph = 0;

    struct tcphdr *tcph = 0;

    switch (proto) {

    case IPPROTO_UDP :

        udph = transport_hdr;

        if ((void *) udph + sizeof (struct udphdr) <= data_end) {

            ports = (bpf_ntohs (udph->dest) << 16) | bpf_ntohs (udph->source);

        }

        break;

    case IPPROTO_TCP :

        tcph = transport_hdr;

        if ((void *) tcph + sizeof (struct tcphdr) <= data_end) {

            ports = (bpf_ntohs (tcph->dest) << 16) | bpf_ntohs (tcph->source);

        }

        break;

    default :

        break;

    }

    return ports;

}



__attribute__ ((__always_inline__)) static inline void gue_record_route (struct ethhdr *outer_eth, struct ethhdr *inner_eth, void *data_end, bool outer_v4, bool inner_v4) {

    struct flow_key flow = {0};

    struct flow_debug_info debug_info = {0};

    struct ipv6hdr *ip6h = 0;

    struct iphdr *ip4h = 0;

    void *transport_header = 0;

    __u32 cpu_num = bpf_get_smp_processor_id ();

    void *flow_debug_map = bpf_map_lookup_elem (&flow_debug_maps, &cpu_num);

    if (!flow_debug_map) {

        return;

    }

    if (outer_v4) {

        if ((void *) outer_eth + sizeof (struct ethhdr) + sizeof (struct iphdr) > data_end) {

            return;

        }

        ip4h = (void *) outer_eth + sizeof (struct ethhdr);

        debug_info.l4_hop = ip4h->saddr;

        debug_info.this_hop = ip4h->daddr;

    }

    else {

        if ((void *) outer_eth + sizeof (struct ethhdr) + sizeof (struct ipv6hdr) > data_end) {

            return;

        }

        ip6h = (void *) outer_eth + sizeof (struct ethhdr);

        __builtin_memcpy (debug_info.l4_hopv6, ip6h -> saddr.s6_addr32, sizeof (debug_info.l4_hopv6));

        __builtin_memcpy (debug_info.this_hopv6, ip6h -> daddr.s6_addr32, sizeof (debug_info.this_hopv6));

    }

    if (inner_v4) {

        if ((void *) inner_eth + sizeof (struct ethhdr) + sizeof (struct iphdr) > data_end) {

            return;

        }

        ip4h = (void *) inner_eth + sizeof (struct ethhdr);

        transport_header = (void *) inner_eth + sizeof (struct ethhdr) + sizeof (struct iphdr);

        flow.src = ip4h->saddr;

        flow.dst = ip4h->daddr;

        flow.proto = ip4h->protocol;

        flow.ports = get_next_ports (transport_header, ip4h->protocol, data_end);

    }

    else {

        if ((void *) inner_eth + sizeof (struct ethhdr) + sizeof (struct ipv6hdr) > data_end) {

            return;

        }

        ip6h = (void *) inner_eth + sizeof (struct ethhdr);

        transport_header = (void *) inner_eth + sizeof (struct ethhdr) + sizeof (struct ipv6hdr);

        __builtin_memcpy (flow.srcv6, ip6h -> saddr.s6_addr32, sizeof (flow.srcv6));

        __builtin_memcpy (flow.dstv6, ip6h -> daddr.s6_addr32, sizeof (flow.dstv6));

        flow.proto = ip6h->nexthdr;

        flow.ports = get_next_ports (transport_header, ip6h->nexthdr, data_end);

    }

    bpf_map_update_elem (flow_debug_map, & flow, & debug_info, BPF_ANY);

    return;

}

#endif // of __FLOW_DEBUG_HELPERS_H



structFIle:  ./txl_annotate/annotate_struct_test_healthchecking_structs.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_healthchecking_structs.h.out
string #ifndef exists in file
line Number: 1 #ifndef __HEALTHCHECKING_STRUCTS_H

string #endif exists in file
line Number: 39 #endif // of __HEALTHCHECKING_STRUCTS_H

[('#ifndef ', '__HEALTHCHECKING_STRUCTS_H', 1, 38)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_healthchecking_structs.h.out
#ifndef __HEALTHCHECKING_STRUCTS_H

#define __HEALTHCHECKING_STRUCTS_H



<struct>

struct hc_real_definition {

    union {

        __be32 daddr;

        __be32 v6daddr [4];

    };

    __u8 flags;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_structs.h.out:5:11
StructStr struct hc_real_definition {
    union {
        __be32 daddr;
        __be32 v6daddr [4];
    };
    __u8 flags;
};



<struct>

struct hc_stats {

    __u64 pckts_processed;

    __u64 pckts_dropped;

    __u64 pckts_skipped;

    __u64 pckts_too_big;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_structs.h.out:15:20
StructStr struct hc_stats {
    __u64 pckts_processed;
    __u64 pckts_dropped;
    __u64 pckts_skipped;
    __u64 pckts_too_big;
};



<struct>

struct hc_key {

    union {

        __be32 addr;

        __be32 addrv6 [4];

    };

    __u16 port;

    __u8 proto;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_structs.h.out:24:31
StructStr struct hc_key {
    union {
        __be32 addr;
        __be32 addrv6 [4];
    };
    __u16 port;
    __u8 proto;
};



<struct>

struct hc_mac {

    __u8 mac [6];

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_healthchecking_structs.h.out:35:37
StructStr struct hc_mac {
    __u8 mac [6];
};

#endif // of __HEALTHCHECKING_STRUCTS_H

structFIle:  ./txl_annotate/annotate_struct_test_decap_kern.c.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_decap_kern.c.out
string #ifndef exists in file
line Number: 12 #ifndef DECAP_PROG_SEC

string #ifdef exists in file
line Number: 82 #ifdef INLINE_DECAP_GUE

string #endif exists in file
line Number: 116 #endif // INLINE_DECAP_GUE

string #ifdef exists in file
line Number: 147 #ifdef INLINE_DECAP_GUE

string #endif exists in file
line Number: 165 #endif // INLINE_DECAP_GUE

[('#ifdef ', 'INLINE_DECAP_GUE', 82, 115), ('#ifdef ', 'INLINE_DECAP_GUE', 147, 164)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_decap_kern.c.out
#include <linux/in.h>

#include <linux/ip.h>

#include <linux/ipv6.h>

#include <stdbool.h>

#include <stddef.h>

#include "balancer_consts.h"

#include "bpf.h"

#include "bpf_helpers.h"

#include "decap_maps.h"

#include "pckt_encap.h"

#include "pckt_parsing.h"

#ifndef DECAP_PROG_SEC

#define DECAP_PROG_SEC "xdp"

#endif



__attribute__ ((__always_inline__)) static inline int process_l3_headers (struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes, void *data, void *data_end, bool is_ipv6) {

    __u64 iph_len;

    struct iphdr *iph;

    struct ipv6hdr *ip6h;

    if (is_ipv6) {

        ip6h = data + off;

        if (ip6h + 1 > data_end) {

            return XDP_DROP;

        }

        iph_len = sizeof (struct ipv6hdr);

        *protocol = ip6h->nexthdr;

        pckt->flow.proto = *protocol;

        *pkt_bytes = bpf_ntohs (ip6h->payload_len);

        off += iph_len;

        if (*protocol == IPPROTO_FRAGMENT) {

            return XDP_DROP;

        }

    }

    else {

        iph = data + off;

        if (iph + 1 > data_end) {

            return XDP_DROP;

        }

        if (iph->ihl != 5) {

            return XDP_DROP;

        }

        *protocol = iph->protocol;

        pckt->flow.proto = *protocol;

        *pkt_bytes = bpf_ntohs (iph->tot_len);

        off += IPV4_HDR_LEN_NO_OPT;

        if (iph->frag_off & PCKT_FRAGMENTED) {

            return XDP_DROP;

        }

    }

    return FURTHER_PROCESSING;

}



__attribute__ ((__always_inline__)) static inline int process_encaped_ipip_pckt (void **data, void **data_end, struct xdp_md *xdp, bool *is_ipv6, struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes) {

    if (*protocol == IPPROTO_IPIP) {

        if (*is_ipv6) {

            if ((*data + sizeof (struct ipv6hdr) + sizeof (struct ethhdr)) > *data_end) {

                return XDP_DROP;

            }

            if (!decap_v6 (xdp, data, data_end, true)) {

                return XDP_DROP;

            }

        }

        else {

            if ((*data + sizeof (struct iphdr) + sizeof (struct ethhdr)) > *data_end) {

                return XDP_DROP;

            }

            if (!decap_v4 (xdp, data, data_end)) {

                return XDP_DROP;

            }

        }

    }

    else if (*protocol == IPPROTO_IPV6) {

        if ((*data + sizeof (struct ipv6hdr) + sizeof (struct ethhdr)) > *data_end) {

            return XDP_DROP;

        }

        if (!decap_v6 (xdp, data, data_end, false)) {

            return XDP_DROP;

        }

    }

    return FURTHER_PROCESSING;

}

#ifdef INLINE_DECAP_GUE



__attribute__ ((__always_inline__)) static inline int process_encaped_gue_pckt (void **data, void **data_end, struct xdp_md *xdp, bool is_ipv6) {

    int offset = 0;

    if (is_ipv6) {

        __u8 v6 = 0;

        offset = sizeof (struct ipv6hdr) + sizeof (struct ethhdr) + sizeof (struct udphdr);

        if ((*data + offset + 1) > *data_end) {

            return XDP_DROP;

        }

        v6 = ((__u8 *) (*data))[offset];

        v6 &= GUEV1_IPV6MASK;

        if (v6) {

            if (!gue_decap_v6 (xdp, data, data_end, false)) {

                return XDP_DROP;

            }

        }

        else {

            if (!gue_decap_v6 (xdp, data, data_end, true)) {

                return XDP_DROP;

            }

        }

    }

    else {

        offset = sizeof (struct iphdr) + sizeof (struct ethhdr) + sizeof (struct udphdr);

        if ((*data + offset) > *data_end) {

            return XDP_DROP;

        }

        if (!gue_decap_v4 (xdp, data, data_end)) {

            return XDP_DROP;

        }

    }

    return FURTHER_PROCESSING;

}

#endif // INLINE_DECAP_GUE



__attribute__ ((__always_inline__)) static inline int process_packet (void *data, __u64 off, void *data_end, bool is_ipv6, struct xdp_md *xdp) {

    struct packet_description pckt = {};

    struct decap_stats *data_stats;

    __u32 key = 0;

    __u8 protocol;

    int action;

    __u16 pkt_bytes;

    action = process_l3_headers (&pckt, &protocol, off, &pkt_bytes, data, data_end, is_ipv6);

    if (action >= 0) {

        return action;

    }

    protocol = pckt.flow.proto;

    data_stats = bpf_map_lookup_elem (&decap_counters, &key);

    if (!data_stats) {

        return XDP_PASS;

    }

    data_stats->total += 1;

    if (protocol == IPPROTO_IPIP || protocol == IPPROTO_IPV6) {

        if (is_ipv6) {

            data_stats->decap_v6 += 1;

        }

        else {

            data_stats->decap_v4 += 1;

        }

        action = process_encaped_ipip_pckt (&data, &data_end, xdp, &is_ipv6, &pckt, &protocol, off, &pkt_bytes);

        if (action >= 0) {

            return action;

        }

    }

#ifdef INLINE_DECAP_GUE

    else if (protocol == IPPROTO_UDP) {

        if (!parse_udp (data, data_end, is_ipv6, &pckt)) {

            return XDP_PASS;

        }

        if (pckt.flow.port16[1] == bpf_htons (GUE_DPORT)) {

            if (is_ipv6) {

                data_stats->decap_v6 += 1;

            }

            else {

                data_stats->decap_v4 += 1;

            }

            action = process_encaped_gue_pckt (&data, &data_end, xdp, is_ipv6);

            if (action >= 0) {

                return action;

            }

        }

    }

#endif // INLINE_DECAP_GUE

    return XDP_PASS;

}



SEC (DECAP_PROG_SEC)

int xdpdecap (struct xdp_md *ctx) {

    void *data = (void *) (long) ctx->data;

    void *data_end = (void *) (long) ctx->data_end;

    struct ethhdr *eth = data;

    __u32 eth_proto;

    __u32 nh_off;

    nh_off = sizeof (struct ethhdr);

    if (data + nh_off > data_end) {

        return XDP_DROP;

    }

    eth_proto = eth->h_proto;

    if (eth_proto == BE_ETH_P_IP) {

        return process_packet (data, nh_off, data_end, false, ctx);

    }

    else if (eth_proto == BE_ETH_P_IPV6) {

        return process_packet (data, nh_off, data_end, true, ctx);

    }

    else {

        return XDP_PASS;

    }

}



structFIle:  ./txl_annotate/annotate_struct_test_flow_debug.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_flow_debug.h.out
string #ifndef exists in file
line Number: 1 #ifndef __FLOW_DEBUG_H

string #ifdef exists in file
line Number: 3 #ifdef RECORD_FLOW_INFO

string #ifndef exists in file
line Number: 4 #ifndef FLOW_DEBUG_MAP_SIZE

string #endif exists in file
line Number: 6 #endif // of FLOW_DEBUG_MAP_SIZE

string #endif exists in file
line Number: 14 #endif // of RECORD_FLOW_INFO

string #endif exists in file
line Number: 15 #endif // of __FLOW_DEBUG_H

[('#ifndef ', 'FLOW_DEBUG_MAP_SIZE', 4, 5), ('#ifdef ', 'RECORD_FLOW_INFO', 3, 13), ('#ifndef ', '__FLOW_DEBUG_H', 1, 14)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_flow_debug.h.out
#ifndef __FLOW_DEBUG_H

#define __FLOW_DEBUG_H

#ifdef RECORD_FLOW_INFO

#ifndef FLOW_DEBUG_MAP_SIZE

#define FLOW_DEBUG_MAP_SIZE 1000000

#endif // of FLOW_DEBUG_MAP_SIZE

#define NO_FLAGS 0

#include "flow_debug_helpers.h"

#define RECORD_GUE_ROUTE(old_eth, new_eth, data_end, outer_v4, inner_v4) \

  gue_record_route(old_eth, new_eth, data_end, outer_v4, inner_v4)

#else

#define RECORD_GUE_ROUTE(...) \

  {}

#endif // of RECORD_FLOW_INFO

#endif // of __FLOW_DEBUG_H

structFIle:  ./txl_annotate/annotate_struct_test_introspection.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_introspection.h.out
string #ifdef exists in file
line Number: 5 #ifdef KATRAN_INTROSPECTION

[]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_introspection.h.out
#define MAX_EVENT_SIZE 128

#define TCP_NONSYN_LRUMISS 0

#define PACKET_TOOBIG 1

#define QUIC_PACKET_DROP_NO_REAL 2

#ifdef KATRAN_INTROSPECTION

#define REPORT_EVENT(xdp, event, data, size, meta_only) \

  ({ submit_event((xdp), &event_pipe, (event), data, size, meta_only); })

#define REPORT_TCP_NONSYN_LRUMISS(xdp, data, size, meta_only) \

  REPORT_EVENT(xdp, TCP_NONSYN_LRUMISS, data, size, meta_only)

#define REPORT_PACKET_TOOBIG(xdp, data, size, meta_only) \

  REPORT_EVENT(xdp, PACKET_TOOBIG, data, size, meta_only)

#define REPORT_QUIC_PACKET_DROP_NO_REAL(xdp, data, size, meta_only) \

  REPORT_EVENT(xdp, QUIC_PACKET_DROP_NO_REAL, data, size, meta_only)

#else

#define REPORT_TCP_NONSYN_LRUMISS(...) \

  {}

#define REPORT_PACKET_TOOBIG(...) \

  {}

#define REPORT_QUIC_PACKET_DROP_NO_REAL(...) \

  {}

#endif

structFIle:  ./txl_annotate/annotate_struct_test_bpf.h.out
Creating preprocessor for:  ./txl_annotate/annotate_struct_test_bpf.h.out
string #ifndef exists in file
line Number: 1 #ifndef _UAPI__LINUX_BPF_H__

string #endif exists in file
line Number: 747 #endif /* _UAPI__LINUX_BPF_H__ */

[('#ifndef ', '_UAPI__LINUX_BPF_H__', 1, 746)]
Parsing Struct Output FIle:  ./txl_annotate/annotate_struct_test_bpf.h.out
#ifndef _UAPI__LINUX_BPF_H__

#define _UAPI__LINUX_BPF_H__

#include <linux/types.h>

#include "bpf_common.h"

#define BPF_JMP32 0x06 /* jmp mode in word width */

#define BPF_ALU64 0x07 /* alu mode in double word width */

#define BPF_DW 0x18 /* double word (64-bit) */

#define BPF_XADD 0xc0 /* exclusive add */

#define BPF_MOV 0xb0 /* mov reg to reg */

#define BPF_ARSH 0xc0 /* sign extending arithmetic shift right */

#define BPF_END 0xd0 /* flags for endianness conversion: */

#define BPF_TO_LE 0x00 /* convert to little-endian */

#define BPF_TO_BE 0x08 /* convert to big-endian */

#define BPF_FROM_LE BPF_TO_LE

#define BPF_FROM_BE BPF_TO_BE

#define BPF_JNE 0x50 /* jump != */

#define BPF_JLT 0xa0 /* LT is unsigned, '<' */

#define BPF_JLE 0xb0 /* LE is unsigned, '<=' */

#define BPF_JSGT 0x60 /* SGT is signed '>', GT in x86 */

#define BPF_JSGE 0x70 /* SGE is signed '>=', GE in x86 */

#define BPF_JSLT 0xc0 /* SLT is signed, '<' */

#define BPF_JSLE 0xd0 /* SLE is signed, '<=' */

#define BPF_CALL 0x80 /* function call */

#define BPF_EXIT 0x90 /* function return */

enum {BPF_REG_0 = 0, BPF_REG_1, BPF_REG_2, BPF_REG_3, BPF_REG_4, BPF_REG_5, BPF_REG_6, BPF_REG_7, BPF_REG_8, BPF_REG_9, BPF_REG_10, __MAX_BPF_REG,};

#define MAX_BPF_REG __MAX_BPF_REG



<struct>

struct bpf_insn {

    __u8 code;

    __u8 dst_reg : 4;

    __u8 src_reg : 4;

    __s16 off;

    __s32 imm;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:29:35
StructStr struct bpf_insn {
    __u8 code;
    __u8 dst_reg : 4;
    __u8 src_reg : 4;
    __s16 off;
    __s32 imm;
};



<struct>

struct bpf_lpm_trie_key {

    __u32 prefixlen;

    __u8 data [0];

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:39:42
StructStr struct bpf_lpm_trie_key {
    __u32 prefixlen;
    __u8 data [0];
};



<struct>

struct bpf_cgroup_storage_key {

    __u64 cgroup_inode_id;

    __u32 attach_type;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:46:49
StructStr struct bpf_cgroup_storage_key {
    __u64 cgroup_inode_id;
    __u32 attach_type;
};

enum bpf_cmd {BPF_MAP_CREATE, BPF_MAP_LOOKUP_ELEM, BPF_MAP_UPDATE_ELEM, BPF_MAP_DELETE_ELEM, BPF_MAP_GET_NEXT_KEY, BPF_PROG_LOAD, BPF_OBJ_PIN, BPF_OBJ_GET, BPF_PROG_ATTACH, BPF_PROG_DETACH, BPF_PROG_TEST_RUN, BPF_PROG_GET_NEXT_ID, BPF_MAP_GET_NEXT_ID, BPF_PROG_GET_FD_BY_ID, BPF_MAP_GET_FD_BY_ID, BPF_OBJ_GET_INFO_BY_FD, BPF_PROG_QUERY, BPF_RAW_TRACEPOINT_OPEN, BPF_BTF_LOAD, BPF_BTF_GET_FD_BY_ID, BPF_TASK_FD_QUERY, BPF_MAP_LOOKUP_AND_DELETE_ELEM, BPF_MAP_FREEZE, BPF_BTF_GET_NEXT_ID,};

enum bpf_map_type {BPF_MAP_TYPE_UNSPEC, BPF_MAP_TYPE_HASH, BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PROG_ARRAY, BPF_MAP_TYPE_PERF_EVENT_ARRAY, BPF_MAP_TYPE_PERCPU_HASH, BPF_MAP_TYPE_PERCPU_ARRAY, BPF_MAP_TYPE_STACK_TRACE, BPF_MAP_TYPE_CGROUP_ARRAY, BPF_MAP_TYPE_LRU_HASH, BPF_MAP_TYPE_LRU_PERCPU_HASH, BPF_MAP_TYPE_LPM_TRIE, BPF_MAP_TYPE_ARRAY_OF_MAPS, BPF_MAP_TYPE_HASH_OF_MAPS, BPF_MAP_TYPE_DEVMAP, BPF_MAP_TYPE_SOCKMAP, BPF_MAP_TYPE_CPUMAP, BPF_MAP_TYPE_XSKMAP, BPF_MAP_TYPE_SOCKHASH, BPF_MAP_TYPE_CGROUP_STORAGE, BPF_MAP_TYPE_REUSEPORT_SOCKARRAY, BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE, BPF_MAP_TYPE_QUEUE, BPF_MAP_TYPE_STACK, BPF_MAP_TYPE_SK_STORAGE, BPF_MAP_TYPE_DEVMAP_HASH,};

enum bpf_prog_type {BPF_PROG_TYPE_UNSPEC, BPF_PROG_TYPE_SOCKET_FILTER, BPF_PROG_TYPE_KPROBE, BPF_PROG_TYPE_SCHED_CLS, BPF_PROG_TYPE_SCHED_ACT, BPF_PROG_TYPE_TRACEPOINT, BPF_PROG_TYPE_XDP, BPF_PROG_TYPE_PERF_EVENT, BPF_PROG_TYPE_CGROUP_SKB, BPF_PROG_TYPE_CGROUP_SOCK, BPF_PROG_TYPE_LWT_IN, BPF_PROG_TYPE_LWT_OUT, BPF_PROG_TYPE_LWT_XMIT, BPF_PROG_TYPE_SOCK_OPS, BPF_PROG_TYPE_SK_SKB, BPF_PROG_TYPE_CGROUP_DEVICE, BPF_PROG_TYPE_SK_MSG, BPF_PROG_TYPE_RAW_TRACEPOINT, BPF_PROG_TYPE_CGROUP_SOCK_ADDR, BPF_PROG_TYPE_LWT_SEG6LOCAL, BPF_PROG_TYPE_LIRC_MODE2, BPF_PROG_TYPE_SK_REUSEPORT, BPF_PROG_TYPE_FLOW_DISSECTOR, BPF_PROG_TYPE_CGROUP_SYSCTL, BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE, BPF_PROG_TYPE_CGROUP_SOCKOPT, BPF_PROG_TYPE_TRACING,};

enum bpf_attach_type {BPF_CGROUP_INET_INGRESS, BPF_CGROUP_INET_EGRESS, BPF_CGROUP_INET_SOCK_CREATE, BPF_CGROUP_SOCK_OPS, BPF_SK_SKB_STREAM_PARSER, BPF_SK_SKB_STREAM_VERDICT, BPF_CGROUP_DEVICE, BPF_SK_MSG_VERDICT, BPF_CGROUP_INET4_BIND, BPF_CGROUP_INET6_BIND, BPF_CGROUP_INET4_CONNECT, BPF_CGROUP_INET6_CONNECT, BPF_CGROUP_INET4_POST_BIND, BPF_CGROUP_INET6_POST_BIND, BPF_CGROUP_UDP4_SENDMSG, BPF_CGROUP_UDP6_SENDMSG, BPF_LIRC_MODE2, BPF_FLOW_DISSECTOR, BPF_CGROUP_SYSCTL, BPF_CGROUP_UDP4_RECVMSG, BPF_CGROUP_UDP6_RECVMSG, BPF_CGROUP_GETSOCKOPT, BPF_CGROUP_SETSOCKOPT, BPF_TRACE_RAW_TP, BPF_TRACE_FENTRY, BPF_TRACE_FEXIT, __MAX_BPF_ATTACH_TYPE};

#define MAX_BPF_ATTACH_TYPE __MAX_BPF_ATTACH_TYPE

#define BPF_F_ALLOW_OVERRIDE (1U << 0)

#define BPF_F_ALLOW_MULTI (1U << 1)

#define BPF_F_STRICT_ALIGNMENT (1U << 0)

#define BPF_F_ANY_ALIGNMENT (1U << 1)

#define BPF_F_TEST_RND_HI32 (1U << 2)

#define BPF_F_TEST_STATE_FREQ (1U << 3)

#define BPF_PSEUDO_MAP_FD 1

#define BPF_PSEUDO_MAP_VALUE 2

#define BPF_PSEUDO_CALL 1

#define BPF_ANY 0 /* create new element or update existing */

#define BPF_NOEXIST 1 /* create new element if it didn't exist */

#define BPF_EXIST 2 /* update existing element */

#define BPF_F_LOCK 4 /* spin_lock-ed map_lookup/map_update */

#define BPF_F_NO_PREALLOC (1U << 0)

#define BPF_F_NO_COMMON_LRU (1U << 1)

#define BPF_F_NUMA_NODE (1U << 2)

#define BPF_OBJ_NAME_LEN 16U

#define BPF_F_RDONLY (1U << 3)

#define BPF_F_WRONLY (1U << 4)

#define BPF_F_STACK_BUILD_ID (1U << 5)

#define BPF_F_ZERO_SEED (1U << 6)

#define BPF_F_RDONLY_PROG (1U << 7)

#define BPF_F_WRONLY_PROG (1U << 8)

#define BPF_F_CLONE (1U << 9)

#define BPF_F_MMAPABLE (1U << 10)

#define BPF_F_QUERY_EFFECTIVE (1U << 0)

enum bpf_stack_build_id_status {BPF_STACK_BUILD_ID_EMPTY = 0, BPF_STACK_BUILD_ID_VALID = 1, BPF_STACK_BUILD_ID_IP = 2,};

#define BPF_BUILD_ID_SIZE 20



<struct>

struct bpf_stack_build_id {

    __s32 status;

    unsigned char build_id [BPF_BUILD_ID_SIZE];

    union {

        __u64 offset;

        __u64 ip;

    };

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:86:93
StructStr struct bpf_stack_build_id {
    __s32 status;
    unsigned char build_id [BPF_BUILD_ID_SIZE];
    union {
        __u64 offset;
        __u64 ip;
    };
};



<struct>

union bpf_attr {

    struct {

        __u32 map_type;

        __u32 key_size;

        __u32 value_size;

        __u32 max_entries;

        __u32 map_flags;

        __u32 inner_map_fd;

        __u32 numa_node;

        char map_name [BPF_OBJ_NAME_LEN];

        __u32 map_ifindex;

        __u32 btf_fd;

        __u32 btf_key_type_id;

        __u32 btf_value_type_id;

    };

    struct {

        __u32 map_fd;

        __aligned_u64 key;

        union {

            __aligned_u64 value;

            __aligned_u64 next_key;

        };

        __u64 flags;

    };

    struct {

        __u32 prog_type;

        __u32 insn_cnt;

        __aligned_u64 insns;

        __aligned_u64 license;

        __u32 log_level;

        __u32 log_size;

        __aligned_u64 log_buf;

        __u32 kern_version;

        __u32 prog_flags;

        char prog_name [BPF_OBJ_NAME_LEN];

        __u32 prog_ifindex;

        __u32 expected_attach_type;

        __u32 prog_btf_fd;

        __u32 func_info_rec_size;

        __aligned_u64 func_info;

        __u32 func_info_cnt;

        __u32 line_info_rec_size;

        __aligned_u64 line_info;

        __u32 line_info_cnt;

        __u32 attach_btf_id;

        __u32 attach_prog_fd;

    };

    struct {

        __aligned_u64 pathname;

        __u32 bpf_fd;

        __u32 file_flags;

    };

    struct {

        __u32 target_fd;

        __u32 attach_bpf_fd;

        __u32 attach_type;

        __u32 attach_flags;

    };

    struct {

        __u32 prog_fd;

        __u32 retval;

        __u32 data_size_in;

        __u32 data_size_out;

        __aligned_u64 data_in;

        __aligned_u64 data_out;

        __u32 repeat;

        __u32 duration;

        __u32 ctx_size_in;

        __u32 ctx_size_out;

        __aligned_u64 ctx_in;

        __aligned_u64 ctx_out;

    } test;

    struct {

        union {

            __u32 start_id;

            __u32 prog_id;

            __u32 map_id;

            __u32 btf_id;

        };

        __u32 next_id;

        __u32 open_flags;

    };

    struct {

        __u32 bpf_fd;

        __u32 info_len;

        __aligned_u64 info;

    } info;

    struct {

        __u32 target_fd;

        __u32 attach_type;

        __u32 query_flags;

        __u32 attach_flags;

        __aligned_u64 prog_ids;

        __u32 prog_cnt;

    } query;

    struct {

        __u64 name;

        __u32 prog_fd;

    } raw_tracepoint;

    struct {

        __aligned_u64 btf;

        __aligned_u64 btf_log_buf;

        __u32 btf_size;

        __u32 btf_log_size;

        __u32 btf_log_level;

    };

    struct {

        __u32 pid;

        __u32 fd;

        __u32 flags;

        __u32 buf_len;

        __aligned_u64 buf;

        __u32 prog_id;

        __u32 fd_type;

        __u64 probe_offset;

        __u64 probe_addr;

    } task_fd_query;

} __attribute__ ((aligned (8)));

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:97:214
StructStr union bpf_attr {
    struct {
        __u32 map_type;
        __u32 key_size;
        __u32 value_size;
        __u32 max_entries;
        __u32 map_flags;
        __u32 inner_map_fd;
        __u32 numa_node;
        char map_name [BPF_OBJ_NAME_LEN];
        __u32 map_ifindex;
        __u32 btf_fd;
        __u32 btf_key_type_id;
        __u32 btf_value_type_id;
    };
    struct {
        __u32 map_fd;
        __aligned_u64 key;
        union {
            __aligned_u64 value;
            __aligned_u64 next_key;
        };
        __u64 flags;
    };
    struct {
        __u32 prog_type;
        __u32 insn_cnt;
        __aligned_u64 insns;
        __aligned_u64 license;
        __u32 log_level;
        __u32 log_size;
        __aligned_u64 log_buf;
        __u32 kern_version;
        __u32 prog_flags;
        char prog_name [BPF_OBJ_NAME_LEN];
        __u32 prog_ifindex;
        __u32 expected_attach_type;
        __u32 prog_btf_fd;
        __u32 func_info_rec_size;
        __aligned_u64 func_info;
        __u32 func_info_cnt;
        __u32 line_info_rec_size;
        __aligned_u64 line_info;
        __u32 line_info_cnt;
        __u32 attach_btf_id;
        __u32 attach_prog_fd;
    };
    struct {
        __aligned_u64 pathname;
        __u32 bpf_fd;
        __u32 file_flags;
    };
    struct {
        __u32 target_fd;
        __u32 attach_bpf_fd;
        __u32 attach_type;
        __u32 attach_flags;
    };
    struct {
        __u32 prog_fd;
        __u32 retval;
        __u32 data_size_in;
        __u32 data_size_out;
        __aligned_u64 data_in;
        __aligned_u64 data_out;
        __u32 repeat;
        __u32 duration;
        __u32 ctx_size_in;
        __u32 ctx_size_out;
        __aligned_u64 ctx_in;
        __aligned_u64 ctx_out;
    } test;
    struct {
        union {
            __u32 start_id;
            __u32 prog_id;
            __u32 map_id;
            __u32 btf_id;
        };
        __u32 next_id;
        __u32 open_flags;
    };
    struct {
        __u32 bpf_fd;
        __u32 info_len;
        __aligned_u64 info;
    } info;
    struct {
        __u32 target_fd;
        __u32 attach_type;
        __u32 query_flags;
        __u32 attach_flags;
        __aligned_u64 prog_ids;
        __u32 prog_cnt;
    } query;
    struct {
        __u64 name;
        __u32 prog_fd;
    } raw_tracepoint;
    struct {
        __aligned_u64 btf;
        __aligned_u64 btf_log_buf;
        __u32 btf_size;
        __u32 btf_log_size;
        __u32 btf_log_level;
    };
    struct {
        __u32 pid;
        __u32 fd;
        __u32 flags;
        __u32 buf_len;
        __aligned_u64 buf;
        __u32 prog_id;
        __u32 fd_type;
        __u64 probe_offset;
        __u64 probe_addr;
    } task_fd_query;
} __attribute__ ((aligned (8)));

#define __BPF_FUNC_MAPPER(FN)                                                  \

  FN(unspec), FN(map_lookup_elem), FN(map_update_elem), FN(map_delete_elem),   \

      FN(probe_read), FN(ktime_get_ns), FN(trace_printk), FN(get_prandom_u32), \

      FN(get_smp_processor_id), FN(skb_store_bytes), FN(l3_csum_replace),      \

      FN(l4_csum_replace), FN(tail_call), FN(clone_redirect),                  \

      FN(get_current_pid_tgid), FN(get_current_uid_gid), FN(get_current_comm), \

      FN(get_cgroup_classid), FN(skb_vlan_push), FN(skb_vlan_pop),             \

      FN(skb_get_tunnel_key), FN(skb_set_tunnel_key), FN(perf_event_read),     \

      FN(redirect), FN(get_route_realm), FN(perf_event_output),                \

      FN(skb_load_bytes), FN(get_stackid), FN(csum_diff),                      \

      FN(skb_get_tunnel_opt), FN(skb_set_tunnel_opt), FN(skb_change_proto),    \

      FN(skb_change_type), FN(skb_under_cgroup), FN(get_hash_recalc),          \

      FN(get_current_task), FN(probe_write_user),                              \

      FN(current_task_under_cgroup), FN(skb_change_tail), FN(skb_pull_data),   \

      FN(csum_update), FN(set_hash_invalid), FN(get_numa_node_id),             \

      FN(skb_change_head), FN(xdp_adjust_head), FN(probe_read_str),            \

      FN(get_socket_cookie), FN(get_socket_uid), FN(set_hash), FN(setsockopt), \

      FN(skb_adjust_room), FN(redirect_map), FN(sk_redirect_map),              \

      FN(sock_map_update), FN(xdp_adjust_meta), FN(perf_event_read_value),     \

      FN(perf_prog_read_value), FN(getsockopt), FN(override_return),           \

      FN(sock_ops_cb_flags_set), FN(msg_redirect_map), FN(msg_apply_bytes),    \

      FN(msg_cork_bytes), FN(msg_pull_data), FN(bind), FN(xdp_adjust_tail),    \

      FN(skb_get_xfrm_state), FN(get_stack), FN(skb_load_bytes_relative),      \

      FN(fib_lookup), FN(sock_hash_update), FN(msg_redirect_hash),             \

      FN(sk_redirect_hash), FN(lwt_push_encap), FN(lwt_seg6_store_bytes),      \

      FN(lwt_seg6_adjust_srh), FN(lwt_seg6_action), FN(rc_repeat),             \

      FN(rc_keydown), FN(skb_cgroup_id), FN(get_current_cgroup_id),            \

      FN(get_local_storage), FN(sk_select_reuseport),                          \

      FN(skb_ancestor_cgroup_id), FN(sk_lookup_tcp), FN(sk_lookup_udp),        \

      FN(sk_release), FN(map_push_elem), FN(map_pop_elem), FN(map_peek_elem),  \

      FN(msg_push_data), FN(msg_pop_data), FN(rc_pointer_rel), FN(spin_lock),  \

      FN(spin_unlock), FN(sk_fullsock), FN(tcp_sock), FN(skb_ecn_set_ce),      \

      FN(get_listener_sock), FN(skc_lookup_tcp), FN(tcp_check_syncookie),      \

      FN(sysctl_get_name), FN(sysctl_get_current_value),                       \

      FN(sysctl_get_new_value), FN(sysctl_set_new_value), FN(strtol),          \

      FN(strtoul), FN(sk_storage_get), FN(sk_storage_delete), FN(send_signal), \

      FN(tcp_gen_syncookie), FN(skb_output), FN(probe_read_user),              \

      FN(probe_read_kernel), FN(probe_read_user_str),                          \

      FN(probe_read_kernel_str),

#define __BPF_ENUM_FN(x) BPF_FUNC_##x

enum bpf_func_id {__BPF_FUNC_MAPPER (__BPF_ENUM_FN) __BPF_FUNC_MAX_ID,};

#undef __BPF_ENUM_FN

#define BPF_F_RECOMPUTE_CSUM (1ULL << 0)

#define BPF_F_INVALIDATE_HASH (1ULL << 1)

#define BPF_F_HDR_FIELD_MASK 0xfULL

#define BPF_F_PSEUDO_HDR (1ULL << 4)

#define BPF_F_MARK_MANGLED_0 (1ULL << 5)

#define BPF_F_MARK_ENFORCE (1ULL << 6)

#define BPF_F_INGRESS (1ULL << 0)

#define BPF_F_TUNINFO_IPV6 (1ULL << 0)

#define BPF_F_SKIP_FIELD_MASK 0xffULL

#define BPF_F_USER_STACK (1ULL << 8)

#define BPF_F_FAST_STACK_CMP (1ULL << 9)

#define BPF_F_REUSE_STACKID (1ULL << 10)

#define BPF_F_USER_BUILD_ID (1ULL << 11)

#define BPF_F_ZERO_CSUM_TX (1ULL << 1)

#define BPF_F_DONT_FRAGMENT (1ULL << 2)

#define BPF_F_SEQ_NUMBER (1ULL << 3)

#define BPF_F_INDEX_MASK 0xffffffffULL

#define BPF_F_CURRENT_CPU BPF_F_INDEX_MASK

#define BPF_F_CTXLEN_MASK (0xfffffULL << 32)

#define BPF_F_CURRENT_NETNS (-1L)

#define BPF_F_ADJ_ROOM_FIXED_GSO (1ULL << 0)

#define BPF_ADJ_ROOM_ENCAP_L2_MASK 0xff

#define BPF_ADJ_ROOM_ENCAP_L2_SHIFT 56

#define BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 (1ULL << 1)

#define BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 (1ULL << 2)

#define BPF_F_ADJ_ROOM_ENCAP_L4_GRE (1ULL << 3)

#define BPF_F_ADJ_ROOM_ENCAP_L4_UDP (1ULL << 4)

#define BPF_F_ADJ_ROOM_ENCAP_L2(len) \

  (((__u64)len & BPF_ADJ_ROOM_ENCAP_L2_MASK) << BPF_ADJ_ROOM_ENCAP_L2_SHIFT)

#define BPF_F_SYSCTL_BASE_NAME (1ULL << 0)

#define BPF_SK_STORAGE_GET_F_CREATE (1ULL << 0)

enum bpf_adj_room_mode {BPF_ADJ_ROOM_NET, BPF_ADJ_ROOM_MAC,};

enum bpf_hdr_start_off {BPF_HDR_START_MAC, BPF_HDR_START_NET,};

enum bpf_lwt_encap_mode {BPF_LWT_ENCAP_SEG6, BPF_LWT_ENCAP_SEG6_INLINE, BPF_LWT_ENCAP_IP,};

#define __bpf_md_ptr(type, name) \

  union {                        \

    type name;                   \

    __u64 : 64;                  \

  } __attribute__((aligned(8)))



<struct>

struct __sk_buff {

    __u32 len;

    __u32 pkt_type;

    __u32 mark;

    __u32 queue_mapping;

    __u32 protocol;

    __u32 vlan_present;

    __u32 vlan_tci;

    __u32 vlan_proto;

    __u32 priority;

    __u32 ingress_ifindex;

    __u32 ifindex;

    __u32 tc_index;

    __u32 cb [5];

    __u32 hash;

    __u32 tc_classid;

    __u32 data;

    __u32 data_end;

    __u32 napi_id;

    __u32 family;

    __u32 remote_ip4;

    __u32 local_ip4;

    __u32 remote_ip6 [4];

    __u32 local_ip6 [4];

    __u32 remote_port;

    __u32 local_port;

    __u32 data_meta;

    __bpf_md_ptr (struct bpf_flow_keys *, flow_keys);

    __u64 tstamp;

    __u32 wire_len;

    __u32 gso_segs;

    __bpf_md_ptr (struct bpf_sock *, sk);

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:299:331
StructStr struct __sk_buff {
    __u32 len;
    __u32 pkt_type;
    __u32 mark;
    __u32 queue_mapping;
    __u32 protocol;
    __u32 vlan_present;
    __u32 vlan_tci;
    __u32 vlan_proto;
    __u32 priority;
    __u32 ingress_ifindex;
    __u32 ifindex;
    __u32 tc_index;
    __u32 cb [5];
    __u32 hash;
    __u32 tc_classid;
    __u32 data;
    __u32 data_end;
    __u32 napi_id;
    __u32 family;
    __u32 remote_ip4;
    __u32 local_ip4;
    __u32 remote_ip6 [4];
    __u32 local_ip6 [4];
    __u32 remote_port;
    __u32 local_port;
    __u32 data_meta;
    __bpf_md_ptr (struct bpf_flow_keys *, flow_keys);
    __u64 tstamp;
    __u32 wire_len;
    __u32 gso_segs;
    __bpf_md_ptr (struct bpf_sock *, sk);
};



<struct>

struct bpf_tunnel_key {

    __u32 tunnel_id;

    union {

        __u32 remote_ipv4;

        __u32 remote_ipv6 [4];

    };

    __u8 tunnel_tos;

    __u8 tunnel_ttl;

    __u16 tunnel_ext;

    __u32 tunnel_label;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:335:345
StructStr struct bpf_tunnel_key {
    __u32 tunnel_id;
    union {
        __u32 remote_ipv4;
        __u32 remote_ipv6 [4];
    };
    __u8 tunnel_tos;
    __u8 tunnel_ttl;
    __u16 tunnel_ext;
    __u32 tunnel_label;
};



<struct>

struct bpf_xfrm_state {

    __u32 reqid;

    __u32 spi;

    __u16 family;

    __u16 ext;

    union {

        __u32 remote_ipv4;

        __u32 remote_ipv6 [4];

    };

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:349:358
StructStr struct bpf_xfrm_state {
    __u32 reqid;
    __u32 spi;
    __u16 family;
    __u16 ext;
    union {
        __u32 remote_ipv4;
        __u32 remote_ipv6 [4];
    };
};

enum bpf_ret_code {BPF_OK = 0, BPF_DROP = 2, BPF_REDIRECT = 7, BPF_LWT_REROUTE = 128,};



<struct>

struct bpf_sock {

    __u32 bound_dev_if;

    __u32 family;

    __u32 type;

    __u32 protocol;

    __u32 mark;

    __u32 priority;

    __u32 src_ip4;

    __u32 src_ip6 [4];

    __u32 src_port;

    __u32 dst_port;

    __u32 dst_ip4;

    __u32 dst_ip6 [4];

    __u32 state;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:363:377
StructStr struct bpf_sock {
    __u32 bound_dev_if;
    __u32 family;
    __u32 type;
    __u32 protocol;
    __u32 mark;
    __u32 priority;
    __u32 src_ip4;
    __u32 src_ip6 [4];
    __u32 src_port;
    __u32 dst_port;
    __u32 dst_ip4;
    __u32 dst_ip6 [4];
    __u32 state;
};



<struct>

struct bpf_tcp_sock {

    __u32 snd_cwnd;

    __u32 srtt_us;

    __u32 rtt_min;

    __u32 snd_ssthresh;

    __u32 rcv_nxt;

    __u32 snd_nxt;

    __u32 snd_una;

    __u32 mss_cache;

    __u32 ecn_flags;

    __u32 rate_delivered;

    __u32 rate_interval_us;

    __u32 packets_out;

    __u32 retrans_out;

    __u32 total_retrans;

    __u32 segs_in;

    __u32 data_segs_in;

    __u32 segs_out;

    __u32 data_segs_out;

    __u32 lost_out;

    __u32 sacked_out;

    __u64 bytes_received;

    __u64 bytes_acked;

    __u32 dsack_dups;

    __u32 delivered;

    __u32 delivered_ce;

    __u32 icsk_retransmits;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:381:408
StructStr struct bpf_tcp_sock {
    __u32 snd_cwnd;
    __u32 srtt_us;
    __u32 rtt_min;
    __u32 snd_ssthresh;
    __u32 rcv_nxt;
    __u32 snd_nxt;
    __u32 snd_una;
    __u32 mss_cache;
    __u32 ecn_flags;
    __u32 rate_delivered;
    __u32 rate_interval_us;
    __u32 packets_out;
    __u32 retrans_out;
    __u32 total_retrans;
    __u32 segs_in;
    __u32 data_segs_in;
    __u32 segs_out;
    __u32 data_segs_out;
    __u32 lost_out;
    __u32 sacked_out;
    __u64 bytes_received;
    __u64 bytes_acked;
    __u32 dsack_dups;
    __u32 delivered;
    __u32 delivered_ce;
    __u32 icsk_retransmits;
};



<struct>

struct bpf_sock_tuple {

    union {

        struct {

            __be32 saddr;

            __be32 daddr;

            __be16 sport;

            __be16 dport;

        } ipv4;

        struct {

            __be32 saddr [4];

            __be32 daddr [4];

            __be16 sport;

            __be16 dport;

        } ipv6;

    };

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:412:427
StructStr struct bpf_sock_tuple {
    union {
        struct {
            __be32 saddr;
            __be32 daddr;
            __be16 sport;
            __be16 dport;
        } ipv4;
        struct {
            __be32 saddr [4];
            __be32 daddr [4];
            __be16 sport;
            __be16 dport;
        } ipv6;
    };
};



<struct>

struct bpf_xdp_sock {

    __u32 queue_id;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:431:433
StructStr struct bpf_xdp_sock {
    __u32 queue_id;
};

#define XDP_PACKET_HEADROOM 256

enum xdp_action {XDP_ABORTED = 0, XDP_DROP, XDP_PASS, XDP_TX, XDP_REDIRECT,};



<struct>

struct xdp_md {

    __u32 data;

    __u32 data_end;

    __u32 data_meta;

    __u32 ingress_ifindex;

    __u32 rx_queue_index;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:439:445
StructStr struct xdp_md {
    __u32 data;
    __u32 data_end;
    __u32 data_meta;
    __u32 ingress_ifindex;
    __u32 rx_queue_index;
};

enum sk_action {SK_DROP = 0, SK_PASS,};



<struct>

struct sk_msg_md {

    __bpf_md_ptr (void *, data);

    __bpf_md_ptr (void *, data_end);

    __u32 family;

    __u32 remote_ip4;

    __u32 local_ip4;

    __u32 remote_ip6 [4];

    __u32 local_ip6 [4];

    __u32 remote_port;

    __u32 local_port;

    __u32 size;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:450:461
StructStr struct sk_msg_md {
    __bpf_md_ptr (void *, data);
    __bpf_md_ptr (void *, data_end);
    __u32 family;
    __u32 remote_ip4;
    __u32 local_ip4;
    __u32 remote_ip6 [4];
    __u32 local_ip6 [4];
    __u32 remote_port;
    __u32 local_port;
    __u32 size;
};



<struct>

struct sk_reuseport_md {

    __bpf_md_ptr (void *, data);

    __bpf_md_ptr (void *, data_end);

    __u32 len;

    __u32 eth_protocol;

    __u32 ip_protocol;

    __u32 bind_inany;

    __u32 hash;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:465:473
StructStr struct sk_reuseport_md {
    __bpf_md_ptr (void *, data);
    __bpf_md_ptr (void *, data_end);
    __u32 len;
    __u32 eth_protocol;
    __u32 ip_protocol;
    __u32 bind_inany;
    __u32 hash;
};

#define BPF_TAG_SIZE 8



<struct>

struct bpf_prog_info {

    __u32 type;

    __u32 id;

    __u8 tag [BPF_TAG_SIZE];

    __u32 jited_prog_len;

    __u32 xlated_prog_len;

    __aligned_u64 jited_prog_insns;

    __aligned_u64 xlated_prog_insns;

    __u64 load_time;

    __u32 created_by_uid;

    __u32 nr_map_ids;

    __aligned_u64 map_ids;

    char name [BPF_OBJ_NAME_LEN];

    __u32 ifindex;

    __u32 gpl_compatible : 1;

    __u32 : 31;

    __u64 netns_dev;

    __u64 netns_ino;

    __u32 nr_jited_ksyms;

    __u32 nr_jited_func_lens;

    __aligned_u64 jited_ksyms;

    __aligned_u64 jited_func_lens;

    __u32 btf_id;

    __u32 func_info_rec_size;

    __aligned_u64 func_info;

    __u32 nr_func_info;

    __u32 nr_line_info;

    __aligned_u64 line_info;

    __aligned_u64 jited_line_info;

    __u32 nr_jited_line_info;

    __u32 line_info_rec_size;

    __u32 jited_line_info_rec_size;

    __u32 nr_prog_tags;

    __aligned_u64 prog_tags;

    __u64 run_time_ns;

    __u64 run_cnt;

} __attribute__ ((aligned (8)));

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:478:514
StructStr struct bpf_prog_info {
    __u32 type;
    __u32 id;
    __u8 tag [BPF_TAG_SIZE];
    __u32 jited_prog_len;
    __u32 xlated_prog_len;
    __aligned_u64 jited_prog_insns;
    __aligned_u64 xlated_prog_insns;
    __u64 load_time;
    __u32 created_by_uid;
    __u32 nr_map_ids;
    __aligned_u64 map_ids;
    char name [BPF_OBJ_NAME_LEN];
    __u32 ifindex;
    __u32 gpl_compatible : 1;
    __u32 : 31;
    __u64 netns_dev;
    __u64 netns_ino;
    __u32 nr_jited_ksyms;
    __u32 nr_jited_func_lens;
    __aligned_u64 jited_ksyms;
    __aligned_u64 jited_func_lens;
    __u32 btf_id;
    __u32 func_info_rec_size;
    __aligned_u64 func_info;
    __u32 nr_func_info;
    __u32 nr_line_info;
    __aligned_u64 line_info;
    __aligned_u64 jited_line_info;
    __u32 nr_jited_line_info;
    __u32 line_info_rec_size;
    __u32 jited_line_info_rec_size;
    __u32 nr_prog_tags;
    __aligned_u64 prog_tags;
    __u64 run_time_ns;
    __u64 run_cnt;
} __attribute__ ((aligned (8)));



<struct>

struct bpf_map_info {

    __u32 type;

    __u32 id;

    __u32 key_size;

    __u32 value_size;

    __u32 max_entries;

    __u32 map_flags;

    char name [BPF_OBJ_NAME_LEN];

    __u32 ifindex;

    __u32 : 32;

    __u64 netns_dev;

    __u64 netns_ino;

    __u32 btf_id;

    __u32 btf_key_type_id;

    __u32 btf_value_type_id;

} __attribute__ ((aligned (8)));

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:518:533
StructStr struct bpf_map_info {
    __u32 type;
    __u32 id;
    __u32 key_size;
    __u32 value_size;
    __u32 max_entries;
    __u32 map_flags;
    char name [BPF_OBJ_NAME_LEN];
    __u32 ifindex;
    __u32 : 32;
    __u64 netns_dev;
    __u64 netns_ino;
    __u32 btf_id;
    __u32 btf_key_type_id;
    __u32 btf_value_type_id;
} __attribute__ ((aligned (8)));



<struct>

struct bpf_btf_info {

    __aligned_u64 btf;

    __u32 btf_size;

    __u32 id;

} __attribute__ ((aligned (8)));

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:537:541
StructStr struct bpf_btf_info {
    __aligned_u64 btf;
    __u32 btf_size;
    __u32 id;
} __attribute__ ((aligned (8)));



<struct>

struct bpf_sock_addr {

    __u32 user_family;

    __u32 user_ip4;

    __u32 user_ip6 [4];

    __u32 user_port;

    __u32 family;

    __u32 type;

    __u32 protocol;

    __u32 msg_src_ip4;

    __u32 msg_src_ip6 [4];

    __bpf_md_ptr (struct bpf_sock *, sk);

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:545:556
StructStr struct bpf_sock_addr {
    __u32 user_family;
    __u32 user_ip4;
    __u32 user_ip6 [4];
    __u32 user_port;
    __u32 family;
    __u32 type;
    __u32 protocol;
    __u32 msg_src_ip4;
    __u32 msg_src_ip6 [4];
    __bpf_md_ptr (struct bpf_sock *, sk);
};



<struct>

struct bpf_sock_ops {

    __u32 op;

    union {

        __u32 args [4];

        __u32 reply;

        __u32 replylong [4];

    };

    __u32 family;

    __u32 remote_ip4;

    __u32 local_ip4;

    __u32 remote_ip6 [4];

    __u32 local_ip6 [4];

    __u32 remote_port;

    __u32 local_port;

    __u32 is_fullsock;

    __u32 snd_cwnd;

    __u32 srtt_us;

    __u32 bpf_sock_ops_cb_flags;

    __u32 state;

    __u32 rtt_min;

    __u32 snd_ssthresh;

    __u32 rcv_nxt;

    __u32 snd_nxt;

    __u32 snd_una;

    __u32 mss_cache;

    __u32 ecn_flags;

    __u32 rate_delivered;

    __u32 rate_interval_us;

    __u32 packets_out;

    __u32 retrans_out;

    __u32 total_retrans;

    __u32 segs_in;

    __u32 data_segs_in;

    __u32 segs_out;

    __u32 data_segs_out;

    __u32 lost_out;

    __u32 sacked_out;

    __u32 sk_txhash;

    __u64 bytes_received;

    __u64 bytes_acked;

    __bpf_md_ptr (struct bpf_sock *, sk);

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:560:601
StructStr struct bpf_sock_ops {
    __u32 op;
    union {
        __u32 args [4];
        __u32 reply;
        __u32 replylong [4];
    };
    __u32 family;
    __u32 remote_ip4;
    __u32 local_ip4;
    __u32 remote_ip6 [4];
    __u32 local_ip6 [4];
    __u32 remote_port;
    __u32 local_port;
    __u32 is_fullsock;
    __u32 snd_cwnd;
    __u32 srtt_us;
    __u32 bpf_sock_ops_cb_flags;
    __u32 state;
    __u32 rtt_min;
    __u32 snd_ssthresh;
    __u32 rcv_nxt;
    __u32 snd_nxt;
    __u32 snd_una;
    __u32 mss_cache;
    __u32 ecn_flags;
    __u32 rate_delivered;
    __u32 rate_interval_us;
    __u32 packets_out;
    __u32 retrans_out;
    __u32 total_retrans;
    __u32 segs_in;
    __u32 data_segs_in;
    __u32 segs_out;
    __u32 data_segs_out;
    __u32 lost_out;
    __u32 sacked_out;
    __u32 sk_txhash;
    __u64 bytes_received;
    __u64 bytes_acked;
    __bpf_md_ptr (struct bpf_sock *, sk);
};

#define BPF_SOCK_OPS_RTO_CB_FLAG (1 << 0)

#define BPF_SOCK_OPS_RETRANS_CB_FLAG (1 << 1)

#define BPF_SOCK_OPS_STATE_CB_FLAG (1 << 2)

#define BPF_SOCK_OPS_RTT_CB_FLAG (1 << 3)

#define BPF_SOCK_OPS_ALL_CB_FLAGS \

  0xF /* Mask of all currently    \

       * supported cb flags       \

       */

enum {BPF_SOCK_OPS_VOID, BPF_SOCK_OPS_TIMEOUT_INIT, BPF_SOCK_OPS_RWND_INIT, BPF_SOCK_OPS_TCP_CONNECT_CB, BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB, BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB, BPF_SOCK_OPS_NEEDS_ECN, BPF_SOCK_OPS_BASE_RTT, BPF_SOCK_OPS_RTO_CB, BPF_SOCK_OPS_RETRANS_CB, BPF_SOCK_OPS_STATE_CB, BPF_SOCK_OPS_TCP_LISTEN_CB, BPF_SOCK_OPS_RTT_CB,};

enum {BPF_TCP_ESTABLISHED = 1, BPF_TCP_SYN_SENT, BPF_TCP_SYN_RECV, BPF_TCP_FIN_WAIT1, BPF_TCP_FIN_WAIT2, BPF_TCP_TIME_WAIT, BPF_TCP_CLOSE, BPF_TCP_CLOSE_WAIT, BPF_TCP_LAST_ACK, BPF_TCP_LISTEN, BPF_TCP_CLOSING, BPF_TCP_NEW_SYN_RECV, BPF_TCP_MAX_STATES};

#define TCP_BPF_IW 1001 /* Set TCP initial congestion window */

#define TCP_BPF_SNDCWND_CLAMP 1002 /* Set sndcwnd_clamp */



<struct>

struct bpf_perf_event_value {

    __u64 counter;

    __u64 enabled;

    __u64 running;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:617:621
StructStr struct bpf_perf_event_value {
    __u64 counter;
    __u64 enabled;
    __u64 running;
};

#define BPF_DEVCG_ACC_MKNOD (1ULL << 0)

#define BPF_DEVCG_ACC_READ (1ULL << 1)

#define BPF_DEVCG_ACC_WRITE (1ULL << 2)

#define BPF_DEVCG_DEV_BLOCK (1ULL << 0)

#define BPF_DEVCG_DEV_CHAR (1ULL << 1)



<struct>

struct bpf_cgroup_dev_ctx {

    __u32 access_type;

    __u32 major;

    __u32 minor;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:630:634
StructStr struct bpf_cgroup_dev_ctx {
    __u32 access_type;
    __u32 major;
    __u32 minor;
};



<struct>

struct bpf_raw_tracepoint_args {

    __u64 args [0];

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:638:640
StructStr struct bpf_raw_tracepoint_args {
    __u64 args [0];
};

#define BPF_FIB_LOOKUP_DIRECT (1U << 0)

#define BPF_FIB_LOOKUP_OUTPUT (1U << 1)

enum {BPF_FIB_LKUP_RET_SUCCESS, BPF_FIB_LKUP_RET_BLACKHOLE, BPF_FIB_LKUP_RET_UNREACHABLE, BPF_FIB_LKUP_RET_PROHIBIT, BPF_FIB_LKUP_RET_NOT_FWDED, BPF_FIB_LKUP_RET_FWD_DISABLED, BPF_FIB_LKUP_RET_UNSUPP_LWT, BPF_FIB_LKUP_RET_NO_NEIGH, BPF_FIB_LKUP_RET_FRAG_NEEDED,};



<struct>

struct bpf_fib_lookup {

    __u8 family;

    __u8 l4_protocol;

    __be16 sport;

    __be16 dport;

    __u16 tot_len;

    __u32 ifindex;

    union {

        __u8 tos;

        __be32 flowinfo;

        __u32 rt_metric;

    };

    union {

        __be32 ipv4_src;

        __u32 ipv6_src [4];

    };

    union {

        __be32 ipv4_dst;

        __u32 ipv6_dst [4];

    };

    __be16 h_vlan_proto;

    __be16 h_vlan_TCI;

    __u8 smac [6];

    __u8 dmac [6];

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:647:671
StructStr struct bpf_fib_lookup {
    __u8 family;
    __u8 l4_protocol;
    __be16 sport;
    __be16 dport;
    __u16 tot_len;
    __u32 ifindex;
    union {
        __u8 tos;
        __be32 flowinfo;
        __u32 rt_metric;
    };
    union {
        __be32 ipv4_src;
        __u32 ipv6_src [4];
    };
    union {
        __be32 ipv4_dst;
        __u32 ipv6_dst [4];
    };
    __be16 h_vlan_proto;
    __be16 h_vlan_TCI;
    __u8 smac [6];
    __u8 dmac [6];
};

enum bpf_task_fd_type {BPF_FD_TYPE_RAW_TRACEPOINT, BPF_FD_TYPE_TRACEPOINT, BPF_FD_TYPE_KPROBE, BPF_FD_TYPE_KRETPROBE, BPF_FD_TYPE_UPROBE, BPF_FD_TYPE_URETPROBE,};

#define BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG (1U << 0)

#define BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL (1U << 1)

#define BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP (1U << 2)



<struct>

struct bpf_flow_keys {

    __u16 nhoff;

    __u16 thoff;

    __u16 addr_proto;

    __u8 is_frag;

    __u8 is_first_frag;

    __u8 is_encap;

    __u8 ip_proto;

    __be16 n_proto;

    __be16 sport;

    __be16 dport;

    union {

        struct {

            __be32 ipv4_src;

            __be32 ipv4_dst;

        };

        struct {

            __u32 ipv6_src [4];

            __u32 ipv6_dst [4];

        };

    };

    __u32 flags;

    __be32 flow_label;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:679:702
StructStr struct bpf_flow_keys {
    __u16 nhoff;
    __u16 thoff;
    __u16 addr_proto;
    __u8 is_frag;
    __u8 is_first_frag;
    __u8 is_encap;
    __u8 ip_proto;
    __be16 n_proto;
    __be16 sport;
    __be16 dport;
    union {
        struct {
            __be32 ipv4_src;
            __be32 ipv4_dst;
        };
        struct {
            __u32 ipv6_src [4];
            __u32 ipv6_dst [4];
        };
    };
    __u32 flags;
    __be32 flow_label;
};



<struct>

struct bpf_func_info {

    __u32 insn_off;

    __u32 type_id;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:706:709
StructStr struct bpf_func_info {
    __u32 insn_off;
    __u32 type_id;
};

#define BPF_LINE_INFO_LINE_NUM(line_col) ((line_col) >> 10)

#define BPF_LINE_INFO_LINE_COL(line_col) ((line_col)&0x3ff)



<struct>

struct bpf_line_info {

    __u32 insn_off;

    __u32 file_name_off;

    __u32 line_off;

    __u32 line_col;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:715:720
StructStr struct bpf_line_info {
    __u32 insn_off;
    __u32 file_name_off;
    __u32 line_off;
    __u32 line_col;
};



<struct>

struct bpf_spin_lock {

    __u32 val;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:724:726
StructStr struct bpf_spin_lock {
    __u32 val;
};



<struct>

struct bpf_sysctl {

    __u32 write;

    __u32 file_pos;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:730:733
StructStr struct bpf_sysctl {
    __u32 write;
    __u32 file_pos;
};



<struct>

struct bpf_sockopt {

    __bpf_md_ptr (struct bpf_sock *, sk);

    __bpf_md_ptr (void *, optval);

    __bpf_md_ptr (void *, optval_end);

    __s32 level;

    __s32 optname;

    __s32 optlen;

    __s32 retval;

};

</struct>

EXTRACT ->  ./txl_annotate/annotate_struct_test_bpf.h.out:737:745
StructStr struct bpf_sockopt {
    __bpf_md_ptr (struct bpf_sock *, sk);
    __bpf_md_ptr (void *, optval);
    __bpf_md_ptr (void *, optval_end);
    __s32 level;
    __s32 optname;
    __s32 optlen;
    __s32 retval;
};

#endif /* _UAPI__LINUX_BPF_H__ */

Creating preprocessor for:  ./txl_annotate/annotate_func_test_csum_helpers.h.xml
[]
Starting <source file="/home/sayandes/codequery/test/csum_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline __u16 csum_fold_helper (__u64 csum)" startline="30" endline="39">

Creating preprocessor for:  /home/sayandes/codequery/test/csum_helpers.h
string #ifndef exists in file
line Number: 17 #ifndef __CSUM_HELPERS_H

string #ifdef exists in file
line Number: 90 #ifdef GUE_ENCAP

string #endif exists in file
line Number: 337 #endif // of GUE_ENCAP

string #endif exists in file
line Number: 339 #endif // of __CSUM_HELPERS_H

[('#ifdef ', 'GUE_ENCAP', 90, 336), ('#ifndef ', '__CSUM_HELPERS_H', 17, 338)]
['__attribute__ ((__always_inline__)) static inline __u16 csum_fold_helper (__u64 csum) {\n', '    int i;\n', '#pragma unroll\n', '    for (i = 0; i < 4; i++) {\n', '        if (csum >> 16)\n', '            csum = (csum & 0xffff) + (csum >> 16);\n', '    }\n', '    return ~csum;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/csum_helpers.h" funcheader="__attribute__ ((__always_inline__)) static int min_helper (int a, int b)" startline="41" endline="43">

['__attribute__ ((__always_inline__)) static int min_helper (int a, int b) {\n', '    return a < b ? a : b;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/csum_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline void ipv4_csum (void *data_start, int data_size, __u64 *csum)" startline="45" endline="49">

['__attribute__ ((__always_inline__)) static inline void ipv4_csum (void *data_start, int data_size, __u64 *csum) {\n', '    *csum = bpf_csum_diff (0, 0, data_start, data_size, *csum);\n', '    *csum = csum_fold_helper (*csum);\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/csum_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline void ipv4_csum_inline (void *iph, __u64 *csum)" startline="51" endline="60">

['__attribute__ ((__always_inline__)) static inline void ipv4_csum_inline (void *iph, __u64 *csum) {\n', '    __u16 *next_iph_u16 = (__u16 *) iph;\n', '#pragma clang loop unroll(full)\n', '    for (int i = 0; i < sizeof (struct iphdr) >> 1; i++) {\n', '        *csum += *next_iph_u16++;\n', '    }\n', '    *csum = csum_fold_helper (*csum);\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/csum_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline void ipv4_l4_csum (void *data_start, int data_size, __u64 *csum, struct iphdr *iph)" startline="62" endline="73">

['__attribute__ ((__always_inline__)) static inline void ipv4_l4_csum (void *data_start, int data_size, __u64 *csum, struct iphdr *iph) {\n', '    __u32 tmp = 0;\n', '    *csum = bpf_csum_diff (0, 0, &iph->saddr, sizeof (__be32), *csum);\n', '    *csum = bpf_csum_diff (0, 0, &iph->daddr, sizeof (__be32), *csum);\n', '    tmp = __builtin_bswap32 ((__u32) (iph->protocol));\n', '    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);\n', '    tmp = __builtin_bswap32 ((__u32) (data_size));\n', '    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);\n', '    *csum = bpf_csum_diff (0, 0, data_start, data_size, *csum);\n', '    *csum = csum_fold_helper (*csum);\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/csum_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline void ipv6_csum (void *data_start, int data_size, __u64 *csum, struct ipv6hdr *ip6h)" startline="75" endline="88">

['__attribute__ ((__always_inline__)) static inline void ipv6_csum (void *data_start, int data_size, __u64 *csum, struct ipv6hdr *ip6h) {\n', '    __u32 tmp = 0;\n', '    *csum = bpf_csum_diff (0, 0, &ip6h->saddr, sizeof (struct in6_addr), *csum);\n', '    *csum = bpf_csum_diff (0, 0, &ip6h->daddr, sizeof (struct in6_addr), *csum);\n', '    tmp = __builtin_bswap32 ((__u32) (data_size));\n', '    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);\n', '    tmp = __builtin_bswap32 ((__u32) (ip6h->nexthdr));\n', '    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);\n', '    *csum = bpf_csum_diff (0, 0, data_start, data_size, *csum);\n', '    *csum = csum_fold_helper (*csum);\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/csum_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline __s64 add_pseudo_ipv6_header (struct ipv6hdr *ip6h, __u64 *csum)" startline="95" endline="127">

['__attribute__ ((__always_inline__)) static inline __s64 add_pseudo_ipv6_header (struct ipv6hdr *ip6h, __u64 *csum) {\n', '    __s64 ret;\n', '    __u32 tmp = 0;\n', '    ret = bpf_csum_diff (0, 0, &ip6h->saddr, sizeof (struct in6_addr), *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    ret = bpf_csum_diff (0, 0, &ip6h->daddr, sizeof (struct in6_addr), *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    tmp = (__u32) bpf_ntohs (ip6h->payload_len);\n', '    tmp = bpf_htonl (tmp);\n', '    ret = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    tmp = __builtin_bswap32 ((__u32) (ip6h->nexthdr));\n', '    ret = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    return 0;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/csum_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline __s64 rem_pseudo_ipv6_header (struct ipv6hdr *ip6h, __u64 *csum)" startline="129" endline="158">

['__attribute__ ((__always_inline__)) static inline __s64 rem_pseudo_ipv6_header (struct ipv6hdr *ip6h, __u64 *csum) {\n', '    __s64 ret;\n', '    __u32 tmp = 0;\n', '    ret = bpf_csum_diff (&ip6h->saddr, sizeof (struct in6_addr), 0, 0, *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    ret = bpf_csum_diff (&ip6h->daddr, sizeof (struct in6_addr), 0, 0, *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    tmp = (__u32) bpf_ntohs (ip6h->payload_len);\n', '    tmp = bpf_htonl (tmp);\n', '    ret = bpf_csum_diff (&tmp, sizeof (__u32), 0, 0, *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    tmp = __builtin_bswap32 ((__u32) (ip6h->nexthdr));\n', '    ret = bpf_csum_diff (&tmp, sizeof (__u32), 0, 0, *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    return 0;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/csum_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline __s64 add_pseudo_ipv4_header (struct iphdr *iph, __u64 *csum)" startline="160" endline="189">

['__attribute__ ((__always_inline__)) static inline __s64 add_pseudo_ipv4_header (struct iphdr *iph, __u64 *csum) {\n', '    __s64 ret;\n', '    __u32 tmp = 0;\n', '    ret = bpf_csum_diff (0, 0, &iph->saddr, sizeof (__be32), *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    ret = bpf_csum_diff (0, 0, &iph->daddr, sizeof (__be32), *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    tmp = (__u32) bpf_ntohs (iph->tot_len) - sizeof (struct iphdr);\n', '    tmp = bpf_htonl (tmp);\n', '    ret = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    tmp = __builtin_bswap32 ((__u32) (iph->protocol));\n', '    ret = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    return 0;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/csum_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline __s64 rem_pseudo_ipv4_header (struct iphdr *iph, __u64 *csum)" startline="191" endline="220">

['__attribute__ ((__always_inline__)) static inline __s64 rem_pseudo_ipv4_header (struct iphdr *iph, __u64 *csum) {\n', '    __s64 ret;\n', '    __u32 tmp = 0;\n', '    ret = bpf_csum_diff (&iph->saddr, sizeof (__be32), 0, 0, *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    ret = bpf_csum_diff (&iph->daddr, sizeof (__be32), 0, 0, *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    tmp = (__u32) bpf_ntohs (iph->tot_len) - sizeof (struct iphdr);\n', '    tmp = bpf_htonl (tmp);\n', '    ret = bpf_csum_diff (&tmp, sizeof (__u32), 0, 0, *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    tmp = __builtin_bswap32 ((__u32) (iph->protocol));\n', '    ret = bpf_csum_diff (&tmp, sizeof (__u32), 0, 0, *csum);\n', '    if (ret < 0) {\n', '        return ret;\n', '    }\n', '    *csum = ret;\n', '    return 0;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/csum_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline bool gue_csum_v6 (struct ipv6hdr *outer_ip6h, struct udphdr *udph, struct ipv6hdr *inner_ip6h, __u64 *csum_in_hdr)" startline="234" endline="268">

['__attribute__ ((__always_inline__)) static inline bool gue_csum_v6 (struct ipv6hdr *outer_ip6h, struct udphdr *udph, struct ipv6hdr *inner_ip6h, __u64 *csum_in_hdr) {\n', '    __s64 ret;\n', '    __u32 tmp = 0;\n', '    __u32 seed = (~(*csum_in_hdr)) & 0xffff;\n', '    __u32 orig_csum = (__u32) *csum_in_hdr;\n', '    ret = bpf_csum_diff (0, 0, &orig_csum, sizeof (__u32), seed);\n', '    if (ret < 0) {\n', '        return false;\n', '    }\n', '    *csum_in_hdr = ret;\n', '    if (rem_pseudo_ipv6_header (inner_ip6h, csum_in_hdr) < 0) {\n', '        return false;\n', '    }\n', '    ret = bpf_csum_diff (0, 0, inner_ip6h, sizeof (struct ipv6hdr), *csum_in_hdr);\n', '    if (ret < 0) {\n', '        return false;\n', '    }\n', '    *csum_in_hdr = ret;\n', '    ret = bpf_csum_diff (0, 0, udph, sizeof (struct udphdr), *csum_in_hdr);\n', '    if (ret < 0) {\n', '        return false;\n', '    }\n', '    *csum_in_hdr = ret;\n', '    if (add_pseudo_ipv6_header (outer_ip6h, csum_in_hdr) < 0) {\n', '        return false;\n', '    }\n', '    *csum_in_hdr = csum_fold_helper (*csum_in_hdr);\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/csum_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline bool gue_csum_v4 (struct iphdr *outer_iph, struct udphdr *udph, struct iphdr *inner_iph, __u64 *csum_in_hdr)" startline="270" endline="302">

['__attribute__ ((__always_inline__)) static inline bool gue_csum_v4 (struct iphdr *outer_iph, struct udphdr *udph, struct iphdr *inner_iph, __u64 *csum_in_hdr) {\n', '    __s64 ret;\n', '    __u32 tmp = 0;\n', '    __u32 seed = (~(*csum_in_hdr)) & 0xffff;\n', '    __u32 orig_csum = (__u32) *csum_in_hdr;\n', '    ret = bpf_csum_diff (0, 0, &orig_csum, sizeof (__u32), seed);\n', '    if (ret < 0) {\n', '        return false;\n', '    }\n', '    *csum_in_hdr = ret;\n', '    if (rem_pseudo_ipv4_header (inner_iph, csum_in_hdr) < 0) {\n', '        return false;\n', '    }\n', '    ret = bpf_csum_diff (0, 0, inner_iph, sizeof (struct iphdr), *csum_in_hdr);\n', '    if (ret < 0) {\n', '        return false;\n', '    }\n', '    *csum_in_hdr = ret;\n', '    ret = bpf_csum_diff (0, 0, udph, sizeof (struct udphdr), *csum_in_hdr);\n', '    if (ret < 0) {\n', '        return false;\n', '    }\n', '    *csum_in_hdr = ret;\n', '    if (add_pseudo_ipv4_header (outer_iph, csum_in_hdr) < 0) {\n', '        return false;\n', '    }\n', '    *csum_in_hdr = csum_fold_helper (*csum_in_hdr);\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/csum_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline bool gue_csum_v4_in_v6 (struct ipv6hdr *outer_ip6h, struct udphdr *udph, struct iphdr *inner_iph, __u64 *csum_in_hdr)" startline="304" endline="336">

['__attribute__ ((__always_inline__)) static inline bool gue_csum_v4_in_v6 (struct ipv6hdr *outer_ip6h, struct udphdr *udph, struct iphdr *inner_iph, __u64 *csum_in_hdr) {\n', '    __s64 ret;\n', '    __u32 tmp = 0;\n', '    __u32 seed = (~(*csum_in_hdr)) & 0xffff;\n', '    __u32 orig_csum = (__u32) *csum_in_hdr;\n', '    ret = bpf_csum_diff (0, 0, &orig_csum, sizeof (__u32), seed);\n', '    if (ret < 0) {\n', '        return false;\n', '    }\n', '    *csum_in_hdr = ret;\n', '    if (rem_pseudo_ipv4_header (inner_iph, csum_in_hdr) < 0) {\n', '        return false;\n', '    }\n', '    ret = bpf_csum_diff (0, 0, inner_iph, sizeof (struct iphdr), *csum_in_hdr);\n', '    if (ret < 0) {\n', '        return false;\n', '    }\n', '    *csum_in_hdr = ret;\n', '    ret = bpf_csum_diff (0, 0, udph, sizeof (struct udphdr), *csum_in_hdr);\n', '    if (ret < 0) {\n', '        return false;\n', '    }\n', '    *csum_in_hdr = ret;\n', '    if (add_pseudo_ipv6_header (outer_ip6h, csum_in_hdr) < 0) {\n', '        return false;\n', '    }\n', '    *csum_in_hdr = csum_fold_helper (*csum_in_hdr);\n', '    return true;\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_bpf_endian.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_bpf.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_xdp_root.c.xml
[]
Starting <source file="/home/sayandes/codequery/test/xdp_root.c" funcheader="int SEC (\"xdp\") xdp_root (struct xdp_md *ctx)" startline="30" endline="37">

Creating preprocessor for:  /home/sayandes/codequery/test/xdp_root.c
[]
['int SEC ("xdp")\n', 'xdp_root (struct xdp_md *ctx) {\n', '    __u32 *fd;\n', '#pragma clang loop unroll(full)\n', '    for (__u32 i = 0; i < ROOT_ARRAY_SIZE; i++) {\n', '        bpf_tail_call (ctx, & root_array, i);\n', '    }\n', '    return XDP_PASS;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/xdp_root.c" funcheader="int SEC (\"xdp\") xdp_val (struct xdp_md *ctx)" startline="40" endline="47">

['int SEC ("xdp")\n', 'xdp_val (struct xdp_md *ctx) {\n', '    __u32 *fd;\n', '#pragma clang loop unroll(full)\n', '    for (__u32 i = 0; i < ROOT_ARRAY_SIZE; i++) {\n', '        bpf_tail_call (ctx, & root_array, i);\n', '    }\n', '    return XDP_PASS;\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_pckt_encap.h.xml
[]
Starting <source file="/home/sayandes/codequery/test/pckt_encap.h" funcheader="__attribute__ ((__always_inline__)) static inline bool encap_v6 (struct xdp_md *xdp, struct ctl_value *cval, bool is_ipv6, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes)" startline="41" endline="91">

Creating preprocessor for:  /home/sayandes/codequery/test/pckt_encap.h
string #ifndef exists in file
line Number: 17 #ifndef __PCKT_ENCAP_H

string #ifdef exists in file
line Number: 175 #ifdef GUE_ENCAP

string #endif exists in file
line Number: 368 #endif // of GUE_ENCAP

string #ifdef exists in file
line Number: 370 #ifdef INLINE_DECAP_GUE

string #endif exists in file
line Number: 413 #endif // of INLINE_DECAP_GUE

string #endif exists in file
line Number: 415 #endif // of __PCKT_ENCAP_H

[('#ifdef ', 'GUE_ENCAP', 175, 367), ('#ifdef ', 'INLINE_DECAP_GUE', 370, 412), ('#ifndef ', '__PCKT_ENCAP_H', 17, 414)]
['__attribute__ ((__always_inline__)) static inline bool encap_v6 (struct xdp_md *xdp, struct ctl_value *cval, bool is_ipv6, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes) {\n', '    void *data;\n', '    void *data_end;\n', '    struct ipv6hdr *ip6h;\n', '    struct ethhdr *new_eth;\n', '    struct ethhdr *old_eth;\n', '    __u16 payload_len;\n', '    __u32 ip_suffix;\n', '    __u32 saddr [4];\n', '    __u8 proto;\n', '    if (bpf_xdp_adjust_head (xdp, 0 - (int) sizeof (struct ipv6hdr))) {\n', '        return false;\n', '    }\n', '    data = (void *) (long) xdp->data;\n', '    data_end = (void *) (long) xdp->data_end;\n', '    new_eth = data;\n', '    ip6h = data + sizeof (struct ethhdr);\n', '    old_eth = data + sizeof (struct ipv6hdr);\n', '    if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {\n', '        return false;\n', '    }\n', '    memcpy (new_eth -> h_dest, cval -> mac, 6);\n', '    memcpy (new_eth -> h_source, old_eth -> h_dest, 6);\n', '    new_eth->h_proto = BE_ETH_P_IPV6;\n', '    if (is_ipv6) {\n', '        proto = IPPROTO_IPV6;\n', '        ip_suffix = pckt->flow.srcv6[3] ^ pckt->flow.port16[0];\n', '        payload_len = pkt_bytes + sizeof (struct ipv6hdr);\n', '    }\n', '    else {\n', '        proto = IPPROTO_IPIP;\n', '        ip_suffix = pckt->flow.src ^ pckt->flow.port16[0];\n', '        payload_len = pkt_bytes;\n', '    }\n', '    saddr[0] = IPIP_V6_PREFIX1;\n', '    saddr[1] = IPIP_V6_PREFIX2;\n', '    saddr[2] = IPIP_V6_PREFIX3;\n', '    saddr[3] = ip_suffix;\n', '    create_v6_hdr (ip6h, pckt -> tos, saddr, dst -> dstv6, payload_len, proto);\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/pckt_encap.h" funcheader="__attribute__ ((__always_inline__)) static inline bool encap_v4 (struct xdp_md *xdp, struct ctl_value *cval, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes)" startline="93" endline="133">

['__attribute__ ((__always_inline__)) static inline bool encap_v4 (struct xdp_md *xdp, struct ctl_value *cval, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes) {\n', '    void *data;\n', '    void *data_end;\n', '    struct iphdr *iph;\n', '    struct ethhdr *new_eth;\n', '    struct ethhdr *old_eth;\n', '    __u32 ip_suffix = bpf_htons (pckt->flow.port16[0]);\n', '    ip_suffix <<= 16;\n', '    ip_suffix ^= pckt->flow.src;\n', '    if (bpf_xdp_adjust_head (xdp, 0 - (int) sizeof (struct iphdr))) {\n', '        return false;\n', '    }\n', '    data = (void *) (long) xdp->data;\n', '    data_end = (void *) (long) xdp->data_end;\n', '    new_eth = data;\n', '    iph = data + sizeof (struct ethhdr);\n', '    old_eth = data + sizeof (struct iphdr);\n', '    if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {\n', '        return false;\n', '    }\n', '    memcpy (new_eth -> h_dest, cval -> mac, 6);\n', '    memcpy (new_eth -> h_source, old_eth -> h_dest, 6);\n', '    new_eth->h_proto = BE_ETH_P_IP;\n', '    create_v4_hdr (iph, pckt -> tos, ((0xFFFF0000 & ip_suffix) | IPIP_V4_PREFIX), dst -> dst, pkt_bytes, IPPROTO_IPIP);\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/pckt_encap.h" funcheader="__attribute__ ((__always_inline__)) static inline bool decap_v6 (struct xdp_md *xdp, void **data, void **data_end, bool inner_v4)" startline="137" endline="156">

['__attribute__ ((__always_inline__)) static inline bool decap_v6 (struct xdp_md *xdp, void **data, void **data_end, bool inner_v4) {\n', '    struct ethhdr *new_eth;\n', '    struct ethhdr *old_eth;\n', '    old_eth = *data;\n', '    new_eth = *data + sizeof (struct ipv6hdr);\n', '    memcpy (new_eth -> h_source, old_eth -> h_source, 6);\n', '    memcpy (new_eth -> h_dest, old_eth -> h_dest, 6);\n', '    if (inner_v4) {\n', '        new_eth->h_proto = BE_ETH_P_IP;\n', '    }\n', '    else {\n', '        new_eth->h_proto = BE_ETH_P_IPV6;\n', '    }\n', '    if (bpf_xdp_adjust_head (xdp, (int) sizeof (struct ipv6hdr))) {\n', '        return false;\n', '    }\n', '    *data = (void *) (long) xdp->data;\n', '    *data_end = (void *) (long) xdp->data_end;\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/pckt_encap.h" funcheader="__attribute__ ((__always_inline__)) static inline bool decap_v4 (struct xdp_md *xdp, void **data, void **data_end)" startline="158" endline="173">

['__attribute__ ((__always_inline__)) static inline bool decap_v4 (struct xdp_md *xdp, void **data, void **data_end) {\n', '    struct ethhdr *new_eth;\n', '    struct ethhdr *old_eth;\n', '    old_eth = *data;\n', '    new_eth = *data + sizeof (struct iphdr);\n', '    memcpy (new_eth -> h_source, old_eth -> h_source, 6);\n', '    memcpy (new_eth -> h_dest, old_eth -> h_dest, 6);\n', '    new_eth->h_proto = BE_ETH_P_IP;\n', '    if (bpf_xdp_adjust_head (xdp, (int) sizeof (struct iphdr))) {\n', '        return false;\n', '    }\n', '    *data = (void *) (long) xdp->data;\n', '    *data_end = (void *) (long) xdp->data_end;\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/pckt_encap.h" funcheader="__attribute__ ((__always_inline__)) static inline bool gue_csum (void *data, void *data_end, bool outer_v6, bool inner_v6, struct packet_description *pckt, __u64 *csum)" startline="177" endline="249">

['__attribute__ ((__always_inline__)) static inline bool gue_csum (void *data, void *data_end, bool outer_v6, bool inner_v6, struct packet_description *pckt, __u64 *csum) {\n', '    __u16 outer_ip_off;\n', '    __u16 udp_hdr_off;\n', '    __u16 inner_ip_off;\n', '    __u16 inner_transport_off;\n', '    struct udphdr *udph;\n', '    outer_ip_off = sizeof (struct ethhdr);\n', '    udp_hdr_off = outer_v6 ? outer_ip_off + sizeof (struct ipv6hdr) : outer_ip_off + sizeof (struct iphdr);\n', '    inner_ip_off = udp_hdr_off + sizeof (struct udphdr);\n', '    inner_transport_off = inner_v6 ? inner_ip_off + sizeof (struct ipv6hdr) : inner_ip_off + sizeof (struct iphdr);\n', '    if (data + inner_transport_off > data_end) {\n', '        return false;\n', '    }\n', '    if (pckt->flow.proto == IPPROTO_UDP) {\n', '        struct udphdr *inner_udp = data + inner_transport_off;\n', '        if (inner_udp + 1 > data_end) {\n', '            return false;\n', '        }\n', '        *csum = inner_udp->check;\n', '    }\n', '    else if (pckt->flow.proto == IPPROTO_TCP) {\n', '        struct tcphdr *inner_tcp = data + inner_transport_off;\n', '        if (inner_tcp + 1 > data_end) {\n', '            return false;\n', '        }\n', '        *csum = inner_tcp->check;\n', '    }\n', '    else {\n', '        return false;\n', '    }\n', '    if (inner_v6) {\n', '        struct ipv6hdr *outer_ip6h = data + outer_ip_off;\n', '        udph = (void *) data + udp_hdr_off;\n', '        struct ipv6hdr *inner_ip6h = data + inner_ip_off;\n', '        if (outer_ip6h + 1 > data_end || udph + 1 > data_end || inner_ip6h + 1 > data_end) {\n', '            return false;\n', '        }\n', '        return gue_csum_v6 (outer_ip6h, udph, inner_ip6h, csum);\n', '    }\n', '    else {\n', '        if (outer_v6) {\n', '            struct ipv6hdr *outer_ip6h = data + outer_ip_off;\n', '            udph = data + udp_hdr_off;\n', '            struct iphdr *inner_iph = data + inner_ip_off;\n', '            if (outer_ip6h + 1 > data_end || udph + 1 > data_end || inner_iph + 1 > data_end) {\n', '                return false;\n', '            }\n', '            return gue_csum_v4_in_v6 (outer_ip6h, udph, inner_iph, csum);\n', '        }\n', '        else {\n', '            struct iphdr *outer_iph = data + outer_ip_off;\n', '            udph = data + udp_hdr_off;\n', '            struct iphdr *inner_iph = data + inner_ip_off;\n', '            if (outer_iph + 1 > data_end || udph + 1 > data_end || inner_iph + 1 > data_end) {\n', '                return false;\n', '            }\n', '            return gue_csum_v4 (outer_iph, udph, inner_iph, csum);\n', '        }\n', '    }\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/pckt_encap.h" funcheader="__attribute__ ((__always_inline__)) static inline bool gue_encap_v4 (struct xdp_md *xdp, struct ctl_value *cval, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes)" startline="251" endline="307">

['__attribute__ ((__always_inline__)) static inline bool gue_encap_v4 (struct xdp_md *xdp, struct ctl_value *cval, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes) {\n', '    void *data;\n', '    void *data_end;\n', '    struct iphdr *iph;\n', '    struct udphdr *udph;\n', '    struct ethhdr *new_eth;\n', '    struct ethhdr *old_eth;\n', '    struct real_definition *src;\n', '    __u16 sport = bpf_htons (pckt->flow.port16[0]);\n', '    __u32 ipv4_src = V4_SRC_INDEX;\n', '    src = bpf_map_lookup_elem (&pckt_srcs, &ipv4_src);\n', '    if (!src) {\n', '        return false;\n', '    }\n', '    ipv4_src = src->dst;\n', '    sport ^= ((pckt->flow.src >> 16) & 0xFFFF);\n', '    if (bpf_xdp_adjust_head (xdp, 0 - ((int) sizeof (struct iphdr) + (int) sizeof (struct udphdr)))) {\n', '        return false;\n', '    }\n', '    data = (void *) (long) xdp->data;\n', '    data_end = (void *) (long) xdp->data_end;\n', '    new_eth = data;\n', '    iph = data + sizeof (struct ethhdr);\n', '    udph = (void *) iph + sizeof (struct iphdr);\n', '    old_eth = data + sizeof (struct iphdr) + sizeof (struct udphdr);\n', '    if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end || udph + 1 > data_end) {\n', '        return false;\n', '    }\n', '    memcpy (new_eth -> h_dest, cval -> mac, sizeof (new_eth -> h_dest));\n', '    memcpy (new_eth -> h_source, old_eth -> h_dest, sizeof (new_eth -> h_source));\n', '    new_eth->h_proto = BE_ETH_P_IP;\n', '    create_udp_hdr (udph, sport, GUE_DPORT, pkt_bytes + sizeof (struct udphdr), 0);\n', '    create_v4_hdr (iph, pckt -> tos, ipv4_src, dst -> dst, pkt_bytes + sizeof (struct udphdr), IPPROTO_UDP);\n', '    __u64 csum = 0;\n', '    if (gue_csum (data, data_end, false, false, pckt, &csum)) {\n', '        udph->check = csum & 0xFFFF;\n', '    }\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/pckt_encap.h" funcheader="__attribute__ ((__always_inline__)) static inline bool gue_encap_v6 (struct xdp_md *xdp, struct ctl_value *cval, bool is_ipv6, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes)" startline="309" endline="367">

['__attribute__ ((__always_inline__)) static inline bool gue_encap_v6 (struct xdp_md *xdp, struct ctl_value *cval, bool is_ipv6, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes) {\n', '    void *data;\n', '    void *data_end;\n', '    struct ipv6hdr *ip6h;\n', '    struct ethhdr *new_eth;\n', '    struct ethhdr *old_eth;\n', '    struct udphdr *udph;\n', '    __u32 key = V6_SRC_INDEX;\n', '    __u16 payload_len;\n', '    __u16 sport;\n', '    struct real_definition *src;\n', '    src = bpf_map_lookup_elem (&pckt_srcs, &key);\n', '    if (!src) {\n', '        return false;\n', '    }\n', '    if (bpf_xdp_adjust_head (xdp, 0 - ((int) sizeof (struct ipv6hdr) + (int) sizeof (struct udphdr)))) {\n', '        return false;\n', '    }\n', '    data = (void *) (long) xdp->data;\n', '    data_end = (void *) (long) xdp->data_end;\n', '    new_eth = data;\n', '    ip6h = data + sizeof (struct ethhdr);\n', '    udph = (void *) ip6h + sizeof (struct ipv6hdr);\n', '    old_eth = data + sizeof (struct ipv6hdr) + sizeof (struct udphdr);\n', '    if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end || udph + 1 > data_end) {\n', '        return false;\n', '    }\n', '    memcpy (new_eth -> h_dest, cval -> mac, 6);\n', '    memcpy (new_eth -> h_source, old_eth -> h_dest, 6);\n', '    new_eth->h_proto = BE_ETH_P_IPV6;\n', '    if (is_ipv6) {\n', '        sport = (pckt->flow.srcv6[3] & 0xFFFF) ^ pckt->flow.port16[0];\n', '        pkt_bytes += (sizeof (struct ipv6hdr) + sizeof (struct udphdr));\n', '    }\n', '    else {\n', '        sport = ((pckt->flow.src >> 16) & 0xFFFF) ^ pckt->flow.port16[0];\n', '        pkt_bytes += sizeof (struct udphdr);\n', '    }\n', '    create_udp_hdr (udph, sport, GUE_DPORT, pkt_bytes, 0);\n', '    create_v6_hdr (ip6h, pckt -> tos, src -> dstv6, dst -> dstv6, pkt_bytes, IPPROTO_UDP);\n', '    __u64 csum = 0;\n', '    if (gue_csum (data, data_end, true, is_ipv6, pckt, &csum)) {\n', '        udph->check = csum & 0xFFFF;\n', '    }\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/pckt_encap.h" funcheader="__attribute__ ((__always_inline__)) static inline bool gue_decap_v4 (struct xdp_md *xdp, void **data, void **data_end)" startline="372" endline="389">

['__attribute__ ((__always_inline__)) static inline bool gue_decap_v4 (struct xdp_md *xdp, void **data, void **data_end) {\n', '    struct ethhdr *new_eth;\n', '    struct ethhdr *old_eth;\n', '    old_eth = *data;\n', '    new_eth = *data + sizeof (struct iphdr) + sizeof (struct udphdr);\n', '    RECORD_GUE_ROUTE (old_eth, new_eth, * data_end, true, true);\n', '    memcpy (new_eth -> h_source, old_eth -> h_source, 6);\n', '    memcpy (new_eth -> h_dest, old_eth -> h_dest, 6);\n', '    new_eth->h_proto = BE_ETH_P_IP;\n', '    if (bpf_xdp_adjust_head (xdp, (int) (sizeof (struct iphdr) + sizeof (struct udphdr)))) {\n', '        return false;\n', '    }\n', '    *data = (void *) (long) xdp->data;\n', '    *data_end = (void *) (long) xdp->data_end;\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/pckt_encap.h" funcheader="__attribute__ ((__always_inline__)) static inline bool gue_decap_v6 (struct xdp_md *xdp, void **data, void **data_end, bool inner_v4)" startline="391" endline="412">

['__attribute__ ((__always_inline__)) static inline bool gue_decap_v6 (struct xdp_md *xdp, void **data, void **data_end, bool inner_v4) {\n', '    struct ethhdr *new_eth;\n', '    struct ethhdr *old_eth;\n', '    old_eth = *data;\n', '    new_eth = *data + sizeof (struct ipv6hdr) + sizeof (struct udphdr);\n', '    RECORD_GUE_ROUTE (old_eth, new_eth, * data_end, false, inner_v4);\n', '    memcpy (new_eth -> h_source, old_eth -> h_source, 6);\n', '    memcpy (new_eth -> h_dest, old_eth -> h_dest, 6);\n', '    if (inner_v4) {\n', '        new_eth->h_proto = BE_ETH_P_IP;\n', '    }\n', '    else {\n', '        new_eth->h_proto = BE_ETH_P_IPV6;\n', '    }\n', '    if (bpf_xdp_adjust_head (xdp, (int) (sizeof (struct ipv6hdr) + sizeof (struct udphdr)))) {\n', '        return false;\n', '    }\n', '    *data = (void *) (long) xdp->data;\n', '    *data_end = (void *) (long) xdp->data_end;\n', '    return true;\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_healthchecking_structs.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_healthchecking_consts.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_flow_debug_maps.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_healthchecking_maps.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_balancer_kern.c.xml
string #ifdef exists in file
line Number: 34 #ifdef LPM_SRC_LOOKUP

string #ifdef exists in file
line Number: 397 #ifdef INLINE_DECAP_IPIP

string #endif exists in file
line Number: 414 #endif // INLINE_DECAP_IPIP

string #ifdef exists in file
line Number: 424 #ifdef INLINE_DECAP_GUE

string #endif exists in file
line Number: 433 #endif // of INLINE_DECAP_GUE

string #ifdef exists in file
line Number: 459 #ifdef ICMP_TOOBIG_GENERATION

string #ifdef exists in file
line Number: 535 #ifdef TCP_SERVER_ID_ROUTING

string #endif exists in file
line Number: 549 #endif // TCP_SERVER_ID_ROUTING

string #ifdef exists in file
line Number: 553 #ifdef GLOBAL_LRU_LOOKUP

string #endif exists in file
line Number: 560 #endif // GLOBAL_LRU_LOOKUP

string #ifdef exists in file
line Number: 599 #ifdef LOCAL_DELIVERY_OPTIMIZATION

[('#ifdef ', 'INLINE_DECAP_IPIP', 397, 413), ('#ifdef ', 'INLINE_DECAP_GUE', 424, 432), ('#ifdef ', 'TCP_SERVER_ID_ROUTING', 535, 548), ('#ifdef ', 'GLOBAL_LRU_LOOKUP', 553, 559)]
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline bool is_under_flood (__u64 *cur_time)" startline="24" endline="50">

Creating preprocessor for:  /home/sayandes/codequery/test/balancer_kern.c
string #ifdef exists in file
line Number: 70 #ifdef LPM_SRC_LOOKUP

string #ifdef exists in file
line Number: 232 #ifdef INLINE_DECAP_GENERIC

string #endif exists in file
line Number: 257 #endif // of INLINE_DECAP_GENERIC

string #ifdef exists in file
line Number: 259 #ifdef GLOBAL_LRU_LOOKUP

string #endif exists in file
line Number: 337 #endif // GLOBAL_LRU_LOOKUP

string #ifdef exists in file
line Number: 339 #ifdef INLINE_DECAP_IPIP

string #endif exists in file
line Number: 388 #endif // of INLINE_DECAP_IPIP

string #ifdef exists in file
line Number: 390 #ifdef INLINE_DECAP_GUE

string #endif exists in file
line Number: 442 #endif // of INLINE_DECAP_GUE

string #ifdef exists in file
line Number: 504 #ifdef INLINE_DECAP_IPIP

string #endif exists in file
line Number: 547 #endif // INLINE_DECAP_IPIP

string #ifdef exists in file
line Number: 557 #ifdef INLINE_DECAP_GUE

string #endif exists in file
line Number: 566 #endif // of INLINE_DECAP_GUE

string #ifdef exists in file
line Number: 597 #ifdef ICMP_TOOBIG_GENERATION

string #ifdef exists in file
line Number: 685 #ifdef TCP_SERVER_ID_ROUTING

string #endif exists in file
line Number: 706 #endif // TCP_SERVER_ID_ROUTING

string #ifdef exists in file
line Number: 714 #ifdef GLOBAL_LRU_LOOKUP

string #endif exists in file
line Number: 722 #endif // GLOBAL_LRU_LOOKUP

string #ifdef exists in file
line Number: 773 #ifdef LOCAL_DELIVERY_OPTIMIZATION

[('#ifdef ', 'INLINE_DECAP_GENERIC', 232, 256), ('#ifdef ', 'GLOBAL_LRU_LOOKUP', 259, 336), ('#ifdef ', 'INLINE_DECAP_IPIP', 339, 387), ('#ifdef ', 'INLINE_DECAP_GUE', 390, 441), ('#ifdef ', 'INLINE_DECAP_IPIP', 504, 546), ('#ifdef ', 'INLINE_DECAP_GUE', 557, 565), ('#ifdef ', 'TCP_SERVER_ID_ROUTING', 685, 705), ('#ifdef ', 'GLOBAL_LRU_LOOKUP', 714, 721)]
checking containment in:  /home/sayandes/codequery/test/balancer_kern.c start:  24 end:  50
['__attribute__ ((__always_inline__)) static inline bool is_under_flood (__u64 *cur_time) {\n', '    __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;\n', '    struct lb_stats *conn_rate_stats = bpf_map_lookup_elem (&stats, &conn_rate_key);\n', '    if (!conn_rate_stats) {\n', '        return true;\n', '    }\n', '    *cur_time = bpf_ktime_get_ns ();\n', '    if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {\n', '        conn_rate_stats->v1 = 1;\n', '        conn_rate_stats->v2 = *cur_time;\n', '    }\n', '    else {\n', '        conn_rate_stats->v1 += 1;\n', '        if (conn_rate_stats->v1 > MAX_CONN_RATE) {\n', '            return true;\n', '        }\n', '    }\n', '    return false;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline bool get_packet_dst (struct real_definition **real, struct packet_description *pckt, struct vip_meta *vip_info, bool is_ipv6, void *lru_map)" startline="52" endline="131">

checking containment in:  /home/sayandes/codequery/test/balancer_kern.c start:  52 end:  131
['__attribute__ ((__always_inline__)) static inline bool get_packet_dst (struct real_definition **real, struct packet_description *pckt, struct vip_meta *vip_info, bool is_ipv6, void *lru_map) {\n', '    struct real_pos_lru new_dst_lru = {};\n', '    bool under_flood = false;\n', '    bool src_found = false;\n', '    __u32 *real_pos;\n', '    __u64 cur_time = 0;\n', '    __u32 hash;\n', '    __u32 key;\n', '    under_flood = is_under_flood (&cur_time);\n', '#ifdef LPM_SRC_LOOKUP\n', '    if ((vip_info->flags & F_SRC_ROUTING) && !under_flood) {\n', '        __u32 *lpm_val;\n', '        if (is_ipv6) {\n', '            struct v6_lpm_key lpm_key_v6 = {};\n', '            lpm_key_v6.prefixlen = 128;\n', '            memcpy (lpm_key_v6.addr, pckt -> flow.srcv6, 16);\n', '            lpm_val = bpf_map_lookup_elem (&lpm_src_v6, &lpm_key_v6);\n', '        }\n', '        else {\n', '            struct v4_lpm_key lpm_key_v4 = {};\n', '            lpm_key_v4.addr = pckt->flow.src;\n', '            lpm_key_v4.prefixlen = 32;\n', '            lpm_val = bpf_map_lookup_elem (&lpm_src_v4, &lpm_key_v4);\n', '        }\n', '        if (lpm_val) {\n', '            src_found = true;\n', '            key = *lpm_val;\n', '        }\n', '        __u32 stats_key = MAX_VIPS + LPM_SRC_CNTRS;\n', '        struct lb_stats *data_stats = bpf_map_lookup_elem (&stats, &stats_key);\n', '        if (data_stats) {\n', '            if (src_found) {\n', '                data_stats->v2 += 1;\n', '            }\n', '            else {\n', '                data_stats->v1 += 1;\n', '            }\n', '        }\n', '    }\n', '#endif\n', '    if (!src_found) {\n', '        bool hash_16bytes = is_ipv6;\n', '        if (vip_info->flags & F_HASH_DPORT_ONLY) {\n', '            pckt->flow.port16[0] = pckt->flow.port16[1];\n', '            memset (pckt -> flow.srcv6, 0, 16);\n', '        }\n', '        hash = get_packet_hash (pckt, hash_16bytes) % RING_SIZE;\n', '        key = RING_SIZE * (vip_info->vip_num) + hash;\n', '        real_pos = bpf_map_lookup_elem (&ch_rings, &key);\n', '        if (!real_pos) {\n', '            return false;\n', '        }\n', '        key = *real_pos;\n', '    }\n', '    pckt->real_index = key;\n', '    *real = bpf_map_lookup_elem (&reals, &key);\n', '    if (!(*real)) {\n', '        return false;\n', '    }\n', '    if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {\n', '        if (pckt->flow.proto == IPPROTO_UDP) {\n', '            new_dst_lru.atime = cur_time;\n', '        }\n', '        new_dst_lru.pos = key;\n', '        bpf_map_update_elem (lru_map, & pckt -> flow, & new_dst_lru, BPF_ANY);\n', '    }\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline void connection_table_lookup (struct real_definition **real, struct packet_description *pckt, void *lru_map, bool isGlobalLru)" startline="133" endline="156">

checking containment in:  /home/sayandes/codequery/test/balancer_kern.c start:  133 end:  156
['__attribute__ ((__always_inline__)) static inline void connection_table_lookup (struct real_definition **real, struct packet_description *pckt, void *lru_map, bool isGlobalLru) {\n', '    struct real_pos_lru *dst_lru;\n', '    __u64 cur_time;\n', '    __u32 key;\n', '    dst_lru = bpf_map_lookup_elem (lru_map, &pckt->flow);\n', '    if (!dst_lru) {\n', '        return;\n', '    }\n', '    if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {\n', '        cur_time = bpf_ktime_get_ns ();\n', '        if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {\n', '            return;\n', '        }\n', '        dst_lru->atime = cur_time;\n', '    }\n', '    key = dst_lru->pos;\n', '    pckt->real_index = key;\n', '    *real = bpf_map_lookup_elem (&reals, &key);\n', '    return;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline int process_l3_headers (struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes, void *data, void *data_end, bool is_ipv6)" startline="158" endline="230">

['__attribute__ ((__always_inline__)) static inline int process_l3_headers (struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes, void *data, void *data_end, bool is_ipv6) {\n', '    __u64 iph_len;\n', '    int action;\n', '    struct iphdr *iph;\n', '    struct ipv6hdr *ip6h;\n', '    if (is_ipv6) {\n', '        ip6h = data + off;\n', '        if (ip6h + 1 > data_end) {\n', '            return XDP_DROP;\n', '        }\n', '        iph_len = sizeof (struct ipv6hdr);\n', '        *protocol = ip6h->nexthdr;\n', '        pckt->flow.proto = *protocol;\n', '        pckt->tos = (ip6h->priority << 4) & 0xF0;\n', '        pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);\n', '        *pkt_bytes = bpf_ntohs (ip6h->payload_len);\n', '        off += iph_len;\n', '        if (*protocol == IPPROTO_FRAGMENT) {\n', '            return XDP_DROP;\n', '        }\n', '        else if (*protocol == IPPROTO_ICMPV6) {\n', '            action = parse_icmpv6 (data, data_end, off, pckt);\n', '            if (action >= 0) {\n', '                return action;\n', '            }\n', '        }\n', '        else {\n', '            memcpy (pckt -> flow.srcv6, ip6h -> saddr.s6_addr32, 16);\n', '            memcpy (pckt -> flow.dstv6, ip6h -> daddr.s6_addr32, 16);\n', '        }\n', '    }\n', '    else {\n', '        iph = data + off;\n', '        if (iph + 1 > data_end) {\n', '            return XDP_DROP;\n', '        }\n', '        if (iph->ihl != 5) {\n', '            return XDP_DROP;\n', '        }\n', '        pckt->tos = iph->tos;\n', '        *protocol = iph->protocol;\n', '        pckt->flow.proto = *protocol;\n', '        *pkt_bytes = bpf_ntohs (iph->tot_len);\n', '        off += IPV4_HDR_LEN_NO_OPT;\n', '        if (iph->frag_off & PCKT_FRAGMENTED) {\n', '            return XDP_DROP;\n', '        }\n', '        if (*protocol == IPPROTO_ICMP) {\n', '            action = parse_icmp (data, data_end, off, pckt);\n', '            if (action >= 0) {\n', '                return action;\n', '            }\n', '        }\n', '        else {\n', '            pckt->flow.src = iph->saddr;\n', '            pckt->flow.dst = iph->daddr;\n', '        }\n', '    }\n', '    return FURTHER_PROCESSING;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline int check_decap_dst (struct packet_description *pckt, bool is_ipv6, bool *pass)" startline="233" endline="255">

checking containment in:  /home/sayandes/codequery/test/balancer_kern.c start:  233 end:  255
Fully contained  #ifdef  INLINE_DECAP_GENERIC
['__attribute__ ((__always_inline__)) static inline int check_decap_dst (struct packet_description *pckt, bool is_ipv6, bool *pass) {\n', '    struct address dst_addr = {};\n', '    struct lb_stats *data_stats;\n', '    if (is_ipv6) {\n', '        memcpy (dst_addr.addrv6, pckt -> flow.dstv6, 16);\n', '    }\n', '    else {\n', '        dst_addr.addr = pckt->flow.dst;\n', '    }\n', '    __u32 *decap_dst_flags = bpf_map_lookup_elem (&decap_dst, &dst_addr);\n', '    if (decap_dst_flags) {\n', '        *pass = false;\n', '        __u32 stats_key = MAX_VIPS + REMOTE_ENCAP_CNTRS;\n', '        data_stats = bpf_map_lookup_elem (&stats, &stats_key);\n', '        if (!data_stats) {\n', '            return XDP_DROP;\n', '        }\n', '        data_stats->v1 += 1;\n', '    }\n', '    return FURTHER_PROCESSING;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline bool reals_have_same_addr (struct real_definition *a, struct real_definition *b)" startline="261" endline="277">

checking containment in:  /home/sayandes/codequery/test/balancer_kern.c start:  261 end:  277
Fully contained  #ifdef  GLOBAL_LRU_LOOKUP
['__attribute__ ((__always_inline__)) static inline bool reals_have_same_addr (struct real_definition *a, struct real_definition *b) {\n', '    if (a->flags != b->flags) {\n', '        return false;\n', '    }\n', '    if (a->flags & F_IPV6) {\n', '        for (int i = 0; i < 4; i++) {\n', '            if (a->dstv6[i] != b->dstv6[i]) {\n', '                return false;\n', '            }\n', '            return true;\n', '        }\n', '    }\n', '    else {\n', '        return a->dst == b->dst;\n', '    }\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline int perform_global_lru_lookup (struct real_definition **dst, struct packet_description *pckt, __u32 cpu_num, struct vip_meta *vip_info, bool is_ipv6)" startline="279" endline="335">

checking containment in:  /home/sayandes/codequery/test/balancer_kern.c start:  279 end:  335
Fully contained  #ifdef  GLOBAL_LRU_LOOKUP
['__attribute__ ((__always_inline__)) static inline int perform_global_lru_lookup (struct real_definition **dst, struct packet_description *pckt, __u32 cpu_num, struct vip_meta *vip_info, bool is_ipv6) {\n', '    void *g_lru_map = bpf_map_lookup_elem (&global_lru_maps, &cpu_num);\n', '    __u32 global_lru_stats_key = MAX_VIPS + GLOBAL_LRU_CNTR;\n', '    struct lb_stats *global_lru_stats = bpf_map_lookup_elem (&stats, &global_lru_stats_key);\n', '    if (!global_lru_stats) {\n', '        return XDP_DROP;\n', '    }\n', '    if (!g_lru_map) {\n', '        global_lru_stats->v1 += 1;\n', '        g_lru_map = &fallback_glru;\n', '    }\n', '    connection_table_lookup (dst, pckt, g_lru_map, true);\n', '    if (*dst) {\n', '        global_lru_stats->v2 += 1;\n', '        struct real_definition *dst_consistent_hash = NULL;\n', '        if (get_packet_dst (&dst_consistent_hash, pckt, vip_info, is_ipv6, NULL)) {\n', '            __u32 global_lru_mismatch_stats_key = MAX_VIPS + GLOBAL_LRU_MISMATCH_CNTR;\n', '            struct lb_stats *global_lru_mismatch_stats = bpf_map_lookup_elem (&stats, &global_lru_mismatch_stats_key);\n', '            if (dst_consistent_hash && global_lru_mismatch_stats) {\n', '                if (reals_have_same_addr (dst_consistent_hash, *dst)) {\n', '                    global_lru_mismatch_stats->v1++;\n', '                }\n', '                else {\n', '                    global_lru_mismatch_stats->v2++;\n', '                }\n', '            }\n', '        }\n', '    }\n', '    return FURTHER_PROCESSING;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline int process_encaped_ipip_pckt (void **data, void **data_end, struct xdp_md *xdp, bool *is_ipv6, __u8 *protocol, bool pass)" startline="340" endline="387">

['__attribute__ ((__always_inline__)) static inline int process_encaped_ipip_pckt (void **data, void **data_end, struct xdp_md *xdp, bool *is_ipv6, __u8 *protocol, bool pass) {\n', '    int action;\n', '    if (*protocol == IPPROTO_IPIP) {\n', '        if (*is_ipv6) {\n', '            int offset = sizeof (struct ipv6hdr) + sizeof (struct ethhdr);\n', '            if ((*data + offset) > *data_end) {\n', '                return XDP_DROP;\n', '            }\n', '            action = decrement_ttl (*data, *data_end, offset, false);\n', '            if (!decap_v6 (xdp, data, data_end, true)) {\n', '                return XDP_DROP;\n', '            }\n', '            *is_ipv6 = false;\n', '        }\n', '        else {\n', '            int offset = sizeof (struct iphdr) + sizeof (struct ethhdr);\n', '            if ((*data + offset) > *data_end) {\n', '                return XDP_DROP;\n', '            }\n', '            action = decrement_ttl (*data, *data_end, offset, false);\n', '            if (!decap_v4 (xdp, data, data_end)) {\n', '                return XDP_DROP;\n', '            }\n', '        }\n', '    }\n', '    else if (*protocol == IPPROTO_IPV6) {\n', '        int offset = sizeof (struct ipv6hdr) + sizeof (struct ethhdr);\n', '        if ((*data + offset) > *data_end) {\n', '            return XDP_DROP;\n', '        }\n', '        action = decrement_ttl (*data, *data_end, offset, true);\n', '        if (!decap_v6 (xdp, data, data_end, false)) {\n', '            return XDP_DROP;\n', '        }\n', '    }\n', '    if (action >= 0) {\n', '        return action;\n', '    }\n', '    if (pass) {\n', '        return XDP_PASS;\n', '    }\n', '    return recirculate (xdp);\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline int process_encaped_gue_pckt (void **data, void **data_end, struct xdp_md *xdp, bool is_ipv6, bool pass)" startline="391" endline="441">

['__attribute__ ((__always_inline__)) static inline int process_encaped_gue_pckt (void **data, void **data_end, struct xdp_md *xdp, bool is_ipv6, bool pass) {\n', '    int offset = 0;\n', '    int action;\n', '    if (is_ipv6) {\n', '        __u8 v6 = 0;\n', '        offset = sizeof (struct ipv6hdr) + sizeof (struct ethhdr) + sizeof (struct udphdr);\n', '        if ((*data + offset + 1) > *data_end) {\n', '            return XDP_DROP;\n', '        }\n', '        v6 = ((__u8 *) (*data))[offset];\n', '        v6 &= GUEV1_IPV6MASK;\n', '        if (v6) {\n', '            action = decrement_ttl (*data, *data_end, offset, true);\n', '            if (!gue_decap_v6 (xdp, data, data_end, false)) {\n', '                return XDP_DROP;\n', '            }\n', '        }\n', '        else {\n', '            action = decrement_ttl (*data, *data_end, offset, false);\n', '            if (!gue_decap_v6 (xdp, data, data_end, true)) {\n', '                return XDP_DROP;\n', '            }\n', '        }\n', '    }\n', '    else {\n', '        offset = sizeof (struct iphdr) + sizeof (struct ethhdr) + sizeof (struct udphdr);\n', '        if ((*data + offset) > *data_end) {\n', '            return XDP_DROP;\n', '        }\n', '        action = decrement_ttl (*data, *data_end, offset, false);\n', '        if (!gue_decap_v4 (xdp, data, data_end)) {\n', '            return XDP_DROP;\n', '        }\n', '    }\n', '    if (action >= 0) {\n', '        return action;\n', '    }\n', '    if (pass) {\n', '        return XDP_PASS;\n', '    }\n', '    return recirculate (xdp);\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline void increment_quic_cid_version_stats (int host_id)" startline="444" endline="457">

checking containment in:  /home/sayandes/codequery/test/balancer_kern.c start:  444 end:  457
['__attribute__ ((__always_inline__)) static inline void increment_quic_cid_version_stats (int host_id) {\n', '    __u32 quic_version_stats_key = MAX_VIPS + QUIC_CID_VERSION_STATS;\n', '    struct lb_stats *quic_version = bpf_map_lookup_elem (&stats, &quic_version_stats_key);\n', '    if (!quic_version) {\n', '        return;\n', '    }\n', '    if (host_id > QUIC_CONNID_VERSION_V1_MAX_VAL) {\n', '        quic_version->v2 += 1;\n', '    }\n', '    else {\n', '        quic_version->v1 += 1;\n', '    }\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline void increment_quic_cid_drop_no_real ()" startline="459" endline="468">

checking containment in:  /home/sayandes/codequery/test/balancer_kern.c start:  459 end:  468
['__attribute__ ((__always_inline__)) static inline void increment_quic_cid_drop_no_real () {\n', '    __u32 quic_drop_stats_key = MAX_VIPS + QUIC_CID_DROP_STATS;\n', '    struct lb_stats *quic_drop = bpf_map_lookup_elem (&stats, &quic_drop_stats_key);\n', '    if (!quic_drop) {\n', '        return;\n', '    }\n', '    quic_drop->v1 += 1;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline void increment_quic_cid_drop_real_0 ()" startline="470" endline="478">

checking containment in:  /home/sayandes/codequery/test/balancer_kern.c start:  470 end:  478
['__attribute__ ((__always_inline__)) static inline void increment_quic_cid_drop_real_0 () {\n', '    __u32 quic_drop_stats_key = MAX_VIPS + QUIC_CID_DROP_STATS;\n', '    struct lb_stats *quic_drop = bpf_map_lookup_elem (&stats, &quic_drop_stats_key);\n', '    if (!quic_drop) {\n', '        return;\n', '    }\n', '    quic_drop->v2 += 1;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline int process_packet (struct xdp_md *xdp, __u64 off, bool is_ipv6)" startline="480" endline="791">

['__attribute__ ((__always_inline__)) static inline int process_packet (struct xdp_md *xdp, __u64 off, bool is_ipv6) {\n', '    void *data = (void *) (long) xdp->data;\n', '    void *data_end = (void *) (long) xdp->data_end;\n', '    struct ctl_value *cval;\n', '    struct real_definition *dst = NULL;\n', '    struct packet_description pckt = {};\n', '    struct vip_definition vip = {};\n', '    struct vip_meta *vip_info;\n', '    struct lb_stats *data_stats;\n', '    __u64 iph_len;\n', '    __u8 protocol;\n', '    __u16 original_sport;\n', '    int action;\n', '    __u32 vip_num;\n', '    __u32 mac_addr_pos = 0;\n', '    __u16 pkt_bytes;\n', '    action = process_l3_headers (&pckt, &protocol, off, &pkt_bytes, data, data_end, is_ipv6);\n', '    if (action >= 0) {\n', '        return action;\n', '    }\n', '    protocol = pckt.flow.proto;\n', '#ifdef INLINE_DECAP_IPIP\n', '    if (protocol == IPPROTO_IPIP) {\n', '        bool pass = true;\n', '        action = check_decap_dst (&pckt, is_ipv6, &pass);\n', '        if (action >= 0) {\n', '            return action;\n', '        }\n', '        return process_encaped_ipip_pckt (&data, &data_end, xdp, &is_ipv6, &protocol, pass);\n', '    }\n', '    else if (protocol == IPPROTO_IPV6) {\n', '        bool pass = true;\n', '        action = check_decap_dst (&pckt, is_ipv6, &pass);\n', '        if (action >= 0) {\n', '            return action;\n', '        }\n', '        return process_encaped_ipip_pckt (&data, &data_end, xdp, &is_ipv6, &protocol, pass);\n', '    }\n', '#endif // INLINE_DECAP_IPIP\n', '    if (protocol == IPPROTO_TCP) {\n', '        if (!parse_tcp (data, data_end, is_ipv6, &pckt)) {\n', '            return XDP_DROP;\n', '        }\n', '    }\n', '    else if (protocol == IPPROTO_UDP) {\n', '        if (!parse_udp (data, data_end, is_ipv6, &pckt)) {\n', '            return XDP_DROP;\n', '        }\n', '#ifdef INLINE_DECAP_GUE\n', '        if (pckt.flow.port16[1] == bpf_htons (GUE_DPORT)) {\n', '            bool pass = true;\n', '            action = check_decap_dst (&pckt, is_ipv6, &pass);\n', '            if (action >= 0) {\n', '                return action;\n', '            }\n', '            return process_encaped_gue_pckt (&data, &data_end, xdp, is_ipv6, pass);\n', '        }\n', '#endif // of INLINE_DECAP_GUE\n', '    }\n', '    else {\n', '        return XDP_PASS;\n', '    }\n', '    if (is_ipv6) {\n', '        memcpy (vip.vipv6, pckt.flow.dstv6, 16);\n', '    }\n', '    else {\n', '        vip.vip = pckt.flow.dst;\n', '    }\n', '    vip.port = pckt.flow.port16[1];\n', '    vip.proto = pckt.flow.proto;\n', '    vip_info = bpf_map_lookup_elem (&vip_map, &vip);\n', '    if (!vip_info) {\n', '        vip.port = 0;\n', '        vip_info = bpf_map_lookup_elem (&vip_map, &vip);\n', '        if (!vip_info) {\n', '            return XDP_PASS;\n', '        }\n', '        if (!(vip_info->flags & F_HASH_DPORT_ONLY)) {\n', '            pckt.flow.port16[1] = 0;\n', '        }\n', '    }\n', '    if (data_end - data > MAX_PCKT_SIZE) {\n', '        REPORT_PACKET_TOOBIG (xdp, data, data_end - data, false);\n', '#ifdef ICMP_TOOBIG_GENERATION\n', '        __u32 stats_key = MAX_VIPS + ICMP_TOOBIG_CNTRS;\n', '        data_stats = bpf_map_lookup_elem (&stats, &stats_key);\n', '        if (!data_stats) {\n', '            return XDP_DROP;\n', '        }\n', '        if (is_ipv6) {\n', '            data_stats->v2 += 1;\n', '        }\n', '        else {\n', '            data_stats->v1 += 1;\n', '        }\n', '        return send_icmp_too_big (xdp, is_ipv6, data_end -data);\n', '#else\n', '        return XDP_DROP;\n', '#endif\n', '    }\n', '    __u32 stats_key = MAX_VIPS + LRU_CNTRS;\n', '    data_stats = bpf_map_lookup_elem (&stats, &stats_key);\n', '    if (!data_stats) {\n', '        return XDP_DROP;\n', '    }\n', '    data_stats->v1 += 1;\n', '    if ((vip_info->flags & F_QUIC_VIP)) {\n', '        __u32 quic_stats_key = MAX_VIPS + QUIC_ROUTE_STATS;\n', '        struct lb_stats *quic_stats = bpf_map_lookup_elem (&stats, &quic_stats_key);\n', '        if (!quic_stats) {\n', '            return XDP_DROP;\n', '        }\n', '        int real_index;\n', '        real_index = parse_quic (data, data_end, is_ipv6, &pckt);\n', '        if (real_index > 0) {\n', '            increment_quic_cid_version_stats (real_index);\n', '            __u32 key = real_index;\n', '            __u32 *real_pos = bpf_map_lookup_elem (&server_id_map, &key);\n', '            if (real_pos) {\n', '                key = *real_pos;\n', '                if (key == 0) {\n', '                    increment_quic_cid_drop_real_0 ();\n', '                    quic_stats->v1 += 1;\n', '                }\n', '                else {\n', '                    pckt.real_index = key;\n', '                    dst = bpf_map_lookup_elem (&reals, &key);\n', '                    if (!dst) {\n', '                        increment_quic_cid_drop_no_real ();\n', '                        REPORT_QUIC_PACKET_DROP_NO_REAL (xdp, data, data_end - data, false);\n', '                        return XDP_DROP;\n', '                    }\n', '                    quic_stats->v2 += 1;\n', '                }\n', '            }\n', '            else {\n', '                quic_stats->v1 += 1;\n', '            }\n', '        }\n', '        else {\n', '            quic_stats->v1 += 1;\n', '        }\n', '    }\n', '    original_sport = pckt.flow.port16[0];\n', '    if (!dst) {\n', '        if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {\n', '            pckt.flow.port16[0] = 0;\n', '        }\n', '        __u32 cpu_num = bpf_get_smp_processor_id ();\n', '        void *lru_map = bpf_map_lookup_elem (&lru_mapping, &cpu_num);\n', '        if (!lru_map) {\n', '            lru_map = &fallback_cache;\n', '            __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;\n', '            struct lb_stats *lru_stats = bpf_map_lookup_elem (&stats, &lru_stats_key);\n', '            if (!lru_stats) {\n', '                return XDP_DROP;\n', '            }\n', '            lru_stats->v1 += 1;\n', '        }\n', '#ifdef TCP_SERVER_ID_ROUTING\n', '        if (pckt.flow.proto == IPPROTO_TCP && !(pckt.flags & F_SYN_SET)) {\n', '            __u32 routing_stats_key = MAX_VIPS + TCP_SERVER_ID_ROUTE_STATS;\n', '            struct lb_stats *routing_stats = bpf_map_lookup_elem (&stats, &routing_stats_key);\n', '            if (!routing_stats) {\n', '                return XDP_DROP;\n', '            }\n', '            if (tcp_hdr_opt_lookup (xdp, is_ipv6, &dst, &pckt, vip_info->flags & F_LRU_BYPASS, lru_map) == FURTHER_PROCESSING) {\n', '                routing_stats->v1 += 1;\n', '            }\n', '            else {\n', '                routing_stats->v2 += 1;\n', '            }\n', '        }\n', '#endif // TCP_SERVER_ID_ROUTING\n', '        if (!dst && !(pckt.flags & F_SYN_SET) && !(vip_info->flags & F_LRU_BYPASS)) {\n', '            connection_table_lookup (& dst, & pckt, lru_map, false);\n', '        }\n', '#ifdef GLOBAL_LRU_LOOKUP\n', '        if (!dst && !(pckt.flags & F_SYN_SET) && vip_info->flags & F_GLOBAL_LRU) {\n', '            int global_lru_lookup_result = perform_global_lru_lookup (&dst, &pckt, cpu_num, vip_info, is_ipv6);\n', '            if (global_lru_lookup_result >= 0) {\n', '                return global_lru_lookup_result;\n', '            }\n', '        }\n', '#endif // GLOBAL_LRU_LOOKUP\n', '        if (!dst) {\n', '            if (pckt.flow.proto == IPPROTO_TCP) {\n', '                __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;\n', '                struct lb_stats *lru_stats = bpf_map_lookup_elem (&stats, &lru_stats_key);\n', '                if (!lru_stats) {\n', '                    return XDP_DROP;\n', '                }\n', '                if (pckt.flags & F_SYN_SET) {\n', '                    lru_stats->v1 += 1;\n', '                }\n', '                else {\n', '                    REPORT_TCP_NONSYN_LRUMISS (xdp, data, data_end - data, false);\n', '                    lru_stats->v2 += 1;\n', '                }\n', '            }\n', '            if (!get_packet_dst (&dst, &pckt, vip_info, is_ipv6, lru_map)) {\n', '                return XDP_DROP;\n', '            }\n', '            data_stats->v2 += 1;\n', '        }\n', '    }\n', '    cval = bpf_map_lookup_elem (&ctl_array, &mac_addr_pos);\n', '    if (!cval) {\n', '        return XDP_DROP;\n', '    }\n', '    vip_num = vip_info->vip_num;\n', '    data_stats = bpf_map_lookup_elem (&stats, &vip_num);\n', '    if (!data_stats) {\n', '        return XDP_DROP;\n', '    }\n', '    data_stats->v1 += 1;\n', '    data_stats->v2 += pkt_bytes;\n', '    data_stats = bpf_map_lookup_elem (&reals_stats, &pckt.real_index);\n', '    if (!data_stats) {\n', '        return XDP_DROP;\n', '    }\n', '    data_stats->v1 += 1;\n', '    data_stats->v2 += pkt_bytes;\n', '#ifdef LOCAL_DELIVERY_OPTIMIZATION\n', '    if ((vip_info->flags & F_LOCAL_VIP) && (dst->flags & F_LOCAL_REAL)) {\n', '        return XDP_PASS;\n', '    }\n', '#endif\n', '    pckt.flow.port16[0] = original_sport;\n', '    if (dst->flags & F_IPV6) {\n', '        if (!PCKT_ENCAP_V6 (xdp, cval, is_ipv6, &pckt, dst, pkt_bytes)) {\n', '            return XDP_DROP;\n', '        }\n', '    }\n', '    else {\n', '        if (!PCKT_ENCAP_V4 (xdp, cval, &pckt, dst, pkt_bytes)) {\n', '            return XDP_DROP;\n', '        }\n', '    }\n', '    return XDP_TX;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="SEC (\"xdp\") int balancer_ingress (struct xdp_md *ctx)" startline="793" endline="817">

['SEC ("xdp")\n', 'int balancer_ingress (struct xdp_md *ctx) {\n', '    void *data = (void *) (long) ctx->data;\n', '    void *data_end = (void *) (long) ctx->data_end;\n', '    struct ethhdr *eth = data;\n', '    __u32 eth_proto;\n', '    __u32 nh_off;\n', '    nh_off = sizeof (struct ethhdr);\n', '    if (data + nh_off > data_end) {\n', '        return XDP_DROP;\n', '    }\n', '    eth_proto = eth->h_proto;\n', '    if (eth_proto == BE_ETH_P_IP) {\n', '        return process_packet (ctx, nh_off, false);\n', '    }\n', '    else if (eth_proto == BE_ETH_P_IPV6) {\n', '        return process_packet (ctx, nh_off, true);\n', '    }\n', '    else {\n', '        return XDP_PASS;\n', '    }\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline __u32 get_packet_hash (struct packet_description *pckt, bool hash_16bytes)" startline="818" endline="827">

checking containment in:  /home/sayandes/codequery/test/balancer_kern.c start:  818 end:  827
['__attribute__ ((__always_inline__)) static inline __u32 get_packet_hash (struct packet_description *pckt, bool hash_16bytes) {\n', '    if (hash_16bytes) {\n', '        return jhash_2words (jhash (pckt->flow.srcv6, 16, INIT_JHASH_SEED_V6), pckt->flow.ports, INIT_JHASH_SEED);\n', '    }\n', '    else {\n', '        return jhash_2words (pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);\n', '    }\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_handle_icmp.h.xml
[]
Starting <source file="/home/sayandes/codequery/test/handle_icmp.h" funcheader="__attribute__ ((__always_inline__)) static inline int swap_mac_and_send (void *data, void *data_end)" startline="38" endline="48">

Creating preprocessor for:  /home/sayandes/codequery/test/handle_icmp.h
string #ifndef exists in file
line Number: 17 #ifndef __HANDLE_ICMP_H

string #endif exists in file
line Number: 286 #endif // of __HANDLE_ICMP_H

[('#ifndef ', '__HANDLE_ICMP_H', 17, 285)]
['__attribute__ ((__always_inline__)) static inline int swap_mac_and_send (void *data, void *data_end) {\n', '    struct ethhdr *eth;\n', '    unsigned char tmp_mac [ETH_ALEN];\n', '    eth = data;\n', '    memcpy (tmp_mac, eth -> h_source, ETH_ALEN);\n', '    memcpy (eth -> h_source, eth -> h_dest, ETH_ALEN);\n', '    memcpy (eth -> h_dest, tmp_mac, ETH_ALEN);\n', '    return XDP_TX;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/handle_icmp.h" funcheader="__attribute__ ((__always_inline__)) static inline void swap_mac (void *data, struct ethhdr *orig_eth)" startline="50" endline="58">

['__attribute__ ((__always_inline__)) static inline void swap_mac (void *data, struct ethhdr *orig_eth) {\n', '    struct ethhdr *eth;\n', '    eth = data;\n', '    memcpy (eth -> h_source, orig_eth -> h_dest, ETH_ALEN);\n', '    memcpy (eth -> h_dest, orig_eth -> h_source, ETH_ALEN);\n', '    eth->h_proto = orig_eth->h_proto;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/handle_icmp.h" funcheader="__attribute__ ((__always_inline__)) static inline int send_icmp_reply (void *data, void *data_end)" startline="60" endline="90">

['__attribute__ ((__always_inline__)) static inline int send_icmp_reply (void *data, void *data_end) {\n', '    struct iphdr *iph;\n', '    struct icmphdr *icmp_hdr;\n', '    __u32 tmp_addr = 0;\n', '    __u64 csum = 0;\n', '    __u64 off = 0;\n', '    if ((data + sizeof (struct ethhdr) + sizeof (struct iphdr) + sizeof (struct icmphdr)) > data_end) {\n', '        return XDP_DROP;\n', '    }\n', '    off += sizeof (struct ethhdr);\n', '    iph = data + off;\n', '    off += sizeof (struct iphdr);\n', '    icmp_hdr = data + off;\n', '    icmp_hdr->type = ICMP_ECHOREPLY;\n', '    icmp_hdr->checksum += 0x0008;\n', '    iph->ttl = DEFAULT_TTL;\n', '    tmp_addr = iph->daddr;\n', '    iph->daddr = iph->saddr;\n', '    iph->saddr = tmp_addr;\n', '    iph->check = 0;\n', '    ipv4_csum_inline (iph, & csum);\n', '    iph->check = csum;\n', '    return swap_mac_and_send (data, data_end);\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/handle_icmp.h" funcheader="__attribute__ ((__always_inline__)) static inline int send_icmp6_reply (void *data, void *data_end)" startline="92" endline="117">

['__attribute__ ((__always_inline__)) static inline int send_icmp6_reply (void *data, void *data_end) {\n', '    struct ipv6hdr *ip6h;\n', '    struct icmp6hdr *icmp_hdr;\n', '    __be32 tmp_addr [4];\n', '    __u64 off = 0;\n', '    if ((data + sizeof (struct ethhdr) + sizeof (struct ipv6hdr) + sizeof (struct icmp6hdr)) > data_end) {\n', '        return XDP_DROP;\n', '    }\n', '    off += sizeof (struct ethhdr);\n', '    ip6h = data + off;\n', '    off += sizeof (struct ipv6hdr);\n', '    icmp_hdr = data + off;\n', '    icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;\n', '    icmp_hdr->icmp6_cksum -= 0x0001;\n', '    ip6h->hop_limit = DEFAULT_TTL;\n', '    memcpy (tmp_addr, ip6h -> saddr.s6_addr32, 16);\n', '    memcpy (ip6h -> saddr.s6_addr32, ip6h -> daddr.s6_addr32, 16);\n', '    memcpy (ip6h -> daddr.s6_addr32, tmp_addr, 16);\n', '    return swap_mac_and_send (data, data_end);\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/handle_icmp.h" funcheader="__attribute__ ((__always_inline__)) static inline int send_icmp4_too_big (struct xdp_md *xdp)" startline="119" endline="162">

['__attribute__ ((__always_inline__)) static inline int send_icmp4_too_big (struct xdp_md *xdp) {\n', '    int headroom = (int) sizeof (struct iphdr) + (int) sizeof (struct icmphdr);\n', '    if (bpf_xdp_adjust_head (xdp, 0 - headroom)) {\n', '        return XDP_DROP;\n', '    }\n', '    void *data = (void *) (long) xdp->data;\n', '    void *data_end = (void *) (long) xdp->data_end;\n', '    if (data + (ICMP_TOOBIG_SIZE + headroom) > data_end) {\n', '        return XDP_DROP;\n', '    }\n', '    struct iphdr *iph, *orig_iph;\n', '    struct ethhdr *orig_eth;\n', '    struct icmphdr *icmp_hdr;\n', '    __u64 csum = 0;\n', '    __u64 off = 0;\n', '    orig_eth = data + headroom;\n', '    swap_mac (data, orig_eth);\n', '    off += sizeof (struct ethhdr);\n', '    iph = data + off;\n', '    off += sizeof (struct iphdr);\n', '    icmp_hdr = data + off;\n', '    off += sizeof (struct icmphdr);\n', '    orig_iph = data + off;\n', '    icmp_hdr->type = ICMP_DEST_UNREACH;\n', '    icmp_hdr->code = ICMP_FRAG_NEEDED;\n', '    icmp_hdr->un.frag.mtu = bpf_htons (MAX_PCKT_SIZE - sizeof (struct ethhdr));\n', '    icmp_hdr->checksum = 0;\n', '    ipv4_csum (icmp_hdr, ICMP_TOOBIG_PAYLOAD_SIZE, & csum);\n', '    icmp_hdr->checksum = csum;\n', '    iph->ttl = DEFAULT_TTL;\n', '    iph->daddr = orig_iph->saddr;\n', '    iph->saddr = orig_iph->daddr;\n', '    iph->version = 4;\n', '    iph->ihl = 5;\n', '    iph->protocol = IPPROTO_ICMP;\n', '    iph->tos = 0;\n', '    iph->tot_len = bpf_htons (ICMP_TOOBIG_SIZE +headroom - sizeof (struct ethhdr));\n', '    iph->check = 0;\n', '    csum = 0;\n', '    ipv4_csum (iph, sizeof (struct iphdr), & csum);\n', '    iph->check = csum;\n', '    return XDP_TX;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/handle_icmp.h" funcheader="__attribute__ ((__always_inline__)) static inline int send_icmp6_too_big (struct xdp_md *xdp)" startline="164" endline="203">

['__attribute__ ((__always_inline__)) static inline int send_icmp6_too_big (struct xdp_md *xdp) {\n', '    int headroom = (int) sizeof (struct ipv6hdr) + (int) sizeof (struct icmp6hdr);\n', '    if (bpf_xdp_adjust_head (xdp, 0 - headroom)) {\n', '        return XDP_DROP;\n', '    }\n', '    void *data = (void *) (long) xdp->data;\n', '    void *data_end = (void *) (long) xdp->data_end;\n', '    if (data + (ICMP6_TOOBIG_SIZE + headroom) > data_end) {\n', '        return XDP_DROP;\n', '    }\n', '    struct ipv6hdr *ip6h, *orig_ip6h;\n', '    struct ethhdr *orig_eth;\n', '    struct icmp6hdr *icmp6_hdr;\n', '    __u64 csum = 0;\n', '    __u64 off = 0;\n', '    orig_eth = data + headroom;\n', '    swap_mac (data, orig_eth);\n', '    off += sizeof (struct ethhdr);\n', '    ip6h = data + off;\n', '    off += sizeof (struct ipv6hdr);\n', '    icmp6_hdr = data + off;\n', '    off += sizeof (struct icmp6hdr);\n', '    orig_ip6h = data + off;\n', '    ip6h->version = 6;\n', '    ip6h->priority = 0;\n', '    ip6h->nexthdr = IPPROTO_ICMPV6;\n', '    ip6h->hop_limit = DEFAULT_TTL;\n', '    ip6h->payload_len = bpf_htons (ICMP6_TOOBIG_PAYLOAD_SIZE);\n', '    memset (ip6h -> flow_lbl, 0, sizeof (ip6h -> flow_lbl));\n', '    memcpy (ip6h -> daddr.s6_addr32, orig_ip6h -> saddr.s6_addr32, 16);\n', '    memcpy (ip6h -> saddr.s6_addr32, orig_ip6h -> daddr.s6_addr32, 16);\n', '    icmp6_hdr->icmp6_type = ICMPV6_PKT_TOOBIG;\n', '    icmp6_hdr->icmp6_code = 0;\n', '    icmp6_hdr->icmp6_mtu = bpf_htonl (MAX_PCKT_SIZE - sizeof (struct ethhdr));\n', '    icmp6_hdr->icmp6_cksum = 0;\n', '    ipv6_csum (icmp6_hdr, ICMP6_TOOBIG_PAYLOAD_SIZE, & csum, ip6h);\n', '    icmp6_hdr->icmp6_cksum = csum;\n', '    return XDP_TX;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/handle_icmp.h" funcheader="__attribute__ ((__always_inline__)) static inline int send_icmp_too_big (struct xdp_md *xdp, bool is_ipv6, int pckt_size)" startline="205" endline="221">

['__attribute__ ((__always_inline__)) static inline int send_icmp_too_big (struct xdp_md *xdp, bool is_ipv6, int pckt_size) {\n', '    int offset = pckt_size;\n', '    if (is_ipv6) {\n', '        offset -= ICMP6_TOOBIG_SIZE;\n', '    }\n', '    else {\n', '        offset -= ICMP_TOOBIG_SIZE;\n', '    }\n', '    if (bpf_xdp_adjust_tail (xdp, 0 - offset)) {\n', '        return XDP_DROP;\n', '    }\n', '    if (is_ipv6) {\n', '        return send_icmp6_too_big (xdp);\n', '    }\n', '    else {\n', '        return send_icmp4_too_big (xdp);\n', '    }\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/handle_icmp.h" funcheader="__attribute__ ((__always_inline__)) static inline int parse_icmpv6 (void *data, void *data_end, __u64 off, struct packet_description *pckt)" startline="223" endline="253">

['__attribute__ ((__always_inline__)) static inline int parse_icmpv6 (void *data, void *data_end, __u64 off, struct packet_description *pckt) {\n', '    struct icmp6hdr *icmp_hdr;\n', '    struct ipv6hdr *ip6h;\n', '    icmp_hdr = data + off;\n', '    if (icmp_hdr + 1 > data_end) {\n', '        return XDP_DROP;\n', '    }\n', '    if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {\n', '        return send_icmp6_reply (data, data_end);\n', '    }\n', '    if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) && (icmp_hdr->icmp6_type != ICMPV6_DEST_UNREACH)) {\n', '        return XDP_PASS;\n', '    }\n', '    off += sizeof (struct icmp6hdr);\n', '    ip6h = data + off;\n', '    if (ip6h + 1 > data_end) {\n', '        return XDP_DROP;\n', '    }\n', '    pckt->flow.proto = ip6h->nexthdr;\n', '    pckt->flags |= F_ICMP;\n', '    memcpy (pckt -> flow.srcv6, ip6h -> daddr.s6_addr32, 16);\n', '    memcpy (pckt -> flow.dstv6, ip6h -> saddr.s6_addr32, 16);\n', '    return FURTHER_PROCESSING;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/handle_icmp.h" funcheader="__attribute__ ((__always_inline__)) static inline int parse_icmp (void *data, void *data_end, __u64 off, struct packet_description *pckt)" startline="255" endline="285">

['__attribute__ ((__always_inline__)) static inline int parse_icmp (void *data, void *data_end, __u64 off, struct packet_description *pckt) {\n', '    struct icmphdr *icmp_hdr;\n', '    struct iphdr *iph;\n', '    icmp_hdr = data + off;\n', '    if (icmp_hdr + 1 > data_end) {\n', '        return XDP_DROP;\n', '    }\n', '    if (icmp_hdr->type == ICMP_ECHO) {\n', '        return send_icmp_reply (data, data_end);\n', '    }\n', '    if (icmp_hdr->type != ICMP_DEST_UNREACH) {\n', '        return XDP_PASS;\n', '    }\n', '    off += sizeof (struct icmphdr);\n', '    iph = data + off;\n', '    if (iph + 1 > data_end) {\n', '        return XDP_DROP;\n', '    }\n', '    if (iph->ihl != 5) {\n', '        return XDP_DROP;\n', '    }\n', '    pckt->flow.proto = iph->protocol;\n', '    pckt->flags |= F_ICMP;\n', '    pckt->flow.src = iph->daddr;\n', '    pckt->flow.dst = iph->saddr;\n', '    return FURTHER_PROCESSING;\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_decap_maps.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_flow_debug.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_balancer_maps.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_encap_helpers.h.xml
string #ifdef exists in file
line Number: 11 #ifdef COPY_INNER_PACKET_TOS

string #ifdef exists in file
line Number: 28 #ifdef COPY_INNER_PACKET_TOS

[]
Starting <source file="/home/sayandes/codequery/test/encap_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline void create_v4_hdr (struct iphdr *iph, __u8 tos, __u32 saddr, __u32 daddr, __u16 pkt_bytes, __u8 proto)" startline="31" endline="55">

Creating preprocessor for:  /home/sayandes/codequery/test/encap_helpers.h
string #ifndef exists in file
line Number: 17 #ifndef __ENCAP_HELPERS_H

string #ifdef exists in file
line Number: 44 #ifdef COPY_INNER_PACKET_TOS

string #ifdef exists in file
line Number: 66 #ifdef COPY_INNER_PACKET_TOS

string #endif exists in file
line Number: 91 #endif // of __ENCAP_HELPERS_H

[('#ifdef ', 'COPY_INNER_PACKET_TOS', 66, 90)]
['__attribute__ ((__always_inline__)) static inline void create_v4_hdr (struct iphdr *iph, __u8 tos, __u32 saddr, __u32 daddr, __u16 pkt_bytes, __u8 proto) {\n', '    __u64 csum = 0;\n', '    iph->version = 4;\n', '    iph->ihl = 5;\n', '    iph->frag_off = 0;\n', '    iph->protocol = proto;\n', '    iph->check = 0;\n', '#ifdef COPY_INNER_PACKET_TOS\n', '    iph->tos = tos;\n', '#else\n', '    iph->tos = DEFAULT_TOS;\n', '#endif\n', '    iph->tot_len = bpf_htons (pkt_bytes + sizeof (struct iphdr));\n', '    iph->daddr = daddr;\n', '    iph->saddr = saddr;\n', '    iph->ttl = DEFAULT_TTL;\n', '    ipv4_csum_inline (iph, & csum);\n', '    iph->check = csum;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/encap_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline void create_v6_hdr (struct ipv6hdr *ip6h, __u8 tc, __u32 *saddr, __u32 *daddr, __u16 payload_len, __u8 proto)" startline="57" endline="77">

['__attribute__ ((__always_inline__)) static inline void create_v6_hdr (struct ipv6hdr *ip6h, __u8 tc, __u32 *saddr, __u32 *daddr, __u16 payload_len, __u8 proto) {\n', '    ip6h->version = 6;\n', '    memset (ip6h -> flow_lbl, 0, sizeof (ip6h -> flow_lbl));\n', '#ifdef COPY_INNER_PACKET_TOS\n', '    ip6h->priority = (tc & 0xF0) >> 4;\n', '    ip6h->flow_lbl[0] = (tc & 0x0F) << 4;\n', '#else\n', '    ip6h->priority = DEFAULT_TOS;\n', '#endif\n', '    ip6h->nexthdr = proto;\n', '    ip6h->payload_len = bpf_htons (payload_len);\n', '    ip6h->hop_limit = DEFAULT_TTL;\n', '    memcpy (ip6h -> saddr.s6_addr32, saddr, 16);\n', '    memcpy (ip6h -> daddr.s6_addr32, daddr, 16);\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/encap_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline void create_udp_hdr (struct udphdr *udph, __u16 sport, __u16 dport, __u16 len, __u16 csum)" startline="79" endline="89">

['__attribute__ ((__always_inline__)) static inline void create_udp_hdr (struct udphdr *udph, __u16 sport, __u16 dport, __u16 len, __u16 csum) {\n', '    udph->source = sport;\n', '    udph->dest = bpf_htons (dport);\n', '    udph->len = bpf_htons (len);\n', '    udph->check = csum;\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_balancer_helpers.h.xml
[]
Starting <source file="/home/sayandes/codequery/test/balancer_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline void submit_event (struct xdp_md *ctx, void *map, __u32 event_id, void *data, __u32 size, bool metadata_only)" startline="46" endline="70">

Creating preprocessor for:  /home/sayandes/codequery/test/balancer_helpers.h
string #ifndef exists in file
line Number: 17 #ifndef __BALANCER_HELPERS

string #ifdef exists in file
line Number: 42 #ifdef KATRAN_INTROSPECTION

string #ifdef exists in file
line Number: 73 #ifdef INLINE_DECAP_GENERIC

string #endif exists in file
line Number: 81 #endif // of INLINE_DECAP_GENERIC

[('#ifdef ', 'INLINE_DECAP_GENERIC', 73, 80)]
['__attribute__ ((__always_inline__)) static inline void submit_event (struct xdp_md *ctx, void *map, __u32 event_id, void *data, __u32 size, bool metadata_only) {\n', '    struct ctl_value *gk;\n', '    __u32 introspection_gk_pos = 5;\n', '    gk = bpf_map_lookup_elem (&ctl_array, &introspection_gk_pos);\n', '    if (!gk || gk->value == 0) {\n', '        return;\n', '    }\n', '    struct event_metadata md = {};\n', '    __u64 flags = BPF_F_CURRENT_CPU;\n', '    md.event = event_id;\n', '    md.pkt_size = size;\n', '    if (metadata_only) {\n', '        md.data_len = 0;\n', '    }\n', '    else {\n', '        md.data_len = min_helper (size, MAX_EVENT_SIZE);\n', '        flags |= (__u64) md.data_len << 32;\n', '    }\n', '    bpf_perf_event_output (ctx, map, flags, & md, sizeof (struct event_metadata));\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline int recirculate (struct xdp_md *ctx)" startline="74" endline="80">

['__attribute__ ((__always_inline__)) static inline int recirculate (struct xdp_md *ctx) {\n', '    int i = RECIRCULATION_INDEX;\n', '    bpf_tail_call (ctx, & subprograms, i);\n', '    return XDP_PASS;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/balancer_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline int decrement_ttl (void *data, void *data_end, int offset, bool is_ipv6)" startline="83" endline="111">

['__attribute__ ((__always_inline__)) static inline int decrement_ttl (void *data, void *data_end, int offset, bool is_ipv6) {\n', '    struct iphdr *iph;\n', '    struct ipv6hdr *ip6h;\n', '    if (is_ipv6) {\n', '        if ((data + offset + sizeof (struct ipv6hdr)) > data_end) {\n', '            return XDP_DROP;\n', '        }\n', '        ip6h = (struct ipv6hdr *) (data + offset);\n', '        if (!--ip6h->hop_limit) {\n', '            return XDP_DROP;\n', '        }\n', '    }\n', '    else {\n', '        if ((data + offset + sizeof (struct iphdr)) > data_end) {\n', '            return XDP_DROP;\n', '        }\n', '        iph = (struct iphdr *) (data + offset);\n', '        __u32 csum;\n', '        if (!--iph->ttl) {\n', '            return XDP_DROP;\n', '        }\n', '        csum = iph->check + 0x0001;\n', '        iph->check = (csum & 0xffff) + (csum >> 16);\n', '    }\n', '    return FURTHER_PROCESSING;\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_healthchecking_ipip.c.xml
[]
Starting <source file="/home/sayandes/codequery/test/healthchecking_ipip.c" funcheader="SEC (\"tc\") int healthcheck_encap (struct __sk_buff *skb)" startline="88" endline="157">

Creating preprocessor for:  /home/sayandes/codequery/test/healthchecking_ipip.c
string #ifndef exists in file
line Number: 27 #ifndef REALS_MAP_SIZE

string #ifndef exists in file
line Number: 35 #ifndef MAX_PACKET_SIZE

[]
['SEC ("tc")\n', 'int healthcheck_encap (struct __sk_buff *skb) {\n', '    int ret = 0;\n', '    int tun_flag = 0;\n', '    __u32 ifindex;\n', '    __u32 somark = skb->mark;\n', '    __u32 v4_intf_pos = 1;\n', '    __u32 v6_intf_pos = 2;\n', '    struct bpf_tunnel_key tkey = {};\n', '    __u32 stats_key = GENERIC_STATS_INDEX;\n', '    struct hc_stats *prog_stats;\n', '    prog_stats = bpf_map_lookup_elem (&hc_stats_map, &stats_key);\n', '    if (!prog_stats) {\n', '        return TC_ACT_UNSPEC;\n', '    }\n', '    if (skb->mark == 0) {\n', '        prog_stats->pckts_skipped += 1;\n', '        return TC_ACT_UNSPEC;\n', '    }\n', '    struct hc_real_definition *real = bpf_map_lookup_elem (&hc_reals_map, &somark);\n', '    if (!real) {\n', '        prog_stats->pckts_skipped += 1;\n', '        return TC_ACT_UNSPEC;\n', '    }\n', '    if (skb->len > MAX_PACKET_SIZE) {\n', '        prog_stats->pckts_dropped += 1;\n', '        prog_stats->pckts_too_big += 1;\n', '        return TC_ACT_SHOT;\n', '    }\n', '    __u32 *v4_intf_ifindex = bpf_map_lookup_elem (&hc_ctrl_map, &v4_intf_pos);\n', '    if (!v4_intf_ifindex) {\n', '        prog_stats->pckts_dropped += 1;\n', '        return TC_ACT_SHOT;\n', '    }\n', '    __u32 *v6_intf_ifindex = bpf_map_lookup_elem (&hc_ctrl_map, &v6_intf_pos);\n', '    if (!v6_intf_ifindex) {\n', '        prog_stats->pckts_dropped += 1;\n', '        return TC_ACT_SHOT;\n', '    }\n', '    tkey.tunnel_ttl = DEFAULT_TTL;\n', '    skb->mark = 0;\n', '    if (real->flags == V6DADDR) {\n', '        tun_flag = BPF_F_TUNINFO_IPV6;\n', '        memcpy (tkey.remote_ipv6, real -> v6daddr, 16);\n', '        ifindex = *v6_intf_ifindex;\n', '    }\n', '    else {\n', '        tkey.remote_ipv4 = real->daddr;\n', '        ifindex = *v4_intf_ifindex;\n', '    }\n', '    prog_stats->pckts_processed += 1;\n', '    bpf_skb_set_tunnel_key (skb, & tkey, sizeof (tkey), tun_flag);\n', '    return bpf_redirect (ifindex, REDIRECT_EGRESS);\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_healthchecking_helpers.h.xml
[]
Starting <source file="/home/sayandes/codequery/test/healthchecking_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline bool set_hc_key (const struct __sk_buff *skb, struct hc_key *hckey, bool is_ipv6)" startline="37" endline="77">

Creating preprocessor for:  /home/sayandes/codequery/test/healthchecking_helpers.h
string #ifndef exists in file
line Number: 17 #ifndef __HEALTHCHECKING_HELPERS_H

string #endif exists in file
line Number: 215 #endif // of __HEALTHCHECKING_HELPERS_H

[('#ifndef ', '__HEALTHCHECKING_HELPERS_H', 17, 214)]
['__attribute__ ((__always_inline__)) static inline bool set_hc_key (const struct __sk_buff *skb, struct hc_key *hckey, bool is_ipv6) {\n', '    void *iphdr = (void *) (long) skb->data + sizeof (struct ethhdr);\n', '    void *transport_hdr;\n', '    if (is_ipv6) {\n', '        struct ipv6hdr *ip6h = iphdr;\n', '        if (ip6h + 1 > (void *) (long) skb->data_end) {\n', '            return false;\n', '        }\n', '        transport_hdr = iphdr + sizeof (struct ipv6hdr);\n', '        memcpy (hckey -> addrv6, ip6h -> daddr.s6_addr32, 16);\n', '        hckey->proto = ip6h->nexthdr;\n', '    }\n', '    else {\n', '        struct iphdr *iph = iphdr;\n', '        if (iph + 1 > (void *) (long) skb->data_end) {\n', '            return false;\n', '        }\n', '        transport_hdr = iphdr + sizeof (struct iphdr);\n', '        hckey->addr = iph->daddr;\n', '        hckey->proto = iph->protocol;\n', '    }\n', '    if (hckey->proto == IPPROTO_TCP) {\n', '        struct tcphdr *tcp = transport_hdr;\n', '        if (tcp + 1 > (void *) (long) skb->data_end) {\n', '            return false;\n', '        }\n', '        hckey->port = tcp->dest;\n', '    }\n', '    else if (hckey->proto == IPPROTO_UDP) {\n', '        struct udphdr *udp = transport_hdr;\n', '        if (udp + 1 > (void *) (long) skb->data_end) {\n', '            return false;\n', '        }\n', '        hckey->port = udp->dest;\n', '    }\n', '    else {\n', '        return false;\n', '    }\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/healthchecking_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline bool hc_encap_ipip (struct __sk_buff *skb, struct hc_real_definition *real, struct ethhdr *ethh, bool is_ipv6)" startline="79" endline="139">

['__attribute__ ((__always_inline__)) static inline bool hc_encap_ipip (struct __sk_buff *skb, struct hc_real_definition *real, struct ethhdr *ethh, bool is_ipv6) {\n', '    struct hc_real_definition *src;\n', '    __u64 flags = 0;\n', '    __u16 pkt_len;\n', '    int adjust_len;\n', '    __u32 key;\n', '    pkt_len = skb->len - sizeof (struct ethhdr);\n', '    if (real->flags == V6DADDR) {\n', '        __u8 proto = IPPROTO_IPV6;\n', '        key = V6_SRC_INDEX;\n', '        src = bpf_map_lookup_elem (&hc_pckt_srcs_map, &key);\n', '        if (!src) {\n', '            return false;\n', '        }\n', '        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV6;\n', '        adjust_len = sizeof (struct ipv6hdr);\n', '        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {\n', '            return false;\n', '        }\n', '        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct ipv6hdr)) > skb->data_end) {\n', '            return false;\n', '        }\n', '        ethh = (void *) (long) skb->data;\n', '        ethh->h_proto = BE_ETH_P_IPV6;\n', '        struct ipv6hdr *ip6h = (void *) (long) skb->data + sizeof (struct ethhdr);\n', '        if (!is_ipv6) {\n', '            proto = IPPROTO_IPIP;\n', '        }\n', '        create_v6_hdr (ip6h, DEFAULT_TOS, src -> v6daddr, real -> v6daddr, pkt_len, proto);\n', '    }\n', '    else {\n', '        key = V4_SRC_INDEX;\n', '        src = bpf_map_lookup_elem (&hc_pckt_srcs_map, &key);\n', '        if (!src) {\n', '            return false;\n', '        }\n', '        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV4;\n', '        adjust_len = sizeof (struct iphdr);\n', '        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {\n', '            return false;\n', '        }\n', '        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct iphdr)) > skb->data_end) {\n', '            return false;\n', '        }\n', '        struct iphdr *iph = (void *) (long) skb->data + sizeof (struct ethhdr);\n', '        create_v4_hdr (iph, DEFAULT_TOS, src -> daddr, real -> daddr, pkt_len, IPPROTO_IPIP);\n', '    }\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/healthchecking_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline __u16 gue_sport (__u32 seed)" startline="141" endline="143">

['__attribute__ ((__always_inline__)) static inline __u16 gue_sport (__u32 seed) {\n', '    return (__u16) ((seed ^ (seed >> 16)) & 0xFFFF);\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/healthchecking_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline bool hc_encap_gue (struct __sk_buff *skb, struct hc_real_definition *real, struct ethhdr *ethh, bool is_ipv6)" startline="145" endline="213">

['__attribute__ ((__always_inline__)) static inline bool hc_encap_gue (struct __sk_buff *skb, struct hc_real_definition *real, struct ethhdr *ethh, bool is_ipv6) {\n', '    struct hc_real_definition *src;\n', '    __u64 flags = 0;\n', '    __u16 pkt_len;\n', '    __u16 sport;\n', '    int adjust_len;\n', '    __u32 key;\n', '    pkt_len = skb->len - sizeof (struct ethhdr);\n', '    if (real->flags == V6DADDR) {\n', '        sport = gue_sport (real->v6daddr[0] | real->v6daddr[3]);\n', '        __u8 proto = IPPROTO_IPV6;\n', '        key = V6_SRC_INDEX;\n', '        src = bpf_map_lookup_elem (&hc_pckt_srcs_map, &key);\n', '        if (!src) {\n', '            return false;\n', '        }\n', '        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 | BPF_F_ADJ_ROOM_ENCAP_L4_UDP;\n', '        adjust_len = sizeof (struct ipv6hdr) + sizeof (struct udphdr);\n', '        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {\n', '            return false;\n', '        }\n', '        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct ipv6hdr) + sizeof (struct udphdr)) > skb->data_end) {\n', '            return false;\n', '        }\n', '        ethh = (void *) (long) skb->data;\n', '        ethh->h_proto = BE_ETH_P_IPV6;\n', '        struct ipv6hdr *ip6h = (void *) (long) skb->data + sizeof (struct ethhdr);\n', '        struct udphdr *udph = (void *) ip6h + sizeof (struct ipv6hdr);\n', '        pkt_len += sizeof (struct udphdr);\n', '        create_udp_hdr (udph, sport, GUE_DPORT, pkt_len, GUE_CSUM);\n', '        create_v6_hdr (ip6h, DEFAULT_TOS, src -> v6daddr, real -> v6daddr, pkt_len, IPPROTO_UDP);\n', '    }\n', '    else {\n', '        sport = gue_sport (real->daddr);\n', '        key = V4_SRC_INDEX;\n', '        src = bpf_map_lookup_elem (&hc_pckt_srcs_map, &key);\n', '        if (!src) {\n', '            return false;\n', '        }\n', '        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 | BPF_F_ADJ_ROOM_ENCAP_L4_UDP;\n', '        adjust_len = sizeof (struct iphdr) + sizeof (struct udphdr);\n', '        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {\n', '            return false;\n', '        }\n', '        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct iphdr) + sizeof (struct udphdr)) > skb->data_end) {\n', '            return false;\n', '        }\n', '        struct iphdr *iph = (void *) (long) skb->data + sizeof (struct ethhdr);\n', '        struct udphdr *udph = (void *) iph + sizeof (struct iphdr);\n', '        pkt_len += sizeof (struct udphdr);\n', '        create_udp_hdr (udph, sport, GUE_DPORT, pkt_len, GUE_CSUM);\n', '        create_v4_hdr (iph, DEFAULT_TOS, src -> daddr, real -> daddr, pkt_len, IPPROTO_UDP);\n', '    }\n', '    return true;\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_balancer_consts.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_flow_debug_helpers.h.xml
[]
Starting <source file="/home/sayandes/codequery/test/flow_debug_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline __u32 get_next_ports (void *transport_hdr, __u8 proto, void *data_end)" startline="29" endline="53">

Creating preprocessor for:  /home/sayandes/codequery/test/flow_debug_helpers.h
string #ifndef exists in file
line Number: 17 #ifndef __FLOW_DEBUG_HELPERS_H

string #endif exists in file
line Number: 126 #endif // of __FLOW_DEBUG_HELPERS_H

[('#ifndef ', '__FLOW_DEBUG_HELPERS_H', 17, 125)]
['__attribute__ ((__always_inline__)) static inline __u32 get_next_ports (void *transport_hdr, __u8 proto, void *data_end) {\n', '    __u32 ports = 0;\n', '    struct udphdr *udph = 0;\n', '    struct tcphdr *tcph = 0;\n', '    switch (proto) {\n', '    case IPPROTO_UDP :\n', '        udph = transport_hdr;\n', '        if ((void *) udph + sizeof (struct udphdr) <= data_end) {\n', '            ports = (bpf_ntohs (udph->dest) << 16) | bpf_ntohs (udph->source);\n', '        }\n', '        break;\n', '    case IPPROTO_TCP :\n', '        tcph = transport_hdr;\n', '        if ((void *) tcph + sizeof (struct tcphdr) <= data_end) {\n', '            ports = (bpf_ntohs (tcph->dest) << 16) | bpf_ntohs (tcph->source);\n', '        }\n', '        break;\n', '    default :\n', '        break;\n', '    }\n', '    return ports;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/flow_debug_helpers.h" funcheader="__attribute__ ((__always_inline__)) static inline void gue_record_route (struct ethhdr *outer_eth, struct ethhdr *inner_eth, void *data_end, bool outer_v4, bool inner_v4)" startline="55" endline="124">

['__attribute__ ((__always_inline__)) static inline void gue_record_route (struct ethhdr *outer_eth, struct ethhdr *inner_eth, void *data_end, bool outer_v4, bool inner_v4) {\n', '    struct flow_key flow = {0};\n', '    struct flow_debug_info debug_info = {0};\n', '    struct ipv6hdr *ip6h = 0;\n', '    struct iphdr *ip4h = 0;\n', '    void *transport_header = 0;\n', '    __u32 cpu_num = bpf_get_smp_processor_id ();\n', '    void *flow_debug_map = bpf_map_lookup_elem (&flow_debug_maps, &cpu_num);\n', '    if (!flow_debug_map) {\n', '        return;\n', '    }\n', '    if (outer_v4) {\n', '        if ((void *) outer_eth + sizeof (struct ethhdr) + sizeof (struct iphdr) > data_end) {\n', '            return;\n', '        }\n', '        ip4h = (void *) outer_eth + sizeof (struct ethhdr);\n', '        debug_info.l4_hop = ip4h->saddr;\n', '        debug_info.this_hop = ip4h->daddr;\n', '    }\n', '    else {\n', '        if ((void *) outer_eth + sizeof (struct ethhdr) + sizeof (struct ipv6hdr) > data_end) {\n', '            return;\n', '        }\n', '        ip6h = (void *) outer_eth + sizeof (struct ethhdr);\n', '        __builtin_memcpy (debug_info.l4_hopv6, ip6h -> saddr.s6_addr32, sizeof (debug_info.l4_hopv6));\n', '        __builtin_memcpy (debug_info.this_hopv6, ip6h -> daddr.s6_addr32, sizeof (debug_info.this_hopv6));\n', '    }\n', '    if (inner_v4) {\n', '        if ((void *) inner_eth + sizeof (struct ethhdr) + sizeof (struct iphdr) > data_end) {\n', '            return;\n', '        }\n', '        ip4h = (void *) inner_eth + sizeof (struct ethhdr);\n', '        transport_header = (void *) inner_eth + sizeof (struct ethhdr) + sizeof (struct iphdr);\n', '        flow.src = ip4h->saddr;\n', '        flow.dst = ip4h->daddr;\n', '        flow.proto = ip4h->protocol;\n', '        flow.ports = get_next_ports (transport_header, ip4h->protocol, data_end);\n', '    }\n', '    else {\n', '        if ((void *) inner_eth + sizeof (struct ethhdr) + sizeof (struct ipv6hdr) > data_end) {\n', '            return;\n', '        }\n', '        ip6h = (void *) inner_eth + sizeof (struct ethhdr);\n', '        transport_header = (void *) inner_eth + sizeof (struct ethhdr) + sizeof (struct ipv6hdr);\n', '        __builtin_memcpy (flow.srcv6, ip6h -> saddr.s6_addr32, sizeof (flow.srcv6));\n', '        __builtin_memcpy (flow.dstv6, ip6h -> daddr.s6_addr32, sizeof (flow.dstv6));\n', '        flow.proto = ip6h->nexthdr;\n', '        flow.ports = get_next_ports (transport_header, ip6h->nexthdr, data_end);\n', '    }\n', '    bpf_map_update_elem (flow_debug_map, & flow, & debug_info, BPF_ANY);\n', '    return;\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_decap_kern.c.xml
string #ifdef exists in file
line Number: 136 #ifdef INLINE_DECAP_GUE

string #endif exists in file
line Number: 154 #endif // INLINE_DECAP_GUE

[('#ifdef ', 'INLINE_DECAP_GUE', 136, 153)]
Starting <source file="/home/sayandes/codequery/test/decap_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline int process_l3_headers (struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes, void *data, void *data_end, bool is_ipv6)" startline="34" endline="83">

Creating preprocessor for:  /home/sayandes/codequery/test/decap_kern.c
string #ifndef exists in file
line Number: 30 #ifndef DECAP_PROG_SEC

string #ifdef exists in file
line Number: 122 #ifdef INLINE_DECAP_GUE

string #endif exists in file
line Number: 162 #endif // INLINE_DECAP_GUE

string #ifdef exists in file
line Number: 202 #ifdef INLINE_DECAP_GUE

string #endif exists in file
line Number: 219 #endif // INLINE_DECAP_GUE

[('#ifdef ', 'INLINE_DECAP_GUE', 122, 161), ('#ifdef ', 'INLINE_DECAP_GUE', 202, 218)]
['__attribute__ ((__always_inline__)) static inline int process_l3_headers (struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes, void *data, void *data_end, bool is_ipv6) {\n', '    __u64 iph_len;\n', '    struct iphdr *iph;\n', '    struct ipv6hdr *ip6h;\n', '    if (is_ipv6) {\n', '        ip6h = data + off;\n', '        if (ip6h + 1 > data_end) {\n', '            return XDP_DROP;\n', '        }\n', '        iph_len = sizeof (struct ipv6hdr);\n', '        *protocol = ip6h->nexthdr;\n', '        pckt->flow.proto = *protocol;\n', '        *pkt_bytes = bpf_ntohs (ip6h->payload_len);\n', '        off += iph_len;\n', '        if (*protocol == IPPROTO_FRAGMENT) {\n', '            return XDP_DROP;\n', '        }\n', '    }\n', '    else {\n', '        iph = data + off;\n', '        if (iph + 1 > data_end) {\n', '            return XDP_DROP;\n', '        }\n', '        if (iph->ihl != 5) {\n', '            return XDP_DROP;\n', '        }\n', '        *protocol = iph->protocol;\n', '        pckt->flow.proto = *protocol;\n', '        *pkt_bytes = bpf_ntohs (iph->tot_len);\n', '        off += IPV4_HDR_LEN_NO_OPT;\n', '        if (iph->frag_off & PCKT_FRAGMENTED) {\n', '            return XDP_DROP;\n', '        }\n', '    }\n', '    return FURTHER_PROCESSING;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/decap_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline int process_encaped_ipip_pckt (void **data, void **data_end, struct xdp_md *xdp, bool *is_ipv6, struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes)" startline="85" endline="120">

['__attribute__ ((__always_inline__)) static inline int process_encaped_ipip_pckt (void **data, void **data_end, struct xdp_md *xdp, bool *is_ipv6, struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes) {\n', '    if (*protocol == IPPROTO_IPIP) {\n', '        if (*is_ipv6) {\n', '            if ((*data + sizeof (struct ipv6hdr) + sizeof (struct ethhdr)) > *data_end) {\n', '                return XDP_DROP;\n', '            }\n', '            if (!decap_v6 (xdp, data, data_end, true)) {\n', '                return XDP_DROP;\n', '            }\n', '        }\n', '        else {\n', '            if ((*data + sizeof (struct iphdr) + sizeof (struct ethhdr)) > *data_end) {\n', '                return XDP_DROP;\n', '            }\n', '            if (!decap_v4 (xdp, data, data_end)) {\n', '                return XDP_DROP;\n', '            }\n', '        }\n', '    }\n', '    else if (*protocol == IPPROTO_IPV6) {\n', '        if ((*data + sizeof (struct ipv6hdr) + sizeof (struct ethhdr)) > *data_end) {\n', '            return XDP_DROP;\n', '        }\n', '        if (!decap_v6 (xdp, data, data_end, false)) {\n', '            return XDP_DROP;\n', '        }\n', '    }\n', '    return FURTHER_PROCESSING;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/decap_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline int process_encaped_gue_pckt (void **data, void **data_end, struct xdp_md *xdp, bool is_ipv6)" startline="123" endline="161">

['__attribute__ ((__always_inline__)) static inline int process_encaped_gue_pckt (void **data, void **data_end, struct xdp_md *xdp, bool is_ipv6) {\n', '    int offset = 0;\n', '    if (is_ipv6) {\n', '        __u8 v6 = 0;\n', '        offset = sizeof (struct ipv6hdr) + sizeof (struct ethhdr) + sizeof (struct udphdr);\n', '        if ((*data + offset + 1) > *data_end) {\n', '            return XDP_DROP;\n', '        }\n', '        v6 = ((__u8 *) (*data))[offset];\n', '        v6 &= GUEV1_IPV6MASK;\n', '        if (v6) {\n', '            if (!gue_decap_v6 (xdp, data, data_end, false)) {\n', '                return XDP_DROP;\n', '            }\n', '        }\n', '        else {\n', '            if (!gue_decap_v6 (xdp, data, data_end, true)) {\n', '                return XDP_DROP;\n', '            }\n', '        }\n', '    }\n', '    else {\n', '        offset = sizeof (struct iphdr) + sizeof (struct ethhdr) + sizeof (struct udphdr);\n', '        if ((*data + offset) > *data_end) {\n', '            return XDP_DROP;\n', '        }\n', '        if (!gue_decap_v4 (xdp, data, data_end)) {\n', '            return XDP_DROP;\n', '        }\n', '    }\n', '    return FURTHER_PROCESSING;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/decap_kern.c" funcheader="__attribute__ ((__always_inline__)) static inline int process_packet (void *data, __u64 off, void *data_end, bool is_ipv6, struct xdp_md *xdp)" startline="164" endline="221">

['__attribute__ ((__always_inline__)) static inline int process_packet (void *data, __u64 off, void *data_end, bool is_ipv6, struct xdp_md *xdp) {\n', '    struct packet_description pckt = {};\n', '    struct decap_stats *data_stats;\n', '    __u32 key = 0;\n', '    __u8 protocol;\n', '    int action;\n', '    __u16 pkt_bytes;\n', '    action = process_l3_headers (&pckt, &protocol, off, &pkt_bytes, data, data_end, is_ipv6);\n', '    if (action >= 0) {\n', '        return action;\n', '    }\n', '    protocol = pckt.flow.proto;\n', '    data_stats = bpf_map_lookup_elem (&decap_counters, &key);\n', '    if (!data_stats) {\n', '        return XDP_PASS;\n', '    }\n', '    data_stats->total += 1;\n', '    if (protocol == IPPROTO_IPIP || protocol == IPPROTO_IPV6) {\n', '        if (is_ipv6) {\n', '            data_stats->decap_v6 += 1;\n', '        }\n', '        else {\n', '            data_stats->decap_v4 += 1;\n', '        }\n', '        action = process_encaped_ipip_pckt (&data, &data_end, xdp, &is_ipv6, &pckt, &protocol, off, &pkt_bytes);\n', '        if (action >= 0) {\n', '            return action;\n', '        }\n', '    }\n', '#ifdef INLINE_DECAP_GUE\n', '    else if (protocol == IPPROTO_UDP) {\n', '        if (!parse_udp (data, data_end, is_ipv6, &pckt)) {\n', '            return XDP_PASS;\n', '        }\n', '        if (pckt.flow.port16[1] == bpf_htons (GUE_DPORT)) {\n', '            if (is_ipv6) {\n', '                data_stats->decap_v6 += 1;\n', '            }\n', '            else {\n', '                data_stats->decap_v4 += 1;\n', '            }\n', '            action = process_encaped_gue_pckt (&data, &data_end, xdp, is_ipv6);\n', '            if (action >= 0) {\n', '                return action;\n', '            }\n', '        }\n', '    }\n', '#endif // INLINE_DECAP_GUE\n', '    return XDP_PASS;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/decap_kern.c" funcheader="SEC (DECAP_PROG_SEC) int xdpdecap (struct xdp_md *ctx)" startline="223" endline="247">

['SEC (DECAP_PROG_SEC)\n', 'int xdpdecap (struct xdp_md *ctx) {\n', '    void *data = (void *) (long) ctx->data;\n', '    void *data_end = (void *) (long) ctx->data_end;\n', '    struct ethhdr *eth = data;\n', '    __u32 eth_proto;\n', '    __u32 nh_off;\n', '    nh_off = sizeof (struct ethhdr);\n', '    if (data + nh_off > data_end) {\n', '        return XDP_DROP;\n', '    }\n', '    eth_proto = eth->h_proto;\n', '    if (eth_proto == BE_ETH_P_IP) {\n', '        return process_packet (data, nh_off, data_end, false, ctx);\n', '    }\n', '    else if (eth_proto == BE_ETH_P_IPV6) {\n', '        return process_packet (data, nh_off, data_end, true, ctx);\n', '    }\n', '    else {\n', '        return XDP_PASS;\n', '    }\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_jhash.h.xml
[]
Starting <source file="/home/sayandes/codequery/test/jhash.h" funcheader="static inline __u32 rol32 (__u32 word, unsigned int shift)" startline="7" endline="9">

Creating preprocessor for:  /home/sayandes/codequery/test/jhash.h
string #ifndef exists in file
line Number: 1 #ifndef _JHASH_KERNEL_

[]
['static inline __u32 rol32 (__u32 word, unsigned int shift) {\n', '    return (word << shift) | (word >> ((-shift) & 31));\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/jhash.h" funcheader="static inline u32 jhash (const void *key, u32 length, u32 initval)" startline="55" endline="100">

['static inline u32 jhash (const void *key, u32 length, u32 initval) {\n', '    u32 a, b, c;\n', '    const unsigned char *k = key;\n', '    a = b = c = JHASH_INITVAL + length + initval;\n', '    while (length > 12) {\n', '        a += *(u32*) (k);\n', '        b += *(u32*) (k + 4);\n', '        c += *(u32*) (k + 8);\n', '        __jhash_mix (a, b, c);\n', '        length -= 12;\n', '        k += 12;\n', '    }\n', '    switch (length) {\n', '    case 12 :\n', '        c += (u32) k[11] << 24;\n', '    case 11 :\n', '        c += (u32) k[10] << 16;\n', '    case 10 :\n', '        c += (u32) k[9] << 8;\n', '    case 9 :\n', '        c += k[8];\n', '    case 8 :\n', '        b += (u32) k[7] << 24;\n', '    case 7 :\n', '        b += (u32) k[6] << 16;\n', '    case 6 :\n', '        b += (u32) k[5] << 8;\n', '    case 5 :\n', '        b += k[4];\n', '    case 4 :\n', '        a += (u32) k[3] << 24;\n', '    case 3 :\n', '        a += (u32) k[2] << 16;\n', '    case 2 :\n', '        a += (u32) k[1] << 8;\n', '    case 1 :\n', '        a += k[0];\n', '        __jhash_final (a, b, c);\n', '    case 0 :\n', '        break;\n', '    }\n', '    return c;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/jhash.h" funcheader="static inline u32 __jhash_nwords (u32 a, u32 b, u32 c, u32 initval)" startline="102" endline="108">

['static inline u32 __jhash_nwords (u32 a, u32 b, u32 c, u32 initval) {\n', '    a += initval;\n', '    b += initval;\n', '    c += initval;\n', '    __jhash_final (a, b, c);\n', '    return c;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/jhash.h" funcheader="static inline u32 jhash_2words (u32 a, u32 b, u32 initval)" startline="110" endline="112">

['static inline u32 jhash_2words (u32 a, u32 b, u32 initval) {\n', '    return __jhash_nwords (a, b, 0, initval +JHASH_INITVAL + (2 << 2));\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/jhash.h" funcheader="static inline u32 jhash_1word (u32 a, u32 initval)" startline="114" endline="116">

['static inline u32 jhash_1word (u32 a, u32 initval) {\n', '    return __jhash_nwords (a, 0, 0, initval +JHASH_INITVAL + (1 << 2));\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_bpf_helpers.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_xdp_pktcntr.c.xml
[]
Starting <source file="/home/sayandes/codequery/test/xdp_pktcntr.c" funcheader="SEC (\"xdp\") int pktcntr (struct xdp_md *ctx)" startline="45" endline="62">

Creating preprocessor for:  /home/sayandes/codequery/test/xdp_pktcntr.c
[]
['SEC ("xdp")\n', 'int pktcntr (struct xdp_md *ctx) {\n', '    void *data_end = (void *) (long) ctx->data_end;\n', '    void *data = (void *) (long) ctx->data;\n', '    __u32 ctl_flag_pos = 0;\n', '    __u32 cntr_pos = 0;\n', '    __u32 *flag = bpf_map_lookup_elem (&ctl_array, &ctl_flag_pos);\n', '    if (!flag || (*flag == 0)) {\n', '        return XDP_PASS;\n', '    }\n', '    __u64 *cntr_val = bpf_map_lookup_elem (&cntrs_array, &cntr_pos);\n', '    if (cntr_val) {\n', '        *cntr_val += 1;\n', '    }\n', '    return XDP_PASS;\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_x.c.xml
[]
Starting <source file="/home/sayandes/codequery/test/x.c" funcheader="SEC (\"xdp\") int xdp_prog_simple (struct xdp_md *ctx)" startline="8" endline="13">

Creating preprocessor for:  /home/sayandes/codequery/test/x.c
[]
['SEC ("xdp")\n', 'int xdp_prog_simple (struct xdp_md *ctx) {\n', '    return xdpdecap (ctx);\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_balancer_structs.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_control_data_maps.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_introspection.h.xml
[]
Creating preprocessor for:  ./txl_annotate/annotate_func_test_healthchecking_kern.c.xml
string #if exists in file
line Number: 31 #if HC_MAX_PACKET_SIZE > 0

[]
Starting <source file="/home/sayandes/codequery/test/healthchecking_kern.c" funcheader="SEC (\"tc\") int healthcheck_encap (struct __sk_buff *skb)" startline="33" endline="139">

Creating preprocessor for:  /home/sayandes/codequery/test/healthchecking_kern.c
string #if exists in file
line Number: 64 #if HC_MAX_PACKET_SIZE > 0

[]
['SEC ("tc")\n', 'int healthcheck_encap (struct __sk_buff *skb) {\n', '    __u32 stats_key = GENERIC_STATS_INDEX;\n', '    __u32 key = HC_MAIN_INTF_POSITION;\n', '    __u32 somark = skb->mark;\n', '    __u32 ifindex = 0;\n', '    __u64 flags = 0;\n', '    bool is_ipv6 = false;\n', '    int adjust_len = 0;\n', '    int ret = 0;\n', '    struct hc_stats *prog_stats;\n', '    struct ethhdr *ethh;\n', '    struct hc_mac *esrc, *edst;\n', '    struct hc_real_definition *src;\n', '    prog_stats = bpf_map_lookup_elem (&hc_stats_map, &stats_key);\n', '    if (!prog_stats) {\n', '        return TC_ACT_UNSPEC;\n', '    }\n', '    if (somark == 0) {\n', '        prog_stats->pckts_skipped += 1;\n', '        return TC_ACT_UNSPEC;\n', '    }\n', '    struct hc_real_definition *real = bpf_map_lookup_elem (&hc_reals_map, &somark);\n', '    if (!real) {\n', '        prog_stats->pckts_skipped += 1;\n', '        return TC_ACT_UNSPEC;\n', '    }\n', '#if HC_MAX_PACKET_SIZE > 0\n', '    if (skb->len > HC_MAX_PACKET_SIZE) {\n', '        prog_stats->pckts_dropped += 1;\n', '        prog_stats->pckts_too_big += 1;\n', '        return TC_ACT_SHOT;\n', '    }\n', '#endif\n', '    __u32 *intf_ifindex = bpf_map_lookup_elem (&hc_ctrl_map, &key);\n', '    if (!intf_ifindex) {\n', '        prog_stats->pckts_dropped += 1;\n', '        return TC_ACT_SHOT;\n', '    }\n', '    key = HC_SRC_MAC_POS;\n', '    esrc = bpf_map_lookup_elem (&hc_pckt_macs, &key);\n', '    if (!esrc) {\n', '        prog_stats->pckts_dropped += 1;\n', '        return TC_ACT_SHOT;\n', '    }\n', '    key = HC_DST_MAC_POS;\n', '    edst = bpf_map_lookup_elem (&hc_pckt_macs, &key);\n', '    if (!edst) {\n', '        prog_stats->pckts_dropped += 1;\n', '        return TC_ACT_SHOT;\n', '    }\n', '    if ((skb->data + sizeof (struct ethhdr)) > skb->data_end) {\n', '        prog_stats->pckts_dropped += 1;\n', '        return TC_ACT_SHOT;\n', '    }\n', '    ethh = (void *) (long) skb->data;\n', '    if (ethh->h_proto == BE_ETH_P_IPV6) {\n', '        is_ipv6 = true;\n', '    }\n', '    struct hc_key hckey = {};\n', '    bool hc_key_parseable = set_hc_key (skb, &hckey, is_ipv6);\n', '    skb->mark = 0;\n', '    if (!HC_ENCAP (skb, real, ethh, is_ipv6)) {\n', '        prog_stats->pckts_dropped += 1;\n', '        return TC_ACT_SHOT;\n', '    }\n', '    if (skb->data + sizeof (struct ethhdr) > skb->data_end) {\n', '        prog_stats->pckts_dropped += 1;\n', '        return TC_ACT_SHOT;\n', '    }\n', '    ethh = (void *) (long) skb->data;\n', '    memcpy (ethh -> h_source, esrc -> mac, 6);\n', '    memcpy (ethh -> h_dest, edst -> mac, 6);\n', '    prog_stats->pckts_processed += 1;\n', '    if (hc_key_parseable) {\n', '        __u32 *hc_key_cntr_index = bpf_map_lookup_elem (&hc_key_map, &hckey);\n', '        if (hc_key_cntr_index) {\n', '            __u32 *packets_processed_for_hc_key = bpf_map_lookup_elem (&per_hckey_stats, hc_key_cntr_index);\n', '            if (packets_processed_for_hc_key) {\n', '                *packets_processed_for_hc_key += 1;\n', '            }\n', '        }\n', '    }\n', '    return bpf_redirect (*intf_ifindex, REDIRECT_EGRESS);\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_pckt_parsing.h.xml
string #if exists in file
line Number: 128 #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0) || \

[]
Starting <source file="/home/sayandes/codequery/test/pckt_parsing.h" funcheader="__attribute__ ((__always_inline__)) static inline __u64 calc_offset (bool is_ipv6, bool is_icmp)" startline="58" endline="74">

Creating preprocessor for:  /home/sayandes/codequery/test/pckt_parsing.h
string #ifndef exists in file
line Number: 17 #ifndef __PCKT_PARSING_H

string #ifdef exists in file
line Number: 138 #ifdef TCP_SERVER_ID_ROUTING

string #ifdef exists in file
line Number: 139 #ifdef TCP_HDR_OPT_SKIP_UNROLL_LOOP

string #if exists in file
line Number: 227 #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0) || \

string #endif exists in file
line Number: 274 #endif // TCP_SERVER_ID_ROUTING

string #endif exists in file
line Number: 337 #endif // of  __PCKT_PARSING_H

[('#if ', 'LINUX_VERSION_CODE', 227, 273), ('#ifdef ', 'TCP_HDR_OPT_SKIP_UNROLL_LOOP', 139, 336)]
['__attribute__ ((__always_inline__)) static inline __u64 calc_offset (bool is_ipv6, bool is_icmp) {\n', '    __u64 off = sizeof (struct ethhdr);\n', '    if (is_ipv6) {\n', '        off += sizeof (struct ipv6hdr);\n', '        if (is_icmp) {\n', '            off += (sizeof (struct icmp6hdr) + sizeof (struct ipv6hdr));\n', '        }\n', '    }\n', '    else {\n', '        off += sizeof (struct iphdr);\n', '        if (is_icmp) {\n', '            off += (sizeof (struct icmphdr) + sizeof (struct iphdr));\n', '        }\n', '    }\n', '    return off;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/pckt_parsing.h" funcheader="__attribute__ ((__always_inline__)) static inline bool parse_udp (void *data, void *data_end, bool is_ipv6, struct packet_description *pckt)" startline="76" endline="100">

['__attribute__ ((__always_inline__)) static inline bool parse_udp (void *data, void *data_end, bool is_ipv6, struct packet_description *pckt) {\n', '    bool is_icmp = !((pckt->flags & F_ICMP) == 0);\n', '    __u64 off = calc_offset (is_ipv6, is_icmp);\n', '    struct udphdr *udp;\n', '    udp = data + off;\n', '    if (udp + 1 > data_end) {\n', '        return false;\n', '    }\n', '    if (!is_icmp) {\n', '        pckt->flow.port16[0] = udp->source;\n', '        pckt->flow.port16[1] = udp->dest;\n', '    }\n', '    else {\n', '        pckt->flow.port16[0] = udp->dest;\n', '        pckt->flow.port16[1] = udp->source;\n', '    }\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/pckt_parsing.h" funcheader="__attribute__ ((__always_inline__)) static inline bool parse_tcp (void *data, void *data_end, bool is_ipv6, struct packet_description *pckt)" startline="102" endline="130">

['__attribute__ ((__always_inline__)) static inline bool parse_tcp (void *data, void *data_end, bool is_ipv6, struct packet_description *pckt) {\n', '    bool is_icmp = !((pckt->flags & F_ICMP) == 0);\n', '    __u64 off = calc_offset (is_ipv6, is_icmp);\n', '    struct tcphdr *tcp;\n', '    tcp = data + off;\n', '    if (tcp + 1 > data_end) {\n', '        return false;\n', '    }\n', '    if (tcp->syn) {\n', '        pckt->flags |= F_SYN_SET;\n', '    }\n', '    if (!is_icmp) {\n', '        pckt->flow.port16[0] = tcp->source;\n', '        pckt->flow.port16[1] = tcp->dest;\n', '    }\n', '    else {\n', '        pckt->flow.port16[0] = tcp->dest;\n', '        pckt->flow.port16[1] = tcp->source;\n', '    }\n', '    return true;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/pckt_parsing.h" funcheader="int parse_hdr_opt (const struct xdp_md *xdp, struct hdr_opt_state *state)" startline="144" endline="197">

['int parse_hdr_opt (const struct xdp_md *xdp, struct hdr_opt_state *state) {\n', '    const void *data = (void *) (long) xdp->data;\n', '    const void *data_end = (void *) (long) xdp->data_end;\n', '    __u8 *tcp_opt, kind, hdr_len;\n', '    if (!state) {\n', '        return -1;\n', '    }\n', '    tcp_opt = (__u8 *) (data + state->byte_offset);\n', '    if (tcp_opt + 1 > data_end) {\n', '        return -1;\n', '    }\n', '    kind = tcp_opt[0];\n', '    if (kind == TCP_OPT_EOL) {\n', '        return -1;\n', '    }\n', '    if (kind == TCP_OPT_NOP) {\n', '        state->hdr_bytes_remaining--;\n', '        state->byte_offset++;\n', '        return 0;\n', '    }\n', '    if (state->hdr_bytes_remaining < 2 || tcp_opt + sizeof (__u8) + sizeof (__u8) > data_end) {\n', '        return -1;\n', '    }\n', '    hdr_len = tcp_opt[1];\n', '    if (hdr_len > state->hdr_bytes_remaining) {\n', '        return -1;\n', '    }\n', '    if (kind == TCP_HDR_OPT_KIND_TPR) {\n', '        if (hdr_len != TCP_HDR_OPT_LEN_TPR) {\n', '            return -1;\n', '        }\n', '        if (tcp_opt + TCP_HDR_OPT_LEN_TPR > data_end) {\n', '            return -1;\n', '        }\n', '        state->server_id = *(__u32*) &tcp_opt[2];\n', '        return 1;\n', '    }\n', '    state->hdr_bytes_remaining -= hdr_len;\n', '    state->byte_offset += hdr_len;\n', '    return 0;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/pckt_parsing.h" funcheader="__attribute__ ((__always_inline__)) static inline int tcp_hdr_opt_lookup (const struct xdp_md *xdp, bool is_ipv6, struct real_definition **real, struct packet_description *pckt, bool bypass_lru, void *lru_map)" startline="199" endline="273">

['__attribute__ ((__always_inline__)) static inline int tcp_hdr_opt_lookup (const struct xdp_md *xdp, bool is_ipv6, struct real_definition **real, struct packet_description *pckt, bool bypass_lru, void *lru_map) {\n', '    const void *data = (void *) (long) xdp->data;\n', '    const void *data_end = (void *) (long) xdp->data_end;\n', '    struct real_pos_lru *dst_lru;\n', '    struct tcphdr *tcp_hdr;\n', '    __u8 tcp_hdr_opt_len = 0;\n', '    __u64 tcp_offset = 0;\n', '    struct hdr_opt_state opt_state = {};\n', '    int err = 0;\n', '    tcp_offset = calc_offset (is_ipv6, false);\n', '    tcp_hdr = (struct tcphdr *) (data + tcp_offset);\n', '    if (tcp_hdr + 1 > data_end) {\n', '        return FURTHER_PROCESSING;\n', '    }\n', '    tcp_hdr_opt_len = (tcp_hdr->doff * 4) - sizeof (struct tcphdr);\n', '    if (tcp_hdr_opt_len < TCP_HDR_OPT_LEN_TPR) {\n', '        return FURTHER_PROCESSING;\n', '    }\n', '    opt_state.hdr_bytes_remaining = tcp_hdr_opt_len;\n', '    opt_state.byte_offset = sizeof (struct tcphdr) + tcp_offset;\n', '#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0) || \\\n', '    !defined TCP_HDR_OPT_SKIP_UNROLL_LOOP\n', '#pragma clang loop unroll(full)\n', '#endif\n', '    for (int i = 0; i < TCP_HDR_OPT_MAX_OPT_CHECKS; i++) {\n', '        err = parse_hdr_opt (xdp, &opt_state);\n', '        if (err || !opt_state.hdr_bytes_remaining) {\n', '            break;\n', '        }\n', '    }\n', '    if (!opt_state.server_id) {\n', '        return FURTHER_PROCESSING;\n', '    }\n', '    __u32 key = opt_state.server_id;\n', '    __u32 *real_pos = bpf_map_lookup_elem (&server_id_map, &key);\n', '    if (!real_pos) {\n', '        return FURTHER_PROCESSING;\n', '    }\n', '    key = *real_pos;\n', '    if (key == 0) {\n', '        return FURTHER_PROCESSING;\n', '    }\n', '    pckt->real_index = key;\n', '    *real = bpf_map_lookup_elem (&reals, &key);\n', '    if (!(*real)) {\n', '        return FURTHER_PROCESSING;\n', '    }\n', '    if (!bypass_lru) {\n', '        struct real_pos_lru *dst_lru = bpf_map_lookup_elem (lru_map, &pckt->flow);\n', '        if (dst_lru) {\n', '            dst_lru->pos = key;\n', '            return 0;\n', '        }\n', '        struct real_pos_lru new_dst_lru = {};\n', '        new_dst_lru.pos = key;\n', '        bpf_map_update_elem (lru_map, & pckt -> flow, & new_dst_lru, BPF_ANY);\n', '    }\n', '    return 0;\n', '}\n']
Starting <source file="/home/sayandes/codequery/test/pckt_parsing.h" funcheader="__attribute__ ((__always_inline__)) static inline int parse_quic (void *data, void *data_end, bool is_ipv6, struct packet_description *pckt)" startline="276" endline="335">

['__attribute__ ((__always_inline__)) static inline int parse_quic (void *data, void *data_end, bool is_ipv6, struct packet_description *pckt) {\n', '    bool is_icmp = (pckt->flags & F_ICMP);\n', '    __u64 off = calc_offset (is_ipv6, is_icmp);\n', '    if ((data + off + sizeof (struct udphdr) + sizeof (__u8)) > data_end) {\n', '        return FURTHER_PROCESSING;\n', '    }\n', '    __u8 *quic_data = data + off + sizeof (struct udphdr);\n', '    __u8 *pkt_type = quic_data;\n', '    __u8 *connId = NULL;\n', '    if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {\n', '        if (quic_data + sizeof (struct quic_long_header) > data_end) {\n', '            return FURTHER_PROCESSING;\n', '        }\n', '        if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {\n', '            return FURTHER_PROCESSING;\n', '        }\n', '        struct quic_long_header *long_header = (struct quic_long_header *) quic_data;\n', '        if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {\n', '            return FURTHER_PROCESSING;\n', '        }\n', '        connId = long_header->dst_connection_id;\n', '    }\n', '    else {\n', '        if (quic_data + sizeof (struct quic_short_header) > data_end) {\n', '            return FURTHER_PROCESSING;\n', '        }\n', '        connId = ((struct quic_short_header *) quic_data)->connection_id;\n', '    }\n', '    if (!connId) {\n', '        return FURTHER_PROCESSING;\n', '    }\n', '    __u8 connIdVersion = (connId[0] >> 6);\n', '    if (connIdVersion == QUIC_CONNID_VERSION_V1) {\n', '        return ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);\n', '    }\n', '    else if (connIdVersion == QUIC_CONNID_VERSION_V2) {\n', '        __u32 cid = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);\n', '        return cid;\n', '    }\n', '    return FURTHER_PROCESSING;\n', '}\n']
Creating preprocessor for:  ./txl_annotate/annotate_func_test_bpf_common.h.xml
[]
MAPS

MAP decap_counters
//fileName ./txl_annotate/annotate_struct_test_decap_maps.h.out startLine: 18 endLine: 24
struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, struct decap_stats);
    __uint (max_entries, STATS_MAP_SIZE);
    __uint (map_flags, NO_FLAGS);
} decap_counters SEC (".maps");

DUPLICATE MAP ctl_array
//fileName ./txl_annotate/annotate_struct_test_xdp_pktcntr.c.out startLine: 14 endLine: 19
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, CTRL_ARRAY_SIZE);
} ctl_array SEC (".maps");

//fileName ./txl_annotate/annotate_struct_test_control_data_maps.h.out startLine: 9 endLine: 15
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, struct ctl_value);
    __uint (max_entries, CTL_MAP_SIZE);
    __uint (map_flags, NO_FLAGS);
} ctl_array SEC (".maps");

MAP vip_map
//fileName ./txl_annotate/annotate_struct_test_balancer_maps.h.out startLine: 9 endLine: 15
struct {
    __uint (type, BPF_MAP_TYPE_HASH);
    __type (key, struct vip_definition);
    __type (value, struct vip_meta);
    __uint (max_entries, MAX_VIPS);
    __uint (map_flags, NO_FLAGS);
} vip_map SEC (".maps");

MAP lru_mapping
//fileName ./txl_annotate/annotate_struct_test_balancer_maps.h.out startLine: 19 endLine: 25
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
    __uint (key_size, sizeof (__u32));
    __uint (value_size, sizeof (__u32));
    __uint (max_entries, MAX_SUPPORTED_CPUS);
    __uint (map_flags, NO_FLAGS);
} lru_mapping SEC (".maps");

MAP reals
//fileName ./txl_annotate/annotate_struct_test_balancer_maps.h.out startLine: 49 endLine: 55
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, struct real_definition);
    __uint (max_entries, MAX_REALS);
    __uint (map_flags, NO_FLAGS);
} reals SEC (".maps");

MAP reals_stats
//fileName ./txl_annotate/annotate_struct_test_balancer_maps.h.out startLine: 59 endLine: 65
struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, struct lb_stats);
    __uint (max_entries, MAX_REALS);
    __uint (map_flags, NO_FLAGS);
} reals_stats SEC (".maps");

MAP stats
//fileName ./txl_annotate/annotate_struct_test_balancer_maps.h.out startLine: 69 endLine: 75
struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, struct lb_stats);
    __uint (max_entries, STATS_MAP_SIZE);
    __uint (map_flags, NO_FLAGS);
} stats SEC (".maps");

MAP server_id_map
//fileName ./txl_annotate/annotate_struct_test_balancer_maps.h.out startLine: 79 endLine: 85
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, MAX_QUIC_REALS);
    __uint (map_flags, NO_FLAGS);
} server_id_map SEC (".maps");

MAP lpm_src_v4
//fileName ./txl_annotate/annotate_struct_test_balancer_maps.h.out startLine: 90 endLine: 96
struct {
    __uint (type, BPF_MAP_TYPE_LPM_TRIE);
    __type (key, struct v4_lpm_key);
    __type (value, __u32);
    __uint (max_entries, MAX_LPM_SRC);
    __uint (map_flags, BPF_F_NO_PREALLOC);
} lpm_src_v4 SEC (".maps");

MAP lpm_src_v6
//fileName ./txl_annotate/annotate_struct_test_balancer_maps.h.out startLine: 100 endLine: 106
struct {
    __uint (type, BPF_MAP_TYPE_LPM_TRIE);
    __type (key, struct v6_lpm_key);
    __type (value, __u32);
    __uint (max_entries, MAX_LPM_SRC);
    __uint (map_flags, BPF_F_NO_PREALLOC);
} lpm_src_v6 SEC (".maps");

MAP global_lru_maps
//fileName ./txl_annotate/annotate_struct_test_balancer_maps.h.out startLine: 112 endLine: 118
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
    __uint (key_size, sizeof (__u32));
    __uint (value_size, sizeof (__u32));
    __uint (max_entries, MAX_SUPPORTED_CPUS);
    __uint (map_flags, NO_FLAGS);
} global_lru_maps SEC (".maps");

MAP flow_debug_maps
//fileName ./txl_annotate/annotate_struct_test_flow_debug_maps.h.out startLine: 9 endLine: 15
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
    __uint (key_size, sizeof (__u32));
    __uint (value_size, sizeof (__u32));
    __uint (max_entries, MAX_SUPPORTED_CPUS);
    __uint (map_flags, NO_FLAGS);
} flow_debug_maps SEC (".maps");

MAP decap_dst
//fileName ./txl_annotate/annotate_struct_test_control_data_maps.h.out startLine: 32 endLine: 38
struct {
    __uint (type, BPF_MAP_TYPE_HASH);
    __type (key, struct address);
    __type (value, __u32);
    __uint (max_entries, MAX_VIPS);
    __uint (map_flags, NO_FLAGS);
} decap_dst SEC (".maps");

PREPROCESSORS
Name:  ./txl_annotate/annotate_struct_test_balancer_helpers.h.out
Val:  [('#ifdef ', 'INLINE_DECAP_GENERIC', 42, 48)]
Name:  ./txl_annotate/annotate_struct_test_decap_maps.h.out
Val:  [('#ifndef ', 'STATS_MAP_SIZE', 5, 25)]
Name:  ./txl_annotate/annotate_struct_test_xdp_pktcntr.c.out
Val:  []
Name:  ./txl_annotate/annotate_struct_test_balancer_maps.h.out
Val:  [('#ifdef ', 'LPM_SRC_LOOKUP', 87, 107), ('#ifdef ', 'GLOBAL_LRU_LOOKUP', 109, 129), ('#ifndef ', '__BALANCER_MAPS_H', 1, 130)]
Name:  ./txl_annotate/annotate_struct_test_xdp_root.c.out
Val:  []
Name:  ./txl_annotate/annotate_struct_test_encap_helpers.h.out
Val:  [('#ifdef ', 'COPY_INNER_PACKET_TOS', 36, 54)]
Name:  ./txl_annotate/annotate_struct_test_pckt_parsing.h.out
Val:  [('#if ', 'LINUX_VERSION_CODE', 168, 206), ('#ifdef ', 'TCP_HDR_OPT_SKIP_UNROLL_LOOP', 100, 249)]
Name:  ./txl_annotate/annotate_struct_test_healthchecking_consts.h.out
Val:  [('#ifndef ', 'HC_MAX_PACKET_SIZE', 7, 16)]
Name:  ./txl_annotate/annotate_struct_test_balancer_consts.h.out
Val:  [('#ifndef ', 'INLINE_DECAP_GUE', 137, 138), ('#ifndef ', 'INLINE_DECAP', 136, 139), ('#ifdef ', 'LPM_SRC_LOOKUP', 135, 140), ('#ifndef ', 'INLINE_DECAP_IPIP', 143, 144), ('#ifndef ', 'INLINE_DECAP_GENERIC', 148, 149), ('#ifdef ', 'INLINE_DECAP_IPIP', 147, 150), ('#ifndef ', 'INLINE_DECAP_GENERIC', 153, 154), ('#ifdef ', 'INLINE_DECAP_GUE', 152, 155), ('#ifdef ', 'GUE_ENCAP', 157, 167)]
Name:  ./txl_annotate/annotate_struct_test_jhash.h.out
Val:  []
Name:  ./txl_annotate/annotate_struct_test_bpf_endian.h.out
Val:  [('#if ', '__BYTE_ORDER__', 4, 12), ('#ifdef ', '__BYTE_ORDER__', 13, 32)]
Name:  ./txl_annotate/annotate_struct_test_bpf_helpers.h.out
Val:  [('#if ', 'defined(__TARGET_ARCH_x86)', 149, 151), ('#ifdef ', 'defined(__TARGET_ARCH_s390)', 152, 154), ('#ifdef ', 'defined(__TARGET_ARCH_arm)', 155, 157), ('#ifdef ', 'defined(__TARGET_ARCH_arm64)', 158, 160), ('#ifdef ', 'defined(__TARGET_ARCH_mips)', 161, 163), ('#ifdef ', 'defined(__TARGET_ARCH_powerpc)', 164, 166), ('#if ', 'defined(__x86_64__)', 174, 175), ('#ifdef ', 'defined(__s390__)', 176, 177), ('#ifdef ', 'defined(__arm__)', 178, 179), ('#ifdef ', 'defined(__aarch64__)', 180, 181), ('#ifdef ', 'defined(__mips__)', 182, 183), ('#ifdef ', 'defined(__powerpc__)', 184, 185), ('#ifdef ', '__i386__', 203, 226), ('#ifdef ', 'defined(bpf_target_s390)', 227, 242), ('#ifdef ', 'defined(bpf_target_arm)', 243, 254), ('#ifdef ', 'defined(bpf_target_arm64)', 255, 270), ('#ifdef ', 'defined(bpf_target_mips)', 271, 282), ('#ifdef ', 'defined(bpf_target_powerpc)', 283, 291), ('#if ', 'defined(bpf_target_powerpc)', 307, 309)]
Name:  ./txl_annotate/annotate_struct_test_healthchecking_kern.c.out
Val:  []
Name:  ./txl_annotate/annotate_struct_test_flow_debug_maps.h.out
Val:  [('#ifndef ', '__FLOW_DEBUG_MAPS_H', 1, 16)]
Name:  ./txl_annotate/annotate_struct_test_pckt_encap.h.out
Val:  [('#ifdef ', 'GUE_ENCAP', 122, 271), ('#ifdef ', 'INLINE_DECAP_GUE', 273, 312), ('#ifndef ', '__PCKT_ENCAP_H', 1, 313)]
Name:  ./txl_annotate/annotate_struct_test_handle_icmp.h.out
Val:  [('#ifndef ', '__HANDLE_ICMP_H', 1, 233)]
Name:  ./txl_annotate/annotate_struct_test_balancer_structs.h.out
Val:  [('#ifdef ', 'RECORD_FLOW_INFO', 115, 128), ('#ifdef ', 'KATRAN_INTROSPECTION', 105, 129)]
Name:  ./txl_annotate/annotate_struct_test_balancer_kern.c.out
Val:  [('#ifdef ', 'INLINE_DECAP_GENERIC', 188, 210), ('#ifdef ', 'GLOBAL_LRU_LOOKUP', 212, 260), ('#ifdef ', 'INLINE_DECAP_IPIP', 262, 306), ('#ifdef ', 'INLINE_DECAP_GUE', 308, 351), ('#ifdef ', 'INLINE_DECAP_IPIP', 407, 423), ('#ifdef ', 'INLINE_DECAP_GUE', 434, 442), ('#ifdef ', 'TCP_SERVER_ID_ROUTING', 545, 558), ('#ifdef ', 'GLOBAL_LRU_LOOKUP', 563, 569)]
Name:  ./txl_annotate/annotate_struct_test_csum_helpers.h.out
Val:  [('#ifdef ', 'GUE_ENCAP', 63, 269), ('#ifndef ', '__CSUM_HELPERS_H', 1, 270)]
Name:  ./txl_annotate/annotate_struct_test_control_data_maps.h.out
Val:  [('#ifdef ', 'GUE_ENCAP', 50, 61)]
Name:  ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out
Val:  [('#ifndef ', '__HEALTHCHECKING_MAPS_H', 1, 75)]
Name:  ./txl_annotate/annotate_struct_test_x.c.out
Val:  []
Name:  ./txl_annotate/annotate_struct_test_healthchecking_helpers.h.out
Val:  [('#ifndef ', '__HEALTHCHECKING_HELPERS_H', 1, 166)]
Name:  ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out
Val:  []
Name:  ./txl_annotate/annotate_struct_test_bpf_common.h.out
Val:  [('#ifndef ', 'BPF_MAXINSNS', 43, 45)]
Name:  ./txl_annotate/annotate_struct_test_flow_debug_helpers.h.out
Val:  [('#ifndef ', '__FLOW_DEBUG_HELPERS_H', 1, 85)]
Name:  ./txl_annotate/annotate_struct_test_healthchecking_structs.h.out
Val:  [('#ifndef ', '__HEALTHCHECKING_STRUCTS_H', 1, 38)]
Name:  ./txl_annotate/annotate_struct_test_decap_kern.c.out
Val:  [('#ifdef ', 'INLINE_DECAP_GUE', 82, 115), ('#ifdef ', 'INLINE_DECAP_GUE', 147, 164)]
Name:  ./txl_annotate/annotate_struct_test_flow_debug.h.out
Val:  [('#ifndef ', 'FLOW_DEBUG_MAP_SIZE', 4, 5), ('#ifdef ', 'RECORD_FLOW_INFO', 3, 13), ('#ifndef ', '__FLOW_DEBUG_H', 1, 14)]
Name:  ./txl_annotate/annotate_struct_test_introspection.h.out
Val:  []
Name:  ./txl_annotate/annotate_struct_test_bpf.h.out
Val:  [('#ifndef ', '_UAPI__LINUX_BPF_H__', 1, 746)]
Name:  ./txl_annotate/annotate_func_test_csum_helpers.h.xml
Val:  []
Name:  /home/sayandes/codequery/test/csum_helpers.h
Val:  [('#ifdef ', 'GUE_ENCAP', 90, 336), ('#ifndef ', '__CSUM_HELPERS_H', 17, 338)]
Name:  ./txl_annotate/annotate_func_test_bpf_endian.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_bpf.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_xdp_root.c.xml
Val:  []
Name:  /home/sayandes/codequery/test/xdp_root.c
Val:  []
Name:  ./txl_annotate/annotate_func_test_pckt_encap.h.xml
Val:  []
Name:  /home/sayandes/codequery/test/pckt_encap.h
Val:  [('#ifdef ', 'GUE_ENCAP', 175, 367), ('#ifdef ', 'INLINE_DECAP_GUE', 370, 412), ('#ifndef ', '__PCKT_ENCAP_H', 17, 414)]
Name:  ./txl_annotate/annotate_func_test_healthchecking_structs.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_healthchecking_consts.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_flow_debug_maps.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_healthchecking_maps.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_balancer_kern.c.xml
Val:  [('#ifdef ', 'INLINE_DECAP_IPIP', 397, 413), ('#ifdef ', 'INLINE_DECAP_GUE', 424, 432), ('#ifdef ', 'TCP_SERVER_ID_ROUTING', 535, 548), ('#ifdef ', 'GLOBAL_LRU_LOOKUP', 553, 559)]
Name:  /home/sayandes/codequery/test/balancer_kern.c
Val:  [('#ifdef ', 'INLINE_DECAP_GENERIC', 232, 256), ('#ifdef ', 'GLOBAL_LRU_LOOKUP', 259, 336), ('#ifdef ', 'INLINE_DECAP_IPIP', 339, 387), ('#ifdef ', 'INLINE_DECAP_GUE', 390, 441), ('#ifdef ', 'INLINE_DECAP_IPIP', 504, 546), ('#ifdef ', 'INLINE_DECAP_GUE', 557, 565), ('#ifdef ', 'TCP_SERVER_ID_ROUTING', 685, 705), ('#ifdef ', 'GLOBAL_LRU_LOOKUP', 714, 721)]
Name:  ./txl_annotate/annotate_func_test_handle_icmp.h.xml
Val:  []
Name:  /home/sayandes/codequery/test/handle_icmp.h
Val:  [('#ifndef ', '__HANDLE_ICMP_H', 17, 285)]
Name:  ./txl_annotate/annotate_func_test_decap_maps.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_flow_debug.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_balancer_maps.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_encap_helpers.h.xml
Val:  []
Name:  /home/sayandes/codequery/test/encap_helpers.h
Val:  [('#ifdef ', 'COPY_INNER_PACKET_TOS', 66, 90)]
Name:  ./txl_annotate/annotate_func_test_balancer_helpers.h.xml
Val:  []
Name:  /home/sayandes/codequery/test/balancer_helpers.h
Val:  [('#ifdef ', 'INLINE_DECAP_GENERIC', 73, 80)]
Name:  ./txl_annotate/annotate_func_test_healthchecking_ipip.c.xml
Val:  []
Name:  /home/sayandes/codequery/test/healthchecking_ipip.c
Val:  []
Name:  ./txl_annotate/annotate_func_test_healthchecking_helpers.h.xml
Val:  []
Name:  /home/sayandes/codequery/test/healthchecking_helpers.h
Val:  [('#ifndef ', '__HEALTHCHECKING_HELPERS_H', 17, 214)]
Name:  ./txl_annotate/annotate_func_test_balancer_consts.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_flow_debug_helpers.h.xml
Val:  []
Name:  /home/sayandes/codequery/test/flow_debug_helpers.h
Val:  [('#ifndef ', '__FLOW_DEBUG_HELPERS_H', 17, 125)]
Name:  ./txl_annotate/annotate_func_test_decap_kern.c.xml
Val:  [('#ifdef ', 'INLINE_DECAP_GUE', 136, 153)]
Name:  /home/sayandes/codequery/test/decap_kern.c
Val:  [('#ifdef ', 'INLINE_DECAP_GUE', 122, 161), ('#ifdef ', 'INLINE_DECAP_GUE', 202, 218)]
Name:  ./txl_annotate/annotate_func_test_jhash.h.xml
Val:  []
Name:  /home/sayandes/codequery/test/jhash.h
Val:  []
Name:  ./txl_annotate/annotate_func_test_bpf_helpers.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_xdp_pktcntr.c.xml
Val:  []
Name:  /home/sayandes/codequery/test/xdp_pktcntr.c
Val:  []
Name:  ./txl_annotate/annotate_func_test_x.c.xml
Val:  []
Name:  /home/sayandes/codequery/test/x.c
Val:  []
Name:  ./txl_annotate/annotate_func_test_balancer_structs.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_control_data_maps.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_introspection.h.xml
Val:  []
Name:  ./txl_annotate/annotate_func_test_healthchecking_kern.c.xml
Val:  []
Name:  /home/sayandes/codequery/test/healthchecking_kern.c
Val:  []
Name:  ./txl_annotate/annotate_func_test_pckt_parsing.h.xml
Val:  []
Name:  /home/sayandes/codequery/test/pckt_parsing.h
Val:  [('#if ', 'LINUX_VERSION_CODE', 227, 273), ('#ifdef ', 'TCP_HDR_OPT_SKIP_UNROLL_LOOP', 139, 336)]
Name:  ./txl_annotate/annotate_func_test_bpf_common.h.xml
Val:  []
