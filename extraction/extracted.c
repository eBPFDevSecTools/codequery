/* SPDX-License-Identifier: GPL-2.0 */
#ifndef INTROSPECTION_H
#define INTROSPECTION_H
#include "introspection.h"
#endif 

#ifndef BALANCER_KERN_TPL_H
#define BALANCER_KERN_TPL_H
#include "balancer_kern-tpl.h"
#endif 

#ifndef BALANCER_MAPS_H
#define BALANCER_MAPS_H
#include "balancer_maps.h"
#endif 

#ifndef PCKT_ENCAP_H
#define PCKT_ENCAP_H
#include "pckt_encap.h"
#endif 

#ifndef HEALTHCHECKING_HELPERS_H
#define HEALTHCHECKING_HELPERS_H
#include "healthchecking_helpers.h"
#endif 

#ifndef BALANCER_CONSTS_H
#define BALANCER_CONSTS_H
#include "balancer_consts.h"
#endif 

#ifndef ENCAP_HELPERS_H
#define ENCAP_HELPERS_H
#include "encap_helpers.h"
#endif 

#ifndef FLOW_DEBUG_H
#define FLOW_DEBUG_H
#include "flow_debug.h"
#endif 

#ifndef JHASH_H
#define JHASH_H
#include "jhash.h"
#endif 

#ifndef CONTROL_DATA_MAPS_H
#define CONTROL_DATA_MAPS_H
#include "control_data_maps.h"
#endif 

#ifndef HEALTHCHECKING_STRUCTS_H
#define HEALTHCHECKING_STRUCTS_H
#include "healthchecking_structs.h"
#endif 

#ifndef BALANCER_STRUCTS_H
#define BALANCER_STRUCTS_H
#include "balancer_structs.h"
#endif 

#ifndef HEALTHCHECKING_MAPS_H
#define HEALTHCHECKING_MAPS_H
#include "healthchecking_maps.h"
#endif 

#ifndef BALANCER_HELPERS_H
#define BALANCER_HELPERS_H
#include "balancer_helpers.h"
#endif 

#ifndef PCKT_PARSING_H
#define PCKT_PARSING_H
#include "pckt_parsing.h"
#endif 

#ifndef FLOW_DEBUG_MAPS_H
#define FLOW_DEBUG_MAPS_H
#include "flow_debug_maps.h"
#endif 

#ifndef DECAP_MAPS_H
#define DECAP_MAPS_H
#include "decap_maps.h"
#endif 

#ifndef BPF_H
#define BPF_H
#include "bpf.h"
#endif 

#ifndef FLOW_DEBUG_HELPERS_H
#define FLOW_DEBUG_HELPERS_H
#include "flow_debug_helpers.h"
#endif 

#ifndef BPF_COMMON_H
#define BPF_COMMON_H
#include "bpf_common.h"
#endif 

#ifndef CSUM_HELPERS_H
#define CSUM_HELPERS_H
#include "csum_helpers.h"
#endif 

#ifndef BPF_HELPERS_H
#define BPF_HELPERS_H
#include "bpf_helpers.h"
#endif 

#ifndef BPF_ENDIAN_H
#define BPF_ENDIAN_H
#include "bpf_endian.h"
#endif 

#ifndef BALANCER_KERN_FLAVORS_TPL_H
#define BALANCER_KERN_FLAVORS_TPL_H
#include "balancer_kern_flavors-tpl.h"
#endif 

#ifndef HEALTHCHECKING_CONSTS_H
#define HEALTHCHECKING_CONSTS_H
#include "healthchecking_consts.h"
#endif 

#ifndef HANDLE_ICMP_H
#define HANDLE_ICMP_H
#include "handle_icmp.h"
#endif 

#ifndef VERSION_H
#define VERSION_H
#include "version.h"
#endif 

#ifndef INTROSPECTION_H
#define INTROSPECTION_H
#include "introspection.h"
#endif 

#ifndef CDEFS_H
#define CDEFS_H
#include "cdefs.h"
#endif 

#include <bits/wordsize.h>
#include <bits/long-double.h>
#ifndef SELECT_H
#define SELECT_H
#include "select.h"
#endif 

#ifndef SWAB_H
#define SWAB_H
#include "swab.h"
#endif 

#include <linux/types.h>
#include <asm/bitsperlong.h>
#include <asm/swab.h>
#ifndef BYTESWAP_H
#define BYTESWAP_H
#include "byteswap.h"
#endif 

#include <features.h>
#include <bits/types.h>
#ifndef JHASH_H
#define JHASH_H
#include "jhash.h"
#endif 

#ifndef UINTN_IDENTITY_H
#define UINTN_IDENTITY_H
#include "uintn-identity.h"
#endif 

#ifndef BPF_ENDIAN_H
#define BPF_ENDIAN_H
#include "bpf_endian.h"
#endif 

#include <linux/swab.h>
#ifndef PCKT_PARSING_H
#define PCKT_PARSING_H
#include "pckt_parsing.h"
#endif 

#include <linux/icmp.h>
#include <linux/icmpv6.h>
#include <linux/if_ether.h>
#include <linux/ip.h>
#include <linux/ipv6.h>
#include <linux/ptrace.h>
#include <linux/tcp.h>
#include <linux/udp.h>
#include <linux/version.h>
#include <stdbool.h>
#include <stddef.h>
#ifndef BALANCER_CONSTS_H
#define BALANCER_CONSTS_H
#include "balancer_consts.h"
#endif 

#ifndef BALANCER_HELPERS_H
#define BALANCER_HELPERS_H
#include "balancer_helpers.h"
#endif 

#ifndef BPF_H
#define BPF_H
#include "bpf.h"
#endif 

#ifndef CSUM_HELPERS_H
#define CSUM_HELPERS_H
#include "csum_helpers.h"
#endif 

#include <linux/in.h>
#ifndef BPF_ENDIAN_H
#define BPF_ENDIAN_H
#include "bpf_endian.h"
#endif 

#ifndef BPF_HELPERS_H
#define BPF_HELPERS_H
#include "bpf_helpers.h"
#endif 

#ifndef PCKT_ENCAP_H
#define PCKT_ENCAP_H
#include "pckt_encap.h"
#endif 

#include <string.h>
#ifndef BALANCER_STRUCTS_H
#define BALANCER_STRUCTS_H
#include "balancer_structs.h"
#endif 

#ifndef CONTROL_DATA_MAPS_H
#define CONTROL_DATA_MAPS_H
#include "control_data_maps.h"
#endif 

#ifndef ENCAP_HELPERS_H
#define ENCAP_HELPERS_H
#include "encap_helpers.h"
#endif 

#ifndef FLOW_DEBUG_H
#define FLOW_DEBUG_H
#include "flow_debug.h"
#endif 

#ifndef PCKT_PARSING_H
#define PCKT_PARSING_H
#include "pckt_parsing.h"
#endif 

#ifndef BALANCER_HELPERS_H
#define BALANCER_HELPERS_H
#include "balancer_helpers.h"
#endif 

#ifndef CSUM_HELPERS_H
#define CSUM_HELPERS_H
#include "csum_helpers.h"
#endif 

#ifndef INTROSPECTION_H
#define INTROSPECTION_H
#include "introspection.h"
#endif 

#ifndef FLOW_DEBUG_HELPERS_H
#define FLOW_DEBUG_HELPERS_H
#include "flow_debug_helpers.h"
#endif 

#ifndef FLOW_DEBUG_MAPS_H
#define FLOW_DEBUG_MAPS_H
#include "flow_debug_maps.h"
#endif 

#ifndef HANDLE_ICMP_H
#define HANDLE_ICMP_H
#include "handle_icmp.h"
#endif 

/* Extracted from 
 ./txl_annotate/annotate_struct_test_decap_maps.h.out 
 startLine: 10 endLine: 14
 */ 
struct decap_stats {
    __u64 decap_v4;
    __u64 decap_v6;
    __u64 total;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_decap_maps.h.out 
 startLine: 18 endLine: 24
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, struct decap_stats);
    __uint (max_entries, STATS_MAP_SIZE);
    __uint (map_flags, NO_FLAGS);
} decap_counters SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_xdp_pktcntr.c.out 
 startLine: 14 endLine: 19
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, CTRL_ARRAY_SIZE);
} ctl_array SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_xdp_pktcntr.c.out 
 startLine: 23 endLine: 28
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, __u64);
    __uint (max_entries, CNTRS_ARRAY_SIZE);
} cntrs_array SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_maps.h.out 
 startLine: 9 endLine: 15
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_HASH);
    __type (key, struct vip_definition);
    __type (value, struct vip_meta);
    __uint (max_entries, MAX_VIPS);
    __uint (map_flags, NO_FLAGS);
} vip_map SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_maps.h.out 
 startLine: 19 endLine: 25
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
    __uint (key_size, sizeof (__u32));
    __uint (value_size, sizeof (__u32));
    __uint (max_entries, MAX_SUPPORTED_CPUS);
    __uint (map_flags, NO_FLAGS);
} lru_mapping SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_maps.h.out 
 startLine: 29 endLine: 35
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_LRU_HASH);
    __type (key, struct flow_key);
    __type (value, struct real_pos_lru);
    __uint (max_entries, DEFAULT_LRU_SIZE);
    __uint (map_flags, NO_FLAGS);
} fallback_cache SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_maps.h.out 
 startLine: 39 endLine: 45
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, CH_RINGS_SIZE);
    __uint (map_flags, NO_FLAGS);
} ch_rings SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_maps.h.out 
 startLine: 49 endLine: 55
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, struct real_definition);
    __uint (max_entries, MAX_REALS);
    __uint (map_flags, NO_FLAGS);
} reals SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_maps.h.out 
 startLine: 59 endLine: 65
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, struct lb_stats);
    __uint (max_entries, MAX_REALS);
    __uint (map_flags, NO_FLAGS);
} reals_stats SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_maps.h.out 
 startLine: 69 endLine: 75
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, struct lb_stats);
    __uint (max_entries, STATS_MAP_SIZE);
    __uint (map_flags, NO_FLAGS);
} stats SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_maps.h.out 
 startLine: 79 endLine: 85
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, MAX_QUIC_REALS);
    __uint (map_flags, NO_FLAGS);
} server_id_map SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_maps.h.out 
 startLine: 90 endLine: 96
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_LPM_TRIE);
    __type (key, struct v4_lpm_key);
    __type (value, __u32);
    __uint (max_entries, MAX_LPM_SRC);
    __uint (map_flags, BPF_F_NO_PREALLOC);
} lpm_src_v4 SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_maps.h.out 
 startLine: 100 endLine: 106
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_LPM_TRIE);
    __type (key, struct v6_lpm_key);
    __type (value, __u32);
    __uint (max_entries, MAX_LPM_SRC);
    __uint (map_flags, BPF_F_NO_PREALLOC);
} lpm_src_v6 SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_maps.h.out 
 startLine: 112 endLine: 118
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
    __uint (key_size, sizeof (__u32));
    __uint (value_size, sizeof (__u32));
    __uint (max_entries, MAX_SUPPORTED_CPUS);
    __uint (map_flags, NO_FLAGS);
} global_lru_maps SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_maps.h.out 
 startLine: 122 endLine: 128
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_LRU_HASH);
    __type (key, struct flow_key);
    __type (value, __u32);
    __uint (max_entries, DEFAULT_GLOBAL_LRU_SIZE);
    __uint (map_flags, NO_FLAGS);
} fallback_glru SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_xdp_root.c.out 
 startLine: 6 endLine: 11
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_PROG_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, ROOT_ARRAY_SIZE);
} root_array SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_pckt_parsing.h.out 
 startLine: 19 endLine: 24
 */ 
struct quic_long_header {
    __u8 flags;
    __u32 version;
    __u8 conn_id_lens;
    __u8 dst_connection_id [QUIC_MIN_CONNID_LEN];
} __attribute__ ((__packed__));
/* Extracted from 
 ./txl_annotate/annotate_struct_test_pckt_parsing.h.out 
 startLine: 28 endLine: 31
 */ 
struct quic_short_header {
    __u8 flags;
    __u8 connection_id [QUIC_MIN_CONNID_LEN];
} __attribute__ ((__packed__));
/* Extracted from 
 ./txl_annotate/annotate_struct_test_pckt_parsing.h.out 
 startLine: 93 endLine: 97
 */ 
struct hdr_opt_state {
    __u32 server_id;
    __u8 byte_offset;
    __u8 hdr_bytes_remaining;
};
/* Extracted from 
 /home/sayandes/codequery/test/balancer_kern.c 
 startLine: 24 endLine: 50
 */ 
__attribute__((__always_inline__)) 
	static inline bool is_under_flood(
    __u64* cur_time) {
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
  struct lb_stats* conn_rate_stats =
      bpf_map_lookup_elem(&stats, &conn_rate_key);
  if (!conn_rate_stats) {
    return true;
  }
  *cur_time = bpf_ktime_get_ns();
  // we are going to check that new connections rate is less than predefined
  // value; conn_rate_stats.v1 contains number of new connections for the last
  // second, v2 - when last time quanta started.
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    // new time quanta; reseting counters
    conn_rate_stats->v1 = 1;
    conn_rate_stats->v2 = *cur_time;
  } else {
    conn_rate_stats->v1 += 1;
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
      // we are exceding max connections rate. bypasing lru update and
      // source routing lookup
      return true;
    }
  }
  return false;
}
/* Extracted from 
 /home/sayandes/codequery/test/balancer_kern.c 
 startLine: 52 endLine: 131
 */ 
__attribute__((__always_inline__)) 
	static inline bool get_packet_dst(
    struct real_definition** real,
    struct packet_description* pckt,
    struct vip_meta* vip_info,
    bool is_ipv6,
    void* lru_map) {
  // to update lru w/ new connection
  struct real_pos_lru new_dst_lru = {};
  bool under_flood = false;
  bool src_found = false;
  __u32* real_pos;
  __u64 cur_time = 0;
  __u32 hash;
  __u32 key;

  under_flood = is_under_flood(&cur_time);

#ifdef LPM_SRC_LOOKUP
  if ((vip_info->flags & F_SRC_ROUTING) && !under_flood) {
    __u32* lpm_val;
    if (is_ipv6) {
      struct v6_lpm_key lpm_key_v6 = {};
      lpm_key_v6.prefixlen = 128;
      memcpy(lpm_key_v6.addr, pckt->flow.srcv6, 16);
      lpm_val = bpf_map_lookup_elem(&lpm_src_v6, &lpm_key_v6);
    } else {
      struct v4_lpm_key lpm_key_v4 = {};
      lpm_key_v4.addr = pckt->flow.src;
      lpm_key_v4.prefixlen = 32;
      lpm_val = bpf_map_lookup_elem(&lpm_src_v4, &lpm_key_v4);
    }
    if (lpm_val) {
      src_found = true;
      key = *lpm_val;
    }
    __u32 stats_key = MAX_VIPS + LPM_SRC_CNTRS;
    struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    if (data_stats) {
      if (src_found) {
        data_stats->v2 += 1;
      } else {
        data_stats->v1 += 1;
      }
    }
  }
#endif
  if (!src_found) {
    bool hash_16bytes = is_ipv6;

    if (vip_info->flags & F_HASH_DPORT_ONLY) {
      // service which only use dst port for hash calculation
      // e.g. if packets has same dst port -> they will go to the same real.
      // usually VoIP related services.
      pckt->flow.port16[0] = pckt->flow.port16[1];
      memset(pckt->flow.srcv6, 0, 16);
    }
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    key = RING_SIZE * (vip_info->vip_num) + hash;

    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    if (!real_pos) {
      return false;
    }
    key = *real_pos;
  }
  pckt->real_index = key;
  *real = bpf_map_lookup_elem(&reals, &key);
  if (!(*real)) {
    return false;
  }
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    if (pckt->flow.proto == IPPROTO_UDP) {
      new_dst_lru.atime = cur_time;
    }
    new_dst_lru.pos = key;
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
  }
  return true;
}
/* Extracted from 
 /home/sayandes/codequery/test/balancer_kern.c 
 startLine: 133 endLine: 156
 */ 
__attribute__((__always_inline__)) static inline void connection_table_lookup(
    struct real_definition** real,
    struct packet_description* pckt,
    void* lru_map,
    bool isGlobalLru) {
  struct real_pos_lru* dst_lru;
  __u64 cur_time;
  __u32 key;
  dst_lru = bpf_map_lookup_elem(lru_map, &pckt->flow);
  if (!dst_lru) {
    return;
  }
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    cur_time = bpf_ktime_get_ns();
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
      return;
    }
    dst_lru->atime = cur_time;
  }
  key = dst_lru->pos;
  pckt->real_index = key;
  *real = bpf_map_lookup_elem(&reals, &key);
  return;
}
/* Extracted from 
 /home/sayandes/codequery/test/balancer_kern.c 
 startLine: 233 endLine: 255
 */ 
__attribute__((__always_inline__)) static inline int
check_decap_dst(struct packet_description* pckt, bool is_ipv6, bool* pass) {
  struct address dst_addr = {};
  struct lb_stats* data_stats;

  if (is_ipv6) {
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
  } else {
    dst_addr.addr = pckt->flow.dst;
  }
  __u32* decap_dst_flags = bpf_map_lookup_elem(&decap_dst, &dst_addr);

  if (decap_dst_flags) {
    *pass = false;
    __u32 stats_key = MAX_VIPS + REMOTE_ENCAP_CNTRS;
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    if (!data_stats) {
      return XDP_DROP;
    }
    data_stats->v1 += 1;
  }
  return FURTHER_PROCESSING;
}
/* Extracted from 
 /home/sayandes/codequery/test/balancer_kern.c 
 startLine: 261 endLine: 277
 */ 
__attribute__((__always_inline__)) static inline bool reals_have_same_addr(
    struct real_definition* a,
    struct real_definition* b) {
  if (a->flags != b->flags) {
    return false;
  }
  if (a->flags & F_IPV6) {
    for (int i = 0; i < 4; i++) {
      if (a->dstv6[i] != b->dstv6[i]) {
        return false;
      }
      return true;
    }
  } else {
    return a->dst == b->dst;
  }
}
/* Extracted from 
 /home/sayandes/codequery/test/balancer_kern.c 
 startLine: 279 endLine: 335
 */ 
__attribute__((__always_inline__)) static inline int perform_global_lru_lookup(
    struct real_definition** dst,
    struct packet_description* pckt,
    __u32 cpu_num,
    struct vip_meta* vip_info,
    bool is_ipv6) {
  // lookup in the global cache
  void* g_lru_map = bpf_map_lookup_elem(&global_lru_maps, &cpu_num);
  __u32 global_lru_stats_key = MAX_VIPS + GLOBAL_LRU_CNTR;

  struct lb_stats* global_lru_stats =
      bpf_map_lookup_elem(&stats, &global_lru_stats_key);
  if (!global_lru_stats) {
    return XDP_DROP;
  }

  if (!g_lru_map) {
    // We were not able to retrieve the global lru for this cpu.
    // This counter should never be anything except 0 in prod.
    // We are going to use it for monitoring.
    global_lru_stats->v1 += 1; // global lru map doesn't exist for this cpu
    g_lru_map = &fallback_glru;
  }

  connection_table_lookup(dst, pckt, g_lru_map, /*isGlobalLru=*/true);
  if (*dst) {
    global_lru_stats->v2 += 1; // we routed a flow using global lru

    // Find the real that we route the packet to if we use consistent hashing
    struct real_definition* dst_consistent_hash = NULL;
    if (get_packet_dst(
            &dst_consistent_hash,
            pckt,
            vip_info,
            is_ipv6,
            /*lru_map=*/NULL)) {
      __u32 global_lru_mismatch_stats_key = MAX_VIPS + GLOBAL_LRU_MISMATCH_CNTR;

      struct lb_stats* global_lru_mismatch_stats =
          bpf_map_lookup_elem(&stats, &global_lru_mismatch_stats_key);

      if (dst_consistent_hash && global_lru_mismatch_stats) {
        if (reals_have_same_addr(dst_consistent_hash, *dst)) {
          // We route to the same real as that indicated by the consistent
          // hash
          global_lru_mismatch_stats->v1++;
        } else {
          // We route to a real different from that indicated by the
          // consistent hash
          global_lru_mismatch_stats->v2++;
        }
      }
    }
  }

  return FURTHER_PROCESSING;
}
/* Extracted from 
 /home/sayandes/codequery/test/balancer_kern.c 
 startLine: 444 endLine: 457
 */ 
__attribute__((__always_inline__)) static inline void
increment_quic_cid_version_stats(int host_id) {
  __u32 quic_version_stats_key = MAX_VIPS + QUIC_CID_VERSION_STATS;
  struct lb_stats* quic_version =
      bpf_map_lookup_elem(&stats, &quic_version_stats_key);
  if (!quic_version) {
    return;
  }
  if (host_id > QUIC_CONNID_VERSION_V1_MAX_VAL) {
    quic_version->v2 += 1;
  } else {
    quic_version->v1 += 1;
  }
}
/* Extracted from 
 /home/sayandes/codequery/test/balancer_kern.c 
 startLine: 459 endLine: 468
 */ 
__attribute__((__always_inline__)) static inline void
increment_quic_cid_drop_no_real() {
  __u32 quic_drop_stats_key = MAX_VIPS + QUIC_CID_DROP_STATS;
  struct lb_stats* quic_drop =
      bpf_map_lookup_elem(&stats, &quic_drop_stats_key);
  if (!quic_drop) {
    return;
  }
  quic_drop->v1 += 1;
}
/* Extracted from 
 /home/sayandes/codequery/test/balancer_kern.c 
 startLine: 470 endLine: 478
 */ 
__attribute__((__always_inline__)) static inline void increment_quic_cid_drop_real_0() {
  __u32 quic_drop_stats_key = MAX_VIPS + QUIC_CID_DROP_STATS;
  struct lb_stats* quic_drop =
      bpf_map_lookup_elem(&stats, &quic_drop_stats_key);
  if (!quic_drop) {
    return;
  }
  quic_drop->v2 += 1;
}
/* Extracted from 
 /home/sayandes/codequery/test/balancer_kern.c 
 startLine: 818 endLine: 827
 */ 
__attribute__((__always_inline__)) static inline __u32 get_packet_hash(struct packet_description* pckt,bool hash_16bytes) {
  if (hash_16bytes) {
    return jhash_2words(
        jhash(pckt->flow.srcv6, 16, INIT_JHASH_SEED_V6),
        pckt->flow.ports,
        INIT_JHASH_SEED);
  } else {
    return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
  }
}
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf_helpers.h.out 
 startLine: 99 endLine: 99
 */ 
struct sk_buff;
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf_helpers.h.out 
 startLine: 109 endLine: 117
 */ 
struct bpf_map_def {
    unsigned int type;
    unsigned int key_size;
    unsigned int value_size;
    unsigned int max_entries;
    unsigned int map_flags;
    unsigned int inner_map_idx;
    unsigned int numa_node;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf_helpers.h.out 
 startLine: 230 endLine: 230
 */ 
struct pt_regs;
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf_helpers.h.out 
 startLine: 258 endLine: 258
 */ 
struct pt_regs;
/* Extracted from 
 ./txl_annotate/annotate_struct_test_flow_debug_maps.h.out 
 startLine: 9 endLine: 15
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
    __uint (key_size, sizeof (__u32));
    __uint (value_size, sizeof (__u32));
    __uint (max_entries, MAX_SUPPORTED_CPUS);
    __uint (map_flags, NO_FLAGS);
} flow_debug_maps SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_structs.h.out 
 startLine: 5 endLine: 19
 */ 
struct flow_key {
    union {
        __be32 src;
        __be32 srcv6 [4];
    };
    union {
        __be32 dst;
        __be32 dstv6 [4];
    };
    union {
        __u32 ports;
        __u16 port16 [2];
    };
    __u8 proto;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_structs.h.out 
 startLine: 23 endLine: 28
 */ 
struct packet_description {
    struct flow_key flow;
    __u32 real_index;
    __u8 flags;
    __u8 tos;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_structs.h.out 
 startLine: 32 endLine: 38
 */ 
struct ctl_value {
    union {
        __u64 value;
        __u32 ifindex;
        __u8 mac [6];
    };
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_structs.h.out 
 startLine: 42 endLine: 49
 */ 
struct vip_definition {
    union {
        __be32 vip;
        __be32 vipv6 [4];
    };
    __u16 port;
    __u8 proto;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_structs.h.out 
 startLine: 53 endLine: 56
 */ 
struct vip_meta {
    __u32 flags;
    __u32 vip_num;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_structs.h.out 
 startLine: 60 endLine: 63
 */ 
struct real_pos_lru {
    __u32 pos;
    __u64 atime;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_structs.h.out 
 startLine: 67 endLine: 73
 */ 
struct real_definition {
    union {
        __be32 dst;
        __be32 dstv6 [4];
    };
    __u8 flags;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_structs.h.out 
 startLine: 77 endLine: 80
 */ 
struct lb_stats {
    __u64 v1;
    __u64 v2;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_structs.h.out 
 startLine: 84 endLine: 87
 */ 
struct v4_lpm_key {
    __u32 prefixlen;
    __be32 addr;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_structs.h.out 
 startLine: 91 endLine: 94
 */ 
struct v6_lpm_key {
    __u32 prefixlen;
    __be32 addr [4];
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_structs.h.out 
 startLine: 98 endLine: 103
 */ 
struct address {
    union {
        __be32 addr;
        __be32 addrv6 [4];
    };
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_structs.h.out 
 startLine: 108 endLine: 112
 */ 
struct event_metadata {
    __u32 event;
    __u32 pkt_size;
    __u32 data_len;
} __attribute__ ((__packed__));
/* Extracted from 
 ./txl_annotate/annotate_struct_test_balancer_structs.h.out 
 startLine: 118 endLine: 127
 */ 
struct flow_debug_info {
    union {
        __be32 l4_hop;
        __be32 l4_hopv6 [4];
    };
    union {
        __be32 this_hop;
        __be32 this_hopv6 [4];
    };
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_control_data_maps.h.out 
 startLine: 9 endLine: 15
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, struct ctl_value);
    __uint (max_entries, CTL_MAP_SIZE);
    __uint (map_flags, NO_FLAGS);
} ctl_array SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_control_data_maps.h.out 
 startLine: 20 endLine: 26
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
    __type (key, int);
    __type (value, __u32);
    __uint (max_entries, MAX_SUPPORTED_CPUS);
    __uint (map_flags, NO_FLAGS);
} event_pipe SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_control_data_maps.h.out 
 startLine: 32 endLine: 38
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_HASH);
    __type (key, struct address);
    __type (value, __u32);
    __uint (max_entries, MAX_VIPS);
    __uint (map_flags, NO_FLAGS);
} decap_dst SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_control_data_maps.h.out 
 startLine: 42 endLine: 47
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_PROG_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, SUBPROGRAMS_ARRAY_SIZE);
} subprograms SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_control_data_maps.h.out 
 startLine: 53 endLine: 59
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, struct real_definition);
    __uint (max_entries, 2);
    __uint (map_flags, NO_FLAGS);
} pckt_srcs SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out 
 startLine: 10 endLine: 15
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, CTRL_MAP_SIZE);
} hc_ctrl_map SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out 
 startLine: 19 endLine: 24
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_HASH);
    __type (key, __u32);
    __type (value, struct hc_real_definition);
    __uint (max_entries, MAX_REALS);
} hc_reals_map SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out 
 startLine: 28 endLine: 34
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, struct hc_real_definition);
    __uint (max_entries, 2);
    __uint (map_flags, NO_FLAGS);
} hc_pckt_srcs_map SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out 
 startLine: 38 endLine: 44
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, struct hc_mac);
    __uint (max_entries, 2);
    __uint (map_flags, NO_FLAGS);
} hc_pckt_macs SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out 
 startLine: 48 endLine: 54
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, struct hc_stats);
    __uint (max_entries, STATS_SIZE);
    __uint (map_flags, NO_FLAGS);
} hc_stats_map SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out 
 startLine: 58 endLine: 64
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, __u64);
    __uint (max_entries, MAX_VIPS);
    __uint (map_flags, NO_FLAGS);
} per_hckey_stats SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_maps.h.out 
 startLine: 68 endLine: 74
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_HASH);
    __type (key, struct hc_key);
    __type (value, __u32);
    __uint (max_entries, MAX_VIPS);
    __uint (map_flags, NO_FLAGS);
} hc_key_map SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out 
 startLine: 22 endLine: 28
 */ 
struct hc_real_definition {
    union {
        __be32 daddr;
        __be32 v6daddr [4];
    };
    __u8 flags;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out 
 startLine: 32 endLine: 37
 */ 
struct hc_stats {
    __u64 pckts_processed;
    __u64 pckts_dropped;
    __u64 pckts_skipped;
    __u64 pckts_too_big;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out 
 startLine: 41 endLine: 46
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_ARRAY);
    __type (key, __u32);
    __type (value, __u32);
    __uint (max_entries, CTRL_MAP_SIZE);
} hc_ctrl_map SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out 
 startLine: 50 endLine: 55
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_HASH);
    __type (key, __u32);
    __type (value, struct hc_real_definition);
    __uint (max_entries, REALS_MAP_SIZE);
} hc_reals_map SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_ipip.c.out 
 startLine: 59 endLine: 65
 */ 
struct {
    __uint (type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __type (key, __u32);
    __type (value, struct hc_stats);
    __uint (max_entries, STATS_SIZE);
    __uint (map_flags, NO_FLAGS);
} hc_stats_map SEC (".maps");
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_structs.h.out 
 startLine: 5 endLine: 11
 */ 
struct hc_real_definition {
    union {
        __be32 daddr;
        __be32 v6daddr [4];
    };
    __u8 flags;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_structs.h.out 
 startLine: 15 endLine: 20
 */ 
struct hc_stats {
    __u64 pckts_processed;
    __u64 pckts_dropped;
    __u64 pckts_skipped;
    __u64 pckts_too_big;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_structs.h.out 
 startLine: 24 endLine: 31
 */ 
struct hc_key {
    union {
        __be32 addr;
        __be32 addrv6 [4];
    };
    __u16 port;
    __u8 proto;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_healthchecking_structs.h.out 
 startLine: 35 endLine: 37
 */ 
struct hc_mac {
    __u8 mac [6];
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 29 endLine: 35
 */ 
struct bpf_insn {
    __u8 code;
    __u8 dst_reg : 4;
    __u8 src_reg : 4;
    __s16 off;
    __s32 imm;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 39 endLine: 42
 */ 
struct bpf_lpm_trie_key {
    __u32 prefixlen;
    __u8 data [0];
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 46 endLine: 49
 */ 
struct bpf_cgroup_storage_key {
    __u64 cgroup_inode_id;
    __u32 attach_type;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 86 endLine: 93
 */ 
struct bpf_stack_build_id {
    __s32 status;
    unsigned char build_id [BPF_BUILD_ID_SIZE];
    union {
        __u64 offset;
        __u64 ip;
    };
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 97 endLine: 214
 */ 
union bpf_attr {
    struct {
        __u32 map_type;
        __u32 key_size;
        __u32 value_size;
        __u32 max_entries;
        __u32 map_flags;
        __u32 inner_map_fd;
        __u32 numa_node;
        char map_name [BPF_OBJ_NAME_LEN];
        __u32 map_ifindex;
        __u32 btf_fd;
        __u32 btf_key_type_id;
        __u32 btf_value_type_id;
    };
    struct {
        __u32 map_fd;
        __aligned_u64 key;
        union {
            __aligned_u64 value;
            __aligned_u64 next_key;
        };
        __u64 flags;
    };
    struct {
        __u32 prog_type;
        __u32 insn_cnt;
        __aligned_u64 insns;
        __aligned_u64 license;
        __u32 log_level;
        __u32 log_size;
        __aligned_u64 log_buf;
        __u32 kern_version;
        __u32 prog_flags;
        char prog_name [BPF_OBJ_NAME_LEN];
        __u32 prog_ifindex;
        __u32 expected_attach_type;
        __u32 prog_btf_fd;
        __u32 func_info_rec_size;
        __aligned_u64 func_info;
        __u32 func_info_cnt;
        __u32 line_info_rec_size;
        __aligned_u64 line_info;
        __u32 line_info_cnt;
        __u32 attach_btf_id;
        __u32 attach_prog_fd;
    };
    struct {
        __aligned_u64 pathname;
        __u32 bpf_fd;
        __u32 file_flags;
    };
    struct {
        __u32 target_fd;
        __u32 attach_bpf_fd;
        __u32 attach_type;
        __u32 attach_flags;
    };
    struct {
        __u32 prog_fd;
        __u32 retval;
        __u32 data_size_in;
        __u32 data_size_out;
        __aligned_u64 data_in;
        __aligned_u64 data_out;
        __u32 repeat;
        __u32 duration;
        __u32 ctx_size_in;
        __u32 ctx_size_out;
        __aligned_u64 ctx_in;
        __aligned_u64 ctx_out;
    } test;
    struct {
        union {
            __u32 start_id;
            __u32 prog_id;
            __u32 map_id;
            __u32 btf_id;
        };
        __u32 next_id;
        __u32 open_flags;
    };
    struct {
        __u32 bpf_fd;
        __u32 info_len;
        __aligned_u64 info;
    } info;
    struct {
        __u32 target_fd;
        __u32 attach_type;
        __u32 query_flags;
        __u32 attach_flags;
        __aligned_u64 prog_ids;
        __u32 prog_cnt;
    } query;
    struct {
        __u64 name;
        __u32 prog_fd;
    } raw_tracepoint;
    struct {
        __aligned_u64 btf;
        __aligned_u64 btf_log_buf;
        __u32 btf_size;
        __u32 btf_log_size;
        __u32 btf_log_level;
    };
    struct {
        __u32 pid;
        __u32 fd;
        __u32 flags;
        __u32 buf_len;
        __aligned_u64 buf;
        __u32 prog_id;
        __u32 fd_type;
        __u64 probe_offset;
        __u64 probe_addr;
    } task_fd_query;
} __attribute__ ((aligned (8)));
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 299 endLine: 331
 */ 
struct __sk_buff {
    __u32 len;
    __u32 pkt_type;
    __u32 mark;
    __u32 queue_mapping;
    __u32 protocol;
    __u32 vlan_present;
    __u32 vlan_tci;
    __u32 vlan_proto;
    __u32 priority;
    __u32 ingress_ifindex;
    __u32 ifindex;
    __u32 tc_index;
    __u32 cb [5];
    __u32 hash;
    __u32 tc_classid;
    __u32 data;
    __u32 data_end;
    __u32 napi_id;
    __u32 family;
    __u32 remote_ip4;
    __u32 local_ip4;
    __u32 remote_ip6 [4];
    __u32 local_ip6 [4];
    __u32 remote_port;
    __u32 local_port;
    __u32 data_meta;
    __bpf_md_ptr (struct bpf_flow_keys *, flow_keys);
    __u64 tstamp;
    __u32 wire_len;
    __u32 gso_segs;
    __bpf_md_ptr (struct bpf_sock *, sk);
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 335 endLine: 345
 */ 
struct bpf_tunnel_key {
    __u32 tunnel_id;
    union {
        __u32 remote_ipv4;
        __u32 remote_ipv6 [4];
    };
    __u8 tunnel_tos;
    __u8 tunnel_ttl;
    __u16 tunnel_ext;
    __u32 tunnel_label;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 349 endLine: 358
 */ 
struct bpf_xfrm_state {
    __u32 reqid;
    __u32 spi;
    __u16 family;
    __u16 ext;
    union {
        __u32 remote_ipv4;
        __u32 remote_ipv6 [4];
    };
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 363 endLine: 377
 */ 
struct bpf_sock {
    __u32 bound_dev_if;
    __u32 family;
    __u32 type;
    __u32 protocol;
    __u32 mark;
    __u32 priority;
    __u32 src_ip4;
    __u32 src_ip6 [4];
    __u32 src_port;
    __u32 dst_port;
    __u32 dst_ip4;
    __u32 dst_ip6 [4];
    __u32 state;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 381 endLine: 408
 */ 
struct bpf_tcp_sock {
    __u32 snd_cwnd;
    __u32 srtt_us;
    __u32 rtt_min;
    __u32 snd_ssthresh;
    __u32 rcv_nxt;
    __u32 snd_nxt;
    __u32 snd_una;
    __u32 mss_cache;
    __u32 ecn_flags;
    __u32 rate_delivered;
    __u32 rate_interval_us;
    __u32 packets_out;
    __u32 retrans_out;
    __u32 total_retrans;
    __u32 segs_in;
    __u32 data_segs_in;
    __u32 segs_out;
    __u32 data_segs_out;
    __u32 lost_out;
    __u32 sacked_out;
    __u64 bytes_received;
    __u64 bytes_acked;
    __u32 dsack_dups;
    __u32 delivered;
    __u32 delivered_ce;
    __u32 icsk_retransmits;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 412 endLine: 427
 */ 
struct bpf_sock_tuple {
    union {
        struct {
            __be32 saddr;
            __be32 daddr;
            __be16 sport;
            __be16 dport;
        } ipv4;
        struct {
            __be32 saddr [4];
            __be32 daddr [4];
            __be16 sport;
            __be16 dport;
        } ipv6;
    };
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 431 endLine: 433
 */ 
struct bpf_xdp_sock {
    __u32 queue_id;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 439 endLine: 445
 */ 
struct xdp_md {
    __u32 data;
    __u32 data_end;
    __u32 data_meta;
    __u32 ingress_ifindex;
    __u32 rx_queue_index;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 450 endLine: 461
 */ 
struct sk_msg_md {
    __bpf_md_ptr (void *, data);
    __bpf_md_ptr (void *, data_end);
    __u32 family;
    __u32 remote_ip4;
    __u32 local_ip4;
    __u32 remote_ip6 [4];
    __u32 local_ip6 [4];
    __u32 remote_port;
    __u32 local_port;
    __u32 size;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 465 endLine: 473
 */ 
struct sk_reuseport_md {
    __bpf_md_ptr (void *, data);
    __bpf_md_ptr (void *, data_end);
    __u32 len;
    __u32 eth_protocol;
    __u32 ip_protocol;
    __u32 bind_inany;
    __u32 hash;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 478 endLine: 514
 */ 
struct bpf_prog_info {
    __u32 type;
    __u32 id;
    __u8 tag [BPF_TAG_SIZE];
    __u32 jited_prog_len;
    __u32 xlated_prog_len;
    __aligned_u64 jited_prog_insns;
    __aligned_u64 xlated_prog_insns;
    __u64 load_time;
    __u32 created_by_uid;
    __u32 nr_map_ids;
    __aligned_u64 map_ids;
    char name [BPF_OBJ_NAME_LEN];
    __u32 ifindex;
    __u32 gpl_compatible : 1;
    __u32 : 31;
    __u64 netns_dev;
    __u64 netns_ino;
    __u32 nr_jited_ksyms;
    __u32 nr_jited_func_lens;
    __aligned_u64 jited_ksyms;
    __aligned_u64 jited_func_lens;
    __u32 btf_id;
    __u32 func_info_rec_size;
    __aligned_u64 func_info;
    __u32 nr_func_info;
    __u32 nr_line_info;
    __aligned_u64 line_info;
    __aligned_u64 jited_line_info;
    __u32 nr_jited_line_info;
    __u32 line_info_rec_size;
    __u32 jited_line_info_rec_size;
    __u32 nr_prog_tags;
    __aligned_u64 prog_tags;
    __u64 run_time_ns;
    __u64 run_cnt;
} __attribute__ ((aligned (8)));
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 518 endLine: 533
 */ 
struct bpf_map_info {
    __u32 type;
    __u32 id;
    __u32 key_size;
    __u32 value_size;
    __u32 max_entries;
    __u32 map_flags;
    char name [BPF_OBJ_NAME_LEN];
    __u32 ifindex;
    __u32 : 32;
    __u64 netns_dev;
    __u64 netns_ino;
    __u32 btf_id;
    __u32 btf_key_type_id;
    __u32 btf_value_type_id;
} __attribute__ ((aligned (8)));
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 537 endLine: 541
 */ 
struct bpf_btf_info {
    __aligned_u64 btf;
    __u32 btf_size;
    __u32 id;
} __attribute__ ((aligned (8)));
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 545 endLine: 556
 */ 
struct bpf_sock_addr {
    __u32 user_family;
    __u32 user_ip4;
    __u32 user_ip6 [4];
    __u32 user_port;
    __u32 family;
    __u32 type;
    __u32 protocol;
    __u32 msg_src_ip4;
    __u32 msg_src_ip6 [4];
    __bpf_md_ptr (struct bpf_sock *, sk);
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 560 endLine: 601
 */ 
struct bpf_sock_ops {
    __u32 op;
    union {
        __u32 args [4];
        __u32 reply;
        __u32 replylong [4];
    };
    __u32 family;
    __u32 remote_ip4;
    __u32 local_ip4;
    __u32 remote_ip6 [4];
    __u32 local_ip6 [4];
    __u32 remote_port;
    __u32 local_port;
    __u32 is_fullsock;
    __u32 snd_cwnd;
    __u32 srtt_us;
    __u32 bpf_sock_ops_cb_flags;
    __u32 state;
    __u32 rtt_min;
    __u32 snd_ssthresh;
    __u32 rcv_nxt;
    __u32 snd_nxt;
    __u32 snd_una;
    __u32 mss_cache;
    __u32 ecn_flags;
    __u32 rate_delivered;
    __u32 rate_interval_us;
    __u32 packets_out;
    __u32 retrans_out;
    __u32 total_retrans;
    __u32 segs_in;
    __u32 data_segs_in;
    __u32 segs_out;
    __u32 data_segs_out;
    __u32 lost_out;
    __u32 sacked_out;
    __u32 sk_txhash;
    __u64 bytes_received;
    __u64 bytes_acked;
    __bpf_md_ptr (struct bpf_sock *, sk);
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 617 endLine: 621
 */ 
struct bpf_perf_event_value {
    __u64 counter;
    __u64 enabled;
    __u64 running;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 630 endLine: 634
 */ 
struct bpf_cgroup_dev_ctx {
    __u32 access_type;
    __u32 major;
    __u32 minor;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 638 endLine: 640
 */ 
struct bpf_raw_tracepoint_args {
    __u64 args [0];
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 647 endLine: 671
 */ 
struct bpf_fib_lookup {
    __u8 family;
    __u8 l4_protocol;
    __be16 sport;
    __be16 dport;
    __u16 tot_len;
    __u32 ifindex;
    union {
        __u8 tos;
        __be32 flowinfo;
        __u32 rt_metric;
    };
    union {
        __be32 ipv4_src;
        __u32 ipv6_src [4];
    };
    union {
        __be32 ipv4_dst;
        __u32 ipv6_dst [4];
    };
    __be16 h_vlan_proto;
    __be16 h_vlan_TCI;
    __u8 smac [6];
    __u8 dmac [6];
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 679 endLine: 702
 */ 
struct bpf_flow_keys {
    __u16 nhoff;
    __u16 thoff;
    __u16 addr_proto;
    __u8 is_frag;
    __u8 is_first_frag;
    __u8 is_encap;
    __u8 ip_proto;
    __be16 n_proto;
    __be16 sport;
    __be16 dport;
    union {
        struct {
            __be32 ipv4_src;
            __be32 ipv4_dst;
        };
        struct {
            __u32 ipv6_src [4];
            __u32 ipv6_dst [4];
        };
    };
    __u32 flags;
    __be32 flow_label;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 706 endLine: 709
 */ 
struct bpf_func_info {
    __u32 insn_off;
    __u32 type_id;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 715 endLine: 720
 */ 
struct bpf_line_info {
    __u32 insn_off;
    __u32 file_name_off;
    __u32 line_off;
    __u32 line_col;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 724 endLine: 726
 */ 
struct bpf_spin_lock {
    __u32 val;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 730 endLine: 733
 */ 
struct bpf_sysctl {
    __u32 write;
    __u32 file_pos;
};
/* Extracted from 
 ./txl_annotate/annotate_struct_test_bpf.h.out 
 startLine: 737 endLine: 745
 */ 
struct bpf_sockopt {
    __bpf_md_ptr (struct bpf_sock *, sk);
    __bpf_md_ptr (void *, optval);
    __bpf_md_ptr (void *, optval_end);
    __s32 level;
    __s32 optname;
    __s32 optlen;
    __s32 retval;
};
char _license[] SEC("license") = "GPL";
