#include "common.h"
#include "bpf/ctx/skb.h"
#define ENABLE_IPV4
#define ENABLE_NODEPORT
#define HAVE_LARGE_INSN_LIMIT
#include "node_config.h"
#include "lib/common.h"
static __u64 __now;
#define ktime_get_ns()	(__now * NSEC_PER_SEC)
#define jiffies64()	(__now)
#undef CONNTRACK_ACCOUNTING
#include "lib/conntrack.h"
#include "lib/conntrack_map.h"
#define REPORT_ALL_FLAGS 0xFF
#define REPORT_NO_FLAGS 0x0

void advance_time (void) {
    __now = __now + 1;
}

bool timeout_in (const struct ct_entry *entry, int seconds) {
    return entry->lifetime == __now + seconds;
}

CHECK ("tc", "conntrack")
int bpf_test (__maybe_unused struct __sk_buff *sctx) {
    test_init ();
    TEST ("ct_update_timeout", {struct ct_entry entry = {}; union tcp_flags flags = {}; __u32 then; int monitor; monitor = __ct_update_timeout (& entry, 1000, CT_INGRESS, flags, REPORT_ALL_FLAGS); assert (! monitor); __now += 1 + CT_REPORT_INTERVAL; monitor = __ct_update_timeout (& entry, 1000, CT_INGRESS, flags, REPORT_ALL_FLAGS); assert (monitor); assert (entry.last_rx_report == __now); assert (entry.last_tx_report == 0); assert (entry.rx_flags_seen == 0); then = __now; __now += CT_REPORT_INTERVAL; monitor = __ct_update_timeout (& entry, 1000, CT_INGRESS, flags, REPORT_ALL_FLAGS); assert (! monitor); assert (entry.last_rx_report == then); flags.value |= TCP_FLAG_SYN; monitor = __ct_update_timeout (& entry, 1000, CT_INGRESS, flags, REPORT_ALL_FLAGS); assert (monitor); assert (entry.last_rx_report == __now); assert (entry.rx_flags_seen == bpf_ntohs (TCP_FLAG_SYN)); assert (entry.last_tx_report == 0); assert (entry.tx_flags_seen == 0); monitor = __ct_update_timeout (& entry, 1000, CT_INGRESS, flags, REPORT_ALL_FLAGS); assert (! monitor); flags.value |= TCP_FLAG_FIN; monitor = __ct_update_timeout (& entry, 1000, CT_INGRESS, flags, REPORT_NO_FLAGS); assert (! monitor); assert (entry.rx_flags_seen == bpf_ntohs (TCP_FLAG_SYN)); assert (entry.tx_flags_seen == 0);});
    TEST ("ct_lookup", {#if __clang_major__ < 11 test_log ("Skipping ct_lookup test on Clang < 11 due to compiler bug"); test_skip_now (); #endif struct __ctx_buff ctx = {}; int res; struct ipv4_ct_tuple tuple = {.nexthdr = IPPROTO_TCP}; struct ct_entry ct_entry_new = {}; res = map_update_elem (get_ct_map4 (& tuple), & tuple, & ct_entry_new, BPF_ANY); if (IS_ERR (res)) test_fatal ("map_update_elem: %lld", res); struct ct_entry * entry = map_lookup_elem (get_ct_map4 (& tuple), & tuple); if (! entry) test_fatal ("ct entry lookup failed"); struct ct_state ct_state; union tcp_flags seen_flags = {0}; __u32 monitor; seen_flags.value |= TCP_FLAG_SYN; res = __ct_lookup (get_ct_map4 (& tuple), & ctx, & tuple, ACTION_CREATE, CT_INGRESS, & ct_state, true, seen_flags, & monitor); assert (res == CT_ESTABLISHED); assert (monitor == TRACE_PAYLOAD_LEN); assert (timeout_in (entry, CT_SYN_TIMEOUT)); advance_time (); res = __ct_lookup (get_ct_map4 (& tuple), & ctx, & tuple, ACTION_CREATE, CT_INGRESS, & ct_state, true, seen_flags, & monitor); assert (res == CT_ESTABLISHED); assert (monitor == 0); assert (timeout_in (entry, CT_SYN_TIMEOUT)); advance_time (); seen_flags.value &= ~ TCP_FLAG_SYN; res = __ct_lookup (get_ct_map4 (& tuple), & ctx, & tuple, ACTION_CREATE, CT_INGRESS, & ct_state, true, seen_flags, & monitor); assert (res == CT_ESTABLISHED); assert (monitor == 0); assert (timeout_in (entry, CT_CONNECTION_LIFETIME_TCP)); advance_time (); seen_flags.value |= TCP_FLAG_FIN; res = __ct_lookup (get_ct_map4 (& tuple), & ctx, & tuple, ACTION_CLOSE, CT_INGRESS, & ct_state, true, seen_flags, & monitor); assert (res == CT_ESTABLISHED); assert (monitor == TRACE_PAYLOAD_LEN); assert (timeout_in (entry, CT_CONNECTION_LIFETIME_TCP)); advance_time (); seen_flags.value &= ~ TCP_FLAG_FIN; res = __ct_lookup (get_ct_map4 (& tuple), & ctx, & tuple, ACTION_CREATE, CT_INGRESS, & ct_state, true, seen_flags, & monitor); assert (res == CT_ESTABLISHED); assert (monitor == 0); assert (timeout_in (entry, CT_CONNECTION_LIFETIME_TCP)); advance_time (); seen_flags.value |= TCP_FLAG_FIN; res = __ct_lookup (get_ct_map4 (& tuple), & ctx, & tuple, ACTION_CLOSE, CT_EGRESS, & ct_state, true, seen_flags, & monitor); assert (res == CT_ESTABLISHED); assert (monitor == TRACE_PAYLOAD_LEN); assert (timeout_in (entry, CT_CLOSE_TIMEOUT)); advance_time (); monitor = 0; seen_flags.value &= ~ TCP_FLAG_FIN; res = __ct_lookup (get_ct_map4 (& tuple), & ctx, & tuple, ACTION_CREATE, CT_EGRESS, & ct_state, true, seen_flags, & monitor); assert (res == CT_ESTABLISHED); assert (monitor == 0); assert (timeout_in (entry, CT_CLOSE_TIMEOUT - 1)); advance_time (); monitor = 0; seen_flags.value = TCP_FLAG_SYN; res = __ct_lookup (get_ct_map4 (& tuple), & ctx, & tuple, ACTION_CREATE, CT_EGRESS, & ct_state, true, seen_flags, & monitor); assert (res == CT_REOPENED); assert (monitor == TRACE_PAYLOAD_LEN); assert (timeout_in (entry, CT_CONNECTION_LIFETIME_TCP)); tuple.saddr = 123; seen_flags.value = TCP_FLAG_SYN; res = __ct_lookup (get_ct_map4 (& tuple), & ctx, & tuple, ACTION_CREATE, CT_INGRESS, & ct_state, true, seen_flags, & monitor); assert (res == CT_NEW); assert (monitor == TRACE_PAYLOAD_LEN);});
    test_finish ();
}

BPF_LICENSE ("Dual BSD/GPL");
